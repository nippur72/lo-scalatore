------- FILE C:\Users\PC\AppData\Local\Temp\xcbtmp_ABF8A21B.asm LEVEL 1 PASS 4
      1 U34b4					      PROCESSOR	6502
      2 U34b4		       01 00	   c64	      EQU	%0000000100000000
      3 U34b4		       02 00	   vic20      EQU	%0000001000000000
      4 U34b4		       02 01	   vic20_3k   EQU	%0000001000000001
      5 U34b4		       02 02	   vic20_8k   EQU	%0000001000000010
      6 U34b4		       04 00	   c264       EQU	%0000010000000000
      7 U34b4		       04 01	   cplus4     EQU	%0000010000000001
      8 U34b4		       04 02	   c16	      EQU	%0000010000000010
      9 U34b4		       08 00	   c128       EQU	%0000100000000000
     10 U34b4		       10 00	   pet	      EQU	%0001000000000000
     11 U34b4		       10 09	   pet2001    EQU	%0001000000001001
     12 U34b4		       10 10	   pet3       EQU	%0001000000010000
     13 U34b4		       10 11	   pet3008    EQU	%0001000000010001
     14 U34b4		       10 12	   pet3016    EQU	%0001000000010010
     15 U34b4		       10 14	   pet3032    EQU	%0001000000010100
     16 U34b4		       10 20	   pet4       EQU	%0001000000100000
     17 U34b4		       10 22	   pet4016    EQU	%0001000000100010
     18 U34b4		       10 24	   pet4032    EQU	%0001000000100100
     19 U34b4		       10 44	   pet8032    EQU	%0001000001000100
     20 U34b4		       02 00	   TARGET     EQU	vic20
     21 U34b4		       00 00	   USEIRQ     EQU	0
     22 U34b4		       00 00	   FASTIRQ    EQU	0
     23 U34b4		       00 00	   USESPR     EQU	0
     24 U34b4		       00 00	   USESFX     EQU	0
     25  100d ????				      SEG	"UPSTART"
     26  1001					      ORG	$1001
     27  1001		       0b 10 e5 07	      DC.W	next_line, 2021
     28  1005		       9e 34 31 30*	      DC.B	$9e, [prg_start]d, 0
     29  100b				   next_line
     30  100b		       00 00		      DC.W	0
     31  100d
     32  100d				   prg_start
     33  2bd4 ????				      SEG	"PROGRAM"
     34  100d					      ORG	prg_start
     35  100d				   FPUSH      SET	0
     36  100d				   FPULL      SET	0
      0  100d					      xbegin
      0  100d					      spreset
      1  100d		       a9 ff		      lda	#$ff
      2  100f		       85 0e		      sta	SP
      0  1011					      framereset
      1  1011		       a9 00		      lda	#<STACKFRAME_TOP
      2  1013		       85 0f		      sta	RC
      3  1015		       a9 1d		      lda	#>STACKFRAME_TOP
      4  1017		       85 10		      sta	RC + 1
      3  1019				  -	      IF	TARGET == c64
      4  1019				  -
      5  1019				  -	      lda	$01
      6  1019				  -	      and	#%11111110
      7  1019				  -	      sta	$01
      8  1019					      ENDIF
      9  1019				  -	      IF	TARGET == c128
     10  1019				  -
     11  1019				  -	      lda	#%001110
     12  1019				  -	      sta	MMU
     13  1019				  -
     14  1019				  -	      lda	#$ff
     15  1019				  -	      sta	$D8
     16  1019				  -
     17  1019				  -	      lda	INIT_STATUS
     18  1019				  -	      and	#%11111110
     19  1019				  -	      sta	INIT_STATUS
     20  1019					      ENDIF
     21  1019				  -	      IF	USEIRQ == 1
     22  1019				  -	      jsr	IRQSETUP
     23  1019					      ENDIF
     24  1019
     25  1019		       a2 25		      ldx	#[TEMP3 - CHARAC + 1]
     26  101b		       a9 00		      lda	#0
     27  101d				   .1
     28  101d		       95 16		      sta	CHARAC,x
     29  101f		       ca		      dex
     30  1020		       d0 fb		      bne	.1
      0  1022					      pstringvar	_S1
      1  1022		       a9 73		      lda	#<_S1
      2  1024		       85 02		      sta	R0
      3  1026		       a9 33		      lda	#>_S1
      4  1028		       85 03		      sta	R0 + 1
      5  102a		       ad 73 33 	      lda	_S1
      0  102d					      import	I_STRMOV
      1  102d				   I_STRMOV_IMPORTED SET	1
      7  102d		       20 93 32 	      jsr	STRMOV
      0  1030					      printstring
      1  1030		       a6 0e		      ldx	SP
      2  1032		       e8		      inx
      3  1033		       8a		      txa
      4  1034		       a0 1d		      ldy	#>STRING_WORKAREA
      0  1036					      import	I_STDLIB_PRINTSTR
      1  1036				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  1036		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  1039
      8  1039		       98		      tya
      9  103a		       18		      clc
     10  103b		       65 0e		      adc	SP
     11  103d		       85 0e		      sta	SP
      0  103f					      printnl
      1  103f		       a9 0d		      lda	#13
      0  1041					      kerncall	KERNAL_CHROUT
      1  1041		       20 d2 ff 	      jsr	KERNAL_CHROUT
     41  1041				   FPUSH      SET	1
      0  1044					      pbyte	255
      1  1044		       a9 ff		      lda	#255
      2  1046				  -	      IF	!FPUSH
      3  1046				  -	      pha
      4  1046					      ENDIF
     43  1046				   FPULL      SET	1
     44  1046				   FPUSH      SET	0
      0  1046					      poke_constaddr	$9005
      1  1046				  -	      IF	!FPULL
      2  1046				  -	      pla
      3  1046					      ENDIF
      4  1046		       8d 05 90 	      sta	$9005
     46  1046				   FPULL      SET	0
     47  1046				   FPUSH      SET	1
      0  1049					      pbyte	15
      1  1049		       a9 0f		      lda	#15
      2  104b				  -	      IF	!FPUSH
      3  104b				  -	      pha
      4  104b					      ENDIF
     49  104b				   FPULL      SET	1
     50  104b				   FPUSH      SET	0
      0  104b					      poke_constaddr	$900E
      1  104b				  -	      IF	!FPULL
      2  104b				  -	      pla
      3  104b					      ENDIF
      4  104b		       8d 0e 90 	      sta	$900E
     52  104b				   FPULL      SET	0
     53  104b				   FPUSH      SET	1
      0  104e					      pbyte	25
      1  104e		       a9 19		      lda	#25
      2  1050				  -	      IF	!FPUSH
      3  1050				  -	      pha
      4  1050					      ENDIF
     55  1050				   FPULL      SET	1
     56  1050				   FPUSH      SET	0
      0  1050					      poke_constaddr	$900F
      1  1050				  -	      IF	!FPULL
      2  1050				  -	      pla
      3  1050					      ENDIF
      4  1050		       8d 0f 90 	      sta	$900F
      0  1053					      import	I_F_src2.get_random_direction
      1  1053				   I_F_src2.get_random_direction_IMPORTED SET	1
     59  1053		       20 31 2b 	      jsr	F_src2.get_random_direction
     60  1053				   FPULL      SET	0
      0  1056					      pintvar	V_src2.get_random_direction_.get_random_direction
      0  1056					      pwordvar	V_src2.get_random_direction_.get_random_direction
      1  1056					      IF	!FPUSH
      2  1056		       ad 46 34 	      lda	V_src2.get_random_direction_.get_random_direction
      3  1059		       48		      pha
      4  105a		       ad 47 34 	      lda	V_src2.get_random_direction_.get_random_direction+1
      5  105d		       48		      pha
      6  105e				  -	      ELSE
      7  105e				  -	      lda	V_src2.get_random_direction_.get_random_direction
      8  105e				  -	      ldy	V_src2.get_random_direction_.get_random_direction+1
      9  105e					      ENDIF
      0  105e					      F_cword_int
      0  105e					      plwordvar	V_src2.dir_man
      1  105e					      IF	!FPULL
      2  105e		       68		      pla
      3  105f		       8d 53 34 	      sta	V_src2.dir_man+1
      4  1062		       68		      pla
      5  1063		       8d 52 34 	      sta	V_src2.dir_man
      6  1066				  -	      ELSE
      7  1066				  -	      sta	V_src2.dir_man
      8  1066				  -	      sty	V_src2.dir_man+1
      9  1066					      ENDIF
      0  1066					      pstringvar	_S2
      1  1066		       a9 75		      lda	#<_S2
      2  1068		       85 02		      sta	R0
      3  106a		       a9 33		      lda	#>_S2
      4  106c		       85 03		      sta	R0 + 1
      5  106e		       ad 75 33 	      lda	_S2
      0  1071					      import	I_STRMOV
      1  1071				   I_STRMOV_IMPORTED SET	1
      7  1071		       20 93 32 	      jsr	STRMOV
      0  1074					      plstringvar	V_src2.a@, 23
      1  1074		       a9 75		      lda	#<V_src2.a@
      2  1076		       85 02		      sta	R0
      3  1078		       a9 34		      lda	#>V_src2.a@
      4  107a		       85 03		      sta	R0 + 1
      5  107c		       a9 17		      lda	#23
      0  107e					      import	I_STRREMOV
      1  107e				   I_STRREMOV_IMPORTED SET	1
      7  107e		       20 aa 32 	      jsr	STRREMOV
     66  107e				   FPUSH      SET	1
      0  1081					      pbyte	1
      1  1081		       a9 01		      lda	#1
      2  1083				  -	      IF	!FPUSH
      3  1083				  -	      pha
      4  1083					      ENDIF
     68  1083				   FPULL      SET	1
     69  1083				   FPUSH      SET	0
      0  1083					      plbytevar	V_src2.level
      1  1083				  -	      IF	!FPULL
      2  1083				  -	      pla
      3  1083					      ENDIF
      4  1083		       8d 5c 34 	      sta	V_src2.level
     71  1083				   FPULL      SET	0
      0  1086					      pbyte	2
      1  1086		       a9 02		      lda	#2
      2  1088					      IF	!FPUSH
      3  1088		       48		      pha
      4  1089					      ENDIF
      0  1089					      F_cint_byte
      0  1089					      F_cword_byte
      1  1089		       a9 00		      lda	#$00
      2  108b		       48		      pha
      0  108c					      plintvar	V_src2.lives
      0  108c					      plwordvar	V_src2.lives
      1  108c					      IF	!FPULL
      2  108c		       68		      pla
      3  108d		       8d 5e 34 	      sta	V_src2.lives+1
      4  1090		       68		      pla
      5  1091		       8d 5d 34 	      sta	V_src2.lives
      6  1094				  -	      ELSE
      7  1094				  -	      sta	V_src2.lives
      8  1094				  -	      sty	V_src2.lives+1
      9  1094					      ENDIF
     75  1094				   FPUSH      SET	1
      0  1094					      pbyte	0
      1  1094		       a9 00		      lda	#0
      2  1096				  -	      IF	!FPUSH
      3  1096				  -	      pha
      4  1096					      ENDIF
     77  1096				   FPULL      SET	1
     78  1096				   FPUSH      SET	0
      0  1096					      plbytevar	V_src2.holes
      1  1096				  -	      IF	!FPULL
      2  1096				  -	      pla
      3  1096					      ENDIF
      4  1096		       8d 61 34 	      sta	V_src2.holes
     80  1096				   FPULL      SET	0
     81  1096				   FPUSH      SET	1
      0  1099					      pbyte	4
      1  1099		       a9 04		      lda	#4
      2  109b				  -	      IF	!FPUSH
      3  109b				  -	      pha
      4  109b					      ENDIF
     83  109b				   FPULL      SET	1
     84  109b				   FPUSH      SET	0
      0  109b					      plbytevar	V_src2.d
      1  109b				  -	      IF	!FPULL
      2  109b				  -	      pla
      3  109b					      ENDIF
      4  109b		       8d 68 34 	      sta	V_src2.d
     86  109b				   FPULL      SET	0
     87  109b				   FPUSH      SET	1
      0  109e					      pbyte	2
      1  109e		       a9 02		      lda	#2
      2  10a0				  -	      IF	!FPUSH
      3  10a0				  -	      pha
      4  10a0					      ENDIF
     89  10a0				   FPULL      SET	1
     90  10a0				   FPUSH      SET	0
      0  10a0					      plbytevar	[V_src2.d + 1]
      1  10a0				  -	      IF	!FPULL
      2  10a0				  -	      pla
      3  10a0					      ENDIF
      4  10a0		       8d 69 34 	      sta	[V_src2.d + 1]
     92  10a0				   FPULL      SET	0
     93  10a0				   FPUSH      SET	1
      0  10a3					      pbyte	7
      1  10a3		       a9 07		      lda	#7
      2  10a5				  -	      IF	!FPUSH
      3  10a5				  -	      pha
      4  10a5					      ENDIF
     95  10a5				   FPULL      SET	1
     96  10a5				   FPUSH      SET	0
      0  10a5					      plbytevar	[V_src2.d + 4]
      1  10a5				  -	      IF	!FPULL
      2  10a5				  -	      pla
      3  10a5					      ENDIF
      4  10a5		       8d 6c 34 	      sta	[V_src2.d + 4]
     98  10a5				   FPULL      SET	0
      0  10a8					      pbyte	1
      1  10a8		       a9 01		      lda	#1
      2  10aa					      IF	!FPUSH
      3  10aa		       48		      pha
      4  10ab					      ENDIF
      0  10ab					      F_cint_byte
      0  10ab					      F_cword_byte
      1  10ab		       a9 00		      lda	#$00
      2  10ad		       48		      pha
      0  10ae					      plintvar	V_src2.n_bonus
      0  10ae					      plwordvar	V_src2.n_bonus
      1  10ae					      IF	!FPULL
      2  10ae		       68		      pla
      3  10af		       8d 60 34 	      sta	V_src2.n_bonus+1
      4  10b2		       68		      pla
      5  10b3		       8d 5f 34 	      sta	V_src2.n_bonus
      6  10b6				  -	      ELSE
      7  10b6				  -	      sta	V_src2.n_bonus
      8  10b6				  -	      sty	V_src2.n_bonus+1
      9  10b6					      ENDIF
      0  10b6					      pint	10000
      0  10b6					      pword	10000
      1  10b6					      IF	!FPUSH
      2  10b6		       a9 10		      lda	#<10000
      3  10b8		       48		      pha
      4  10b9		       a9 27		      lda	#>10000
      5  10bb		       48		      pha
      6  10bc				  -	      ELSE
      7  10bc				  -	      lda	#<10000
      8  10bc				  -	      ldy	#>10000
      9  10bc					      ENDIF
      0  10bc					      F_cword_int
      0  10bc					      plwordvar	V_src2.bonus_multiplier
      1  10bc					      IF	!FPULL
      2  10bc		       68		      pla
      3  10bd		       8d 63 34 	      sta	V_src2.bonus_multiplier+1
      4  10c0		       68		      pla
      5  10c1		       8d 62 34 	      sta	V_src2.bonus_multiplier
      6  10c4				  -	      ELSE
      7  10c4				  -	      sta	V_src2.bonus_multiplier
      8  10c4				  -	      sty	V_src2.bonus_multiplier+1
      9  10c4					      ENDIF
      0  10c4					      import	I_F_src2.init_mem
      1  10c4				   I_F_src2.init_mem_IMPORTED SET	1
    106  10c4		       20 ae 29 	      jsr	F_src2.init_mem
    107  10c7				   L_src2.15
      0  10c7					      import	I_F_src2.draw_level
      1  10c7				   I_F_src2.draw_level_IMPORTED SET	1
    109  10c7		       20 88 20 	      jsr	F_src2.draw_level
    110  10c7				   FPUSH      SET	1
      0  10ca					      pbyte	0
      1  10ca		       a9 00		      lda	#0
      2  10cc				  -	      IF	!FPUSH
      3  10cc				  -	      pha
      4  10cc					      ENDIF
    112  10cc				   FPULL      SET	1
    113  10cc				   FPUSH      SET	0
      0  10cc					      plbytevar	V_src2.nbags
      1  10cc				  -	      IF	!FPULL
      2  10cc				  -	      pla
      3  10cc					      ENDIF
      4  10cc		       8d 5b 34 	      sta	V_src2.nbags
    115  10cc				   FPULL      SET	0
    116  10cc				   FPUSH      SET	1
      0  10cf					      pbyte	0
      1  10cf		       a9 00		      lda	#0
      2  10d1				  -	      IF	!FPUSH
      3  10d1				  -	      pha
      4  10d1					      ENDIF
    118  10d1				   FPULL      SET	1
    119  10d1				   FPUSH      SET	0
      0  10d1					      plbytevar	V_src2.cbarrel
      1  10d1				  -	      IF	!FPULL
      2  10d1				  -	      pla
      3  10d1					      ENDIF
      4  10d1		       8d 58 34 	      sta	V_src2.cbarrel
    121  10d4				   L_src2.16
    122  10d4
    123  10d4
    124  10d4
    125  10d4				   _DO_1
    126  10d4				   FPULL      SET	0
      0  10d4					      pint	8143
      0  10d4					      pword	8143
      1  10d4					      IF	!FPUSH
      2  10d4		       a9 cf		      lda	#<8143
      3  10d6		       48		      pha
      4  10d7		       a9 1f		      lda	#>8143
      5  10d9		       48		      pha
      6  10da				  -	      ELSE
      7  10da				  -	      lda	#<8143
      8  10da				  -	      ldy	#>8143
      9  10da					      ENDIF
      0  10da					      pbyte	20
      1  10da		       a9 14		      lda	#20
      2  10dc					      IF	!FPUSH
      3  10dc		       48		      pha
      4  10dd					      ENDIF
      0  10dd					      F_cword_byte
      1  10dd		       a9 00		      lda	#$00
      2  10df		       48		      pha
      0  10e0					      plwordvar	V_src2.random_word_word.limit
      1  10e0					      IF	!FPULL
      2  10e0		       68		      pla
      3  10e1		       8d 49 34 	      sta	V_src2.random_word_word.limit+1
      4  10e4		       68		      pla
      5  10e5		       8d 48 34 	      sta	V_src2.random_word_word.limit
      6  10e8				  -	      ELSE
      7  10e8				  -	      sta	V_src2.random_word_word.limit
      8  10e8				  -	      sty	V_src2.random_word_word.limit+1
      9  10e8					      ENDIF
      0  10e8					      pbyte	31
      1  10e8		       a9 1f		      lda	#31
      2  10ea					      IF	!FPUSH
      3  10ea		       48		      pha
      4  10eb					      ENDIF
      0  10eb					      F_cword_byte
      1  10eb		       a9 00		      lda	#$00
      2  10ed		       48		      pha
      0  10ee					      plwordvar	V_src2.random_word_word.mask
      1  10ee					      IF	!FPULL
      2  10ee		       68		      pla
      3  10ef		       8d 4b 34 	      sta	V_src2.random_word_word.mask+1
      4  10f2		       68		      pla
      5  10f3		       8d 4a 34 	      sta	V_src2.random_word_word.mask
      6  10f6				  -	      ELSE
      7  10f6				  -	      sta	V_src2.random_word_word.mask
      8  10f6				  -	      sty	V_src2.random_word_word.mask+1
      9  10f6					      ENDIF
      0  10f6					      import	I_F_src2.random_word_word
      1  10f6				   I_F_src2.random_word_word_IMPORTED SET	1
    135  10f6		       20 62 2b 	      jsr	F_src2.random_word_word
      0  10f9					      pwordvar	V_src2.random_word_word.random
      1  10f9					      IF	!FPUSH
      2  10f9		       ad 4c 34 	      lda	V_src2.random_word_word.random
      3  10fc		       48		      pha
      4  10fd		       ad 4d 34 	      lda	V_src2.random_word_word.random+1
      5  1100		       48		      pha
      6  1101				  -	      ELSE
      7  1101				  -	      lda	V_src2.random_word_word.random
      8  1101				  -	      ldy	V_src2.random_word_word.random+1
      9  1101					      ENDIF
      0  1101					      F_cint_word
      0  1101					      addint
      0  1101					      addword
      1  1101		       ba		      tsx
      2  1102		       bd 02 01 	      lda.wx	stack + 2
      3  1105		       18		      clc
      4  1106		       7d 04 01 	      adc.wx	stack + 4
      5  1109		       9d 04 01 	      sta.wx	stack + 4
      6  110c		       68		      pla
      7  110d		       7d 03 01 	      adc.wx	stack + 3
      8  1110		       9d 03 01 	      sta.wx	stack + 3
      9  1113		       68		      pla
      0  1114					      F_cword_int
      0  1114					      plwordvar	V_src2.pos_man
      1  1114					      IF	!FPULL
      2  1114		       68		      pla
      3  1115		       8d 51 34 	      sta	V_src2.pos_man+1
      4  1118		       68		      pla
      5  1119		       8d 50 34 	      sta	V_src2.pos_man
      6  111c				  -	      ELSE
      7  111c				  -	      sta	V_src2.pos_man
      8  111c				  -	      sty	V_src2.pos_man+1
      9  111c					      ENDIF
    141  111c				   _CO_1
    142  111c
    143  111c				   FPUSH      SET	1
      0  111c					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 22
      0  111c					      pintvar_pint_addint	V_src2.pos_man, 22
      1  111c		       ad 50 34 	      lda	V_src2.pos_man
      2  111f		       18		      clc
      3  1120		       69 16		      adc	#<22
      4  1122				  -	      IF	!FPUSH
      5  1122				  -	      pha
      6  1122					      ELSE
      7  1122		       aa		      tax
      8  1123					      ENDIF
      9  1123		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  1126		       69 00		      adc	#>22
     11  1128				  -	      IF	!FPUSH
     12  1128				  -	      pha
     13  1128					      ELSE
     14  1128		       a8		      tay
     15  1129		       8a		      txa
     16  112a					      ENDIF
    145  112a				   FPULL      SET	1
    146  112a				   FPUSH      SET	0
      0  112a					      F_peek_word
      1  112a				  -	      IF	!FPULL
      2  112a				  -	      pla
      3  112a				  -	      sta	.l + 2
      4  112a				  -	      pla
      5  112a				  -	      sta	.l + 1
      6  112a					      ELSE
      7  112a		       8d 31 11 	      sta	.l + 1
      8  112d		       8c 32 11 	      sty	.l + 2
      9  1130					      ENDIF
     10  1130		       ad ff ff    .l	      lda	$FFFF
     11  1133					      IF	!FPUSH
     12  1133		       48		      pha
     13  1134					      ENDIF
    148  1134				   FPULL      SET	0
    149  1134				   FPUSH      SET	1
      0  1134					      pbyte	62
      1  1134		       a9 3e		      lda	#62
      2  1136				  -	      IF	!FPUSH
      3  1136				  -	      pha
      4  1136					      ENDIF
    151  1136				   FPULL      SET	1
    152  1136				   FPUSH      SET	0
      0  1136					      cmpbyteeq
      1  1136				  -	      IF	!FPULL
      2  1136				  -	      pla
      3  1136					      ENDIF
      4  1136		       85 02		      sta	R0
      5  1138		       68		      pla
      6  1139		       c5 02		      cmp	R0
      7  113b		       f0 05		      beq	.pht
      0  113d					      pfalse
      1  113d		       a9 00		      lda	#$00
      2  113f					      IF	!FPUSH
      3  113f		       48		      pha
      4  1140					      ENDIF
      9  1140		       f0 03		      beq	.q
      0  1142				   .pht       ptrue
      1  1142		       a9 ff		      lda	#$FF
      2  1144					      IF	!FPUSH
      3  1144		       48		      pha
      4  1145					      ENDIF
     11  1145				   .q
    154  1145				   FPULL      SET	0
    155  1145				   FPUSH      SET	1
      0  1145					      pwordvar	V_src2.pos_man
      1  1145				  -	      IF	!FPUSH
      2  1145				  -	      lda	V_src2.pos_man
      3  1145				  -	      pha
      4  1145				  -	      lda	V_src2.pos_man+1
      5  1145				  -	      pha
      6  1145					      ELSE
      7  1145		       ad 50 34 	      lda	V_src2.pos_man
      8  1148		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  114b					      ENDIF
    157  114b				   FPULL      SET	1
    158  114b				   FPUSH      SET	0
      0  114b					      F_peek_word
      1  114b				  -	      IF	!FPULL
      2  114b				  -	      pla
      3  114b				  -	      sta	.l + 2
      4  114b				  -	      pla
      5  114b				  -	      sta	.l + 1
      6  114b					      ELSE
      7  114b		       8d 52 11 	      sta	.l + 1
      8  114e		       8c 53 11 	      sty	.l + 2
      9  1151					      ENDIF
     10  1151		       ad ff ff    .l	      lda	$FFFF
     11  1154					      IF	!FPUSH
     12  1154		       48		      pha
     13  1155					      ENDIF
    160  1155				   FPULL      SET	0
    161  1155				   FPUSH      SET	1
      0  1155					      pbyte	59
      1  1155		       a9 3b		      lda	#59
      2  1157				  -	      IF	!FPUSH
      3  1157				  -	      pha
      4  1157					      ENDIF
    163  1157				   FPULL      SET	1
      0  1157					      cmpbyteeq
      1  1157				  -	      IF	!FPULL
      2  1157				  -	      pla
      3  1157					      ENDIF
      4  1157		       85 02		      sta	R0
      5  1159		       68		      pla
      6  115a		       c5 02		      cmp	R0
      7  115c		       f0 04		      beq	.pht
      0  115e					      pfalse
      1  115e		       a9 00		      lda	#$00
      2  1160				  -	      IF	!FPUSH
      3  1160				  -	      pha
      4  1160					      ENDIF
      9  1160		       f0 02		      beq	.q
      0  1162				   .pht       ptrue
      1  1162		       a9 ff		      lda	#$FF
      2  1164				  -	      IF	!FPUSH
      3  1164				  -	      pha
      4  1164					      ENDIF
     11  1164				   .q
      0  1164					      orbyte
      1  1164				  -	      IF	!FPULL
      2  1164				  -	      pla
      3  1164					      ENDIF
      4  1164		       85 02		      sta	R0
      5  1166		       68		      pla
      6  1167		       05 02		      ora	R0
      7  1169				  -	      IF	!FPUSH
      8  1169				  -	      pha
      9  1169					      ENDIF
    166  1169				   FPUSH      SET	0
      0  1169					      cond_stmt	_ED_1, $10000
      1  1169				  -	      IF	!FPULL
      2  1169				  -	      pla
      3  1169					      ENDIF
      4  1169		       d0 03		      bne	* + 5
      5  116b				  -	      IF	$10000 > 0 && $10000 < $10000
      6  116b				  -	      jmp	$10000
      7  116b					      ELSE
      8  116b		       4c 71 11 	      jmp	_ED_1
      9  116e					      ENDIF
    168  116e		       4c d4 10 	      jmp	_DO_1
    169  1171				   _ED_1
    170  1171				   FPULL      SET	0
    171  1171				   FPUSH      SET	1
      0  1171					      pwordvar	V_src2.pos_man
      1  1171				  -	      IF	!FPUSH
      2  1171				  -	      lda	V_src2.pos_man
      3  1171				  -	      pha
      4  1171				  -	      lda	V_src2.pos_man+1
      5  1171				  -	      pha
      6  1171					      ELSE
      7  1171		       ad 50 34 	      lda	V_src2.pos_man
      8  1174		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1177					      ENDIF
    173  1177				   FPULL      SET	1
      0  1177					      F_peek_word
      1  1177				  -	      IF	!FPULL
      2  1177				  -	      pla
      3  1177				  -	      sta	.l + 2
      4  1177				  -	      pla
      5  1177				  -	      sta	.l + 1
      6  1177					      ELSE
      7  1177		       8d 7e 11 	      sta	.l + 1
      8  117a		       8c 7f 11 	      sty	.l + 2
      9  117d					      ENDIF
     10  117d		       ad ff ff    .l	      lda	$FFFF
     11  1180				  -	      IF	!FPUSH
     12  1180				  -	      pha
     13  1180					      ENDIF
    175  1180				   FPUSH      SET	0
      0  1180					      plbytevar	V_src2.t
      1  1180				  -	      IF	!FPULL
      2  1180				  -	      pla
      3  1180					      ENDIF
      4  1180		       8d 72 34 	      sta	V_src2.t
    177  1180				   FPULL      SET	0
      0  1183					      pbyte	58
      1  1183		       a9 3a		      lda	#58
      2  1185					      IF	!FPUSH
      3  1185		       48		      pha
      4  1186					      ENDIF
    179  1186				   FPUSH      SET	1
      0  1186					      pwordvar	V_src2.pos_man
      1  1186				  -	      IF	!FPUSH
      2  1186				  -	      lda	V_src2.pos_man
      3  1186				  -	      pha
      4  1186				  -	      lda	V_src2.pos_man+1
      5  1186				  -	      pha
      6  1186					      ELSE
      7  1186		       ad 50 34 	      lda	V_src2.pos_man
      8  1189		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  118c					      ENDIF
    181  118c				   FPULL      SET	1
    182  118c				   FPUSH      SET	0
      0  118c					      poke
      1  118c				  -	      IF	!FPULL
      2  118c				  -	      pla
      3  118c				  -	      sta	.l + 2
      4  118c				  -	      pla
      5  118c				  -	      sta	.l + 1
      6  118c					      ELSE
      7  118c		       8d 94 11 	      sta	.l + 1
      8  118f		       8c 95 11 	      sty	.l + 2
      9  1192					      ENDIF
     10  1192		       68		      pla
     11  1193		       8d ff ff    .l	      sta	$ffff
    184  1193				   FPULL      SET	0
      0  1196					      pbyte	0
      1  1196		       a9 00		      lda	#0
      2  1198					      IF	!FPUSH
      3  1198		       48		      pha
      4  1199					      ENDIF
      0  1199					      pwordvar	V_src2.pos_man
      1  1199					      IF	!FPUSH
      2  1199		       ad 50 34 	      lda	V_src2.pos_man
      3  119c		       48		      pha
      4  119d		       ad 51 34 	      lda	V_src2.pos_man+1
      5  11a0		       48		      pha
      6  11a1				  -	      ELSE
      7  11a1				  -	      lda	V_src2.pos_man
      8  11a1				  -	      ldy	V_src2.pos_man+1
      9  11a1					      ENDIF
      0  11a1					      F_cint_word
      0  11a1					      pint	30720
      0  11a1					      pword	30720
      1  11a1					      IF	!FPUSH
      2  11a1		       a9 00		      lda	#<30720
      3  11a3		       48		      pha
      4  11a4		       a9 78		      lda	#>30720
      5  11a6		       48		      pha
      6  11a7				  -	      ELSE
      7  11a7				  -	      lda	#<30720
      8  11a7				  -	      ldy	#>30720
      9  11a7					      ENDIF
      0  11a7					      addint
      0  11a7					      addword
      1  11a7		       ba		      tsx
      2  11a8		       bd 02 01 	      lda.wx	stack + 2
      3  11ab		       18		      clc
      4  11ac		       7d 04 01 	      adc.wx	stack + 4
      5  11af		       9d 04 01 	      sta.wx	stack + 4
      6  11b2		       68		      pla
      7  11b3		       7d 03 01 	      adc.wx	stack + 3
      8  11b6		       9d 03 01 	      sta.wx	stack + 3
      9  11b9		       68		      pla
      0  11ba					      F_cword_int
      0  11ba					      poke
      1  11ba					      IF	!FPULL
      2  11ba		       68		      pla
      3  11bb		       8d c5 11 	      sta	.l + 2
      4  11be		       68		      pla
      5  11bf		       8d c4 11 	      sta	.l + 1
      6  11c2				  -	      ELSE
      7  11c2				  -	      sta	.l + 1
      8  11c2				  -	      sty	.l + 2
      9  11c2					      ENDIF
     10  11c2		       68		      pla
     11  11c3		       8d ff ff    .l	      sta	$ffff
    192  11c6				   L_src2.newbarrel
      0  11c6					      pint	7712
      0  11c6					      pword	7712
      1  11c6					      IF	!FPUSH
      2  11c6		       a9 20		      lda	#<7712
      3  11c8		       48		      pha
      4  11c9		       a9 1e		      lda	#>7712
      5  11cb		       48		      pha
      6  11cc				  -	      ELSE
      7  11cc				  -	      lda	#<7712
      8  11cc				  -	      ldy	#>7712
      9  11cc					      ENDIF
      0  11cc					      pbytevar_pbytearrayfast	V_src2.cbarrel, V_src2.bstack
      1  11cc		       ae 58 34 	      ldx	V_src2.cbarrel
      2  11cf		       bd b2 33 	      lda	V_src2.bstack,x
      3  11d2					      IF	!FPUSH
      4  11d2		       48		      pha
      5  11d3					      ENDIF
      0  11d3					      F_cint_byte
      0  11d3					      F_cword_byte
      1  11d3		       a9 00		      lda	#$00
      2  11d5		       48		      pha
      0  11d6					      addint
      0  11d6					      addword
      1  11d6		       ba		      tsx
      2  11d7		       bd 02 01 	      lda.wx	stack + 2
      3  11da		       18		      clc
      4  11db		       7d 04 01 	      adc.wx	stack + 4
      5  11de		       9d 04 01 	      sta.wx	stack + 4
      6  11e1		       68		      pla
      7  11e2		       7d 03 01 	      adc.wx	stack + 3
      8  11e5		       9d 03 01 	      sta.wx	stack + 3
      9  11e8		       68		      pla
      0  11e9					      F_cword_int
      0  11e9					      plwordvar	V_src2.pos_barrel
      1  11e9					      IF	!FPULL
      2  11e9		       68		      pla
      3  11ea		       8d 55 34 	      sta	V_src2.pos_barrel+1
      4  11ed		       68		      pla
      5  11ee		       8d 54 34 	      sta	V_src2.pos_barrel
      6  11f1				  -	      ELSE
      7  11f1				  -	      sta	V_src2.pos_barrel
      8  11f1				  -	      sty	V_src2.pos_barrel+1
      9  11f1					      ENDIF
    199  11f1				   FPUSH      SET	1
      0  11f1					      pbyte	62
      1  11f1		       a9 3e		      lda	#62
      2  11f3				  -	      IF	!FPUSH
      3  11f3				  -	      pha
      4  11f3					      ENDIF
    201  11f3				   FPULL      SET	1
    202  11f3				   FPUSH      SET	0
      0  11f3					      plbytevar	V_src2.w
      1  11f3				  -	      IF	!FPULL
      2  11f3				  -	      pla
      3  11f3					      ENDIF
      4  11f3		       8d 6f 34 	      sta	V_src2.w
      0  11f6					      import	I_F_src2.get_random_direction
      1  11f6				   I_F_src2.get_random_direction_IMPORTED SET	1
    205  11f6		       20 31 2b 	      jsr	F_src2.get_random_direction
    206  11f6				   FPULL      SET	0
    207  11f6				   FPUSH      SET	1
      0  11f9					      pintvar	V_src2.get_random_direction_.get_random_direction
      0  11f9					      pwordvar	V_src2.get_random_direction_.get_random_direction
      1  11f9				  -	      IF	!FPUSH
      2  11f9				  -	      lda	V_src2.get_random_direction_.get_random_direction
      3  11f9				  -	      pha
      4  11f9				  -	      lda	V_src2.get_random_direction_.get_random_direction+1
      5  11f9				  -	      pha
      6  11f9					      ELSE
      7  11f9		       ad 46 34 	      lda	V_src2.get_random_direction_.get_random_direction
      8  11fc		       ac 47 34 	      ldy	V_src2.get_random_direction_.get_random_direction+1
      9  11ff					      ENDIF
    209  11ff				   FPULL      SET	1
    210  11ff				   FPUSH      SET	0
      0  11ff					      plintvar	V_src2.dir_barrel
      0  11ff					      plwordvar	V_src2.dir_barrel
      1  11ff				  -	      IF	!FPULL
      2  11ff				  -	      pla
      3  11ff				  -	      sta	V_src2.dir_barrel+1
      4  11ff				  -	      pla
      5  11ff				  -	      sta	V_src2.dir_barrel
      6  11ff					      ELSE
      7  11ff		       8d 56 34 	      sta	V_src2.dir_barrel
      8  1202		       8c 57 34 	      sty	V_src2.dir_barrel+1
      9  1205					      ENDIF
    212  1205				   L_src2.mossagiocatore
      0  1205					      import	I_F_src2.playermove
      1  1205				   I_F_src2.playermove_IMPORTED SET	1
    214  1205		       20 d6 17 	      jsr	F_src2.playermove
    215  1205				   FPULL      SET	0
    216  1205				   FPUSH      SET	1
      0  1208					      pbytevar	V_src2.playermove_.playermove
      1  1208		       ad 4e 34 	      lda	V_src2.playermove_.playermove
      2  120b				  -	      IF	!FPUSH
      3  120b				  -	      pha
      4  120b					      ENDIF
    218  120b				   FPULL      SET	1
    219  120b				   FPUSH      SET	0
      0  120b					      plbytevar	V_src2.e
      1  120b				  -	      IF	!FPULL
      2  120b				  -	      pla
      3  120b					      ENDIF
      4  120b		       8d 74 34 	      sta	V_src2.e
    221  120b				   FPULL      SET	0
    222  120b				   FPUSH      SET	1
      0  120e					      pbytevar_pbyte_cmpbyteeq	V_src2.e, 2
      1  120e		       ad 74 34 	      lda	V_src2.e
      2  1211		       c9 02		      cmp	#2
      3  1213		       f0 04		      beq	.true
      0  1215					      pfalse
      1  1215		       a9 00		      lda	#$00
      2  1217				  -	      IF	!FPUSH
      3  1217				  -	      pha
      4  1217					      ENDIF
      5  1217		       f0 02		      beq	.end
      6  1219				   .true
      0  1219					      ptrue
      1  1219		       a9 ff		      lda	#$FF
      2  121b				  -	      IF	!FPUSH
      3  121b				  -	      pha
      4  121b					      ENDIF
      8  121b				   .end
    224  121b				   FPULL      SET	1
    225  121b				   FPUSH      SET	0
      0  121b					      cond_stmt	_EI_65536, 0
      1  121b				  -	      IF	!FPULL
      2  121b				  -	      pla
      3  121b					      ENDIF
      4  121b		       d0 03		      bne	* + 5
      5  121d				  -	      IF	0 > 0 && 0 < $10000
      6  121d				  -	      jmp	0
      7  121d					      ELSE
      8  121d		       4c 23 12 	      jmp	_EI_65536
      9  1220					      ENDIF
    227  1220		       4c 6e 12 	      jmp	L_src2.morte
    228  1223
    229  1223
    230  1223
    231  1223				   _EI_65536
    232  1223
    233  1223				   FPULL      SET	0
    234  1223				   FPUSH      SET	1
      0  1223					      pbytevar_pbyte_cmpbyteeq	V_src2.e, 1
      1  1223		       ad 74 34 	      lda	V_src2.e
      2  1226		       c9 01		      cmp	#1
      3  1228		       f0 04		      beq	.true
      0  122a					      pfalse
      1  122a		       a9 00		      lda	#$00
      2  122c				  -	      IF	!FPUSH
      3  122c				  -	      pha
      4  122c					      ENDIF
      5  122c		       f0 02		      beq	.end
      6  122e				   .true
      0  122e					      ptrue
      1  122e		       a9 ff		      lda	#$FF
      2  1230				  -	      IF	!FPUSH
      3  1230				  -	      pha
      4  1230					      ENDIF
      8  1230				   .end
    236  1230				   FPULL      SET	1
    237  1230				   FPUSH      SET	0
      0  1230					      cond_stmt	_EI_65537, 0
      1  1230				  -	      IF	!FPULL
      2  1230				  -	      pla
      3  1230					      ENDIF
      4  1230		       d0 03		      bne	* + 5
      5  1232				  -	      IF	0 > 0 && 0 < $10000
      6  1232				  -	      jmp	0
      7  1232					      ELSE
      8  1232		       4c 38 12 	      jmp	_EI_65537
      9  1235					      ENDIF
    239  1235		       4c c7 10 	      jmp	L_src2.15
    240  1238
    241  1238
    242  1238
    243  1238				   _EI_65537
      0  1238					      import	I_F_src2.barrel_move
      1  1238				   I_F_src2.barrel_move_IMPORTED SET	1
    245  1238		       20 8b 1e 	      jsr	F_src2.barrel_move
    246  1238				   FPULL      SET	0
    247  1238				   FPUSH      SET	1
      0  123b					      pbytevar	V_src2.barrel_move_.barrel_move
      1  123b		       ad 4f 34 	      lda	V_src2.barrel_move_.barrel_move
      2  123e				  -	      IF	!FPUSH
      3  123e				  -	      pha
      4  123e					      ENDIF
    249  123e				   FPULL      SET	1
    250  123e				   FPUSH      SET	0
      0  123e					      plbytevar	V_src2.e
      1  123e				  -	      IF	!FPULL
      2  123e				  -	      pla
      3  123e					      ENDIF
      4  123e		       8d 74 34 	      sta	V_src2.e
    252  123e				   FPULL      SET	0
    253  123e				   FPUSH      SET	1
      0  1241					      pbytevar_pbyte_cmpbyteeq	V_src2.e, 2
      1  1241		       ad 74 34 	      lda	V_src2.e
      2  1244		       c9 02		      cmp	#2
      3  1246		       f0 04		      beq	.true
      0  1248					      pfalse
      1  1248		       a9 00		      lda	#$00
      2  124a				  -	      IF	!FPUSH
      3  124a				  -	      pha
      4  124a					      ENDIF
      5  124a		       f0 02		      beq	.end
      6  124c				   .true
      0  124c					      ptrue
      1  124c		       a9 ff		      lda	#$FF
      2  124e				  -	      IF	!FPUSH
      3  124e				  -	      pha
      4  124e					      ENDIF
      8  124e				   .end
    255  124e				   FPULL      SET	1
    256  124e				   FPUSH      SET	0
      0  124e					      cond_stmt	_EI_65538, 0
      1  124e				  -	      IF	!FPULL
      2  124e				  -	      pla
      3  124e					      ENDIF
      4  124e		       d0 03		      bne	* + 5
      5  1250				  -	      IF	0 > 0 && 0 < $10000
      6  1250				  -	      jmp	0
      7  1250					      ELSE
      8  1250		       4c 56 12 	      jmp	_EI_65538
      9  1253					      ENDIF
    258  1253		       4c 6e 12 	      jmp	L_src2.morte
    259  1256
    260  1256
    261  1256
    262  1256				   _EI_65538
    263  1256
    264  1256				   FPULL      SET	0
    265  1256				   FPUSH      SET	1
      0  1256					      pbytevar_pbyte_cmpbyteeq	V_src2.e, 3
      1  1256		       ad 74 34 	      lda	V_src2.e
      2  1259		       c9 03		      cmp	#3
      3  125b		       f0 04		      beq	.true
      0  125d					      pfalse
      1  125d		       a9 00		      lda	#$00
      2  125f				  -	      IF	!FPUSH
      3  125f				  -	      pha
      4  125f					      ENDIF
      5  125f		       f0 02		      beq	.end
      6  1261				   .true
      0  1261					      ptrue
      1  1261		       a9 ff		      lda	#$FF
      2  1263				  -	      IF	!FPUSH
      3  1263				  -	      pha
      4  1263					      ENDIF
      8  1263				   .end
    267  1263				   FPULL      SET	1
    268  1263				   FPUSH      SET	0
      0  1263					      cond_stmt	_EI_65539, 0
      1  1263				  -	      IF	!FPULL
      2  1263				  -	      pla
      3  1263					      ENDIF
      4  1263		       d0 03		      bne	* + 5
      5  1265				  -	      IF	0 > 0 && 0 < $10000
      6  1265				  -	      jmp	0
      7  1265					      ELSE
      8  1265		       4c 6b 12 	      jmp	_EI_65539
      9  1268					      ENDIF
    270  1268		       4c c6 11 	      jmp	L_src2.newbarrel
    271  126b
    272  126b
    273  126b
    274  126b				   _EI_65539
    275  126b		       4c 05 12 	      jmp	L_src2.mossagiocatore
    276  126e
    277  126e
    278  126e
    279  126e				   L_src2.morte
    280  126e				   FPULL      SET	0
    281  126e				   FPUSH      SET	1
      0  126e					      pbyte	0
      1  126e		       a9 00		      lda	#0
      2  1270				  -	      IF	!FPUSH
      3  1270				  -	      pha
      4  1270					      ENDIF
    283  1270				   FPULL      SET	1
    284  1270				   FPUSH      SET	0
      0  1270					      poke_constaddr	$900C
      1  1270				  -	      IF	!FPULL
      2  1270				  -	      pla
      3  1270					      ENDIF
      4  1270		       8d 0c 90 	      sta	$900C
    286  1270				   FPULL      SET	0
    287  1270				   FPUSH      SET	1
      0  1273					      pbyte	250
      1  1273		       a9 fa		      lda	#250
      2  1275				  -	      IF	!FPUSH
      3  1275				  -	      pha
      4  1275					      ENDIF
    289  1275				   FPULL      SET	1
    290  1275				   FPUSH      SET	0
      0  1275					      plbytevar	V_src2.freq
      1  1275				  -	      IF	!FPULL
      2  1275				  -	      pla
      3  1275					      ENDIF
      4  1275		       8d 73 34 	      sta	V_src2.freq
    292  1275				   FPULL      SET	0
    293  1275				   FPUSH      SET	1
      0  1278					      pbytevar_pbyte_cmpbyteeq	V_src2.t, 60
      1  1278		       ad 72 34 	      lda	V_src2.t
      2  127b		       c9 3c		      cmp	#60
      3  127d		       f0 04		      beq	.true
      0  127f					      pfalse
      1  127f		       a9 00		      lda	#$00
      2  1281				  -	      IF	!FPUSH
      3  1281				  -	      pha
      4  1281					      ENDIF
      5  1281		       f0 02		      beq	.end
      6  1283				   .true
      0  1283					      ptrue
      1  1283		       a9 ff		      lda	#$FF
      2  1285				  -	      IF	!FPUSH
      3  1285				  -	      pha
      4  1285					      ENDIF
      8  1285				   .end
    295  1285				   FPULL      SET	1
    296  1285				   FPUSH      SET	0
      0  1285					      cond_stmt	_EI_65540, 0
      1  1285				  -	      IF	!FPULL
      2  1285				  -	      pla
      3  1285					      ENDIF
      4  1285		       d0 03		      bne	* + 5
      5  1287				  -	      IF	0 > 0 && 0 < $10000
      6  1287				  -	      jmp	0
      7  1287					      ELSE
      8  1287		       4c 90 12 	      jmp	_EI_65540
      9  128a					      ENDIF
    298  128a				   FPULL      SET	0
    299  128a				   FPUSH      SET	1
      0  128a					      pbytevar	V_src2.w
      1  128a		       ad 6f 34 	      lda	V_src2.w
      2  128d				  -	      IF	!FPUSH
      3  128d				  -	      pha
      4  128d					      ENDIF
    301  128d				   FPULL      SET	1
    302  128d				   FPUSH      SET	0
      0  128d					      plbytevar	V_src2.t
      1  128d				  -	      IF	!FPULL
      2  128d				  -	      pla
      3  128d					      ENDIF
      4  128d		       8d 72 34 	      sta	V_src2.t
    304  1290				   _EI_65540
    305  1290
    306  1290
    307  1290
    308  1290				   _DO_2
    309  1290				   FPULL      SET	0
    310  1290				   FPUSH      SET	1
      0  1290					      pbytevar	V_src2.freq
      1  1290		       ad 73 34 	      lda	V_src2.freq
      2  1293				  -	      IF	!FPUSH
      3  1293				  -	      pha
      4  1293					      ENDIF
    312  1293				   FPULL      SET	1
    313  1293				   FPUSH      SET	0
      0  1293					      poke_constaddr	$900A
      1  1293				  -	      IF	!FPULL
      2  1293				  -	      pla
      3  1293					      ENDIF
      4  1293		       8d 0a 90 	      sta	$900A
    315  1293				   FPULL      SET	0
    316  1293				   FPUSH      SET	1
      0  1296					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 22
      0  1296					      pintvar_pint_addint	V_src2.pos_man, 22
      1  1296		       ad 50 34 	      lda	V_src2.pos_man
      2  1299		       18		      clc
      3  129a		       69 16		      adc	#<22
      4  129c				  -	      IF	!FPUSH
      5  129c				  -	      pha
      6  129c					      ELSE
      7  129c		       aa		      tax
      8  129d					      ENDIF
      9  129d		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  12a0		       69 00		      adc	#>22
     11  12a2				  -	      IF	!FPUSH
     12  12a2				  -	      pha
     13  12a2					      ELSE
     14  12a2		       a8		      tay
     15  12a3		       8a		      txa
     16  12a4					      ENDIF
    318  12a4				   FPULL      SET	1
    319  12a4				   FPUSH      SET	0
      0  12a4					      F_peek_word
      1  12a4				  -	      IF	!FPULL
      2  12a4				  -	      pla
      3  12a4				  -	      sta	.l + 2
      4  12a4				  -	      pla
      5  12a4				  -	      sta	.l + 1
      6  12a4					      ELSE
      7  12a4		       8d ab 12 	      sta	.l + 1
      8  12a7		       8c ac 12 	      sty	.l + 2
      9  12aa					      ENDIF
     10  12aa		       ad ff ff    .l	      lda	$FFFF
     11  12ad					      IF	!FPUSH
     12  12ad		       48		      pha
     13  12ae					      ENDIF
    321  12ae				   FPULL      SET	0
    322  12ae				   FPUSH      SET	1
      0  12ae					      pbyte	56
      1  12ae		       a9 38		      lda	#56
      2  12b0				  -	      IF	!FPUSH
      3  12b0				  -	      pha
      4  12b0					      ENDIF
    324  12b0				   FPULL      SET	1
    325  12b0				   FPUSH      SET	0
      0  12b0					      cmpbyteneq
      1  12b0				  -	      IF	!FPULL
      2  12b0				  -	      pla
      3  12b0					      ENDIF
      4  12b0		       85 02		      sta	R0
      5  12b2		       68		      pla
      6  12b3		       c5 02		      cmp	R0
      7  12b5		       d0 05		      bne	.pht
      0  12b7					      pfalse
      1  12b7		       a9 00		      lda	#$00
      2  12b9					      IF	!FPUSH
      3  12b9		       48		      pha
      4  12ba					      ENDIF
      9  12ba		       f0 03		      beq	.q
      0  12bc				   .pht       ptrue
      1  12bc		       a9 ff		      lda	#$FF
      2  12be					      IF	!FPUSH
      3  12be		       48		      pha
      4  12bf					      ENDIF
     11  12bf				   .q
    327  12bf				   FPULL      SET	0
      0  12bf					      pwordvar	V_src2.pos_man
      1  12bf					      IF	!FPUSH
      2  12bf		       ad 50 34 	      lda	V_src2.pos_man
      3  12c2		       48		      pha
      4  12c3		       ad 51 34 	      lda	V_src2.pos_man+1
      5  12c6		       48		      pha
      6  12c7				  -	      ELSE
      7  12c7				  -	      lda	V_src2.pos_man
      8  12c7				  -	      ldy	V_src2.pos_man+1
      9  12c7					      ENDIF
      0  12c7					      F_clong_word
      1  12c7		       a9 00		      lda	#$00
      2  12c9		       48		      pha
      0  12ca					      pint	8164
      0  12ca					      pword	8164
      1  12ca					      IF	!FPUSH
      2  12ca		       a9 e4		      lda	#<8164
      3  12cc		       48		      pha
      4  12cd		       a9 1f		      lda	#>8164
      5  12cf		       48		      pha
      6  12d0				  -	      ELSE
      7  12d0				  -	      lda	#<8164
      8  12d0				  -	      ldy	#>8164
      9  12d0					      ENDIF
      0  12d0					      F_clong_int
      1  12d0		       ba		      tsx
      2  12d1		       bd 01 01 	      lda	stack + 1,x
      3  12d4		       10 04		      bpl	.pos
      4  12d6		       a9 ff		      lda	#$ff
      5  12d8		       30 02		      bmi	.end
      6  12da				   .pos
      7  12da		       a9 00		      lda	#$00
      8  12dc				   .end
      9  12dc		       48		      pha
    332  12dc				   FPUSH      SET	1
      0  12dd					      cmplonglt
      0  12dd					      _lcomparison
      1  12dd		       ba		      tsx
      2  12de		       bd 06 01 	      lda.wx	stack+6
      3  12e1		       dd 03 01 	      cmp.wx	stack+3
      4  12e4		       bd 05 01 	      lda.wx	stack+5
      5  12e7		       fd 02 01 	      sbc.wx	stack+2
      6  12ea		       bd 04 01 	      lda.wx	stack+4
      7  12ed		       fd 01 01 	      sbc.wx	stack+1
      8  12f0		       50 02		      bvc	*+4
      9  12f2		       49 80		      eor	#$80
      2  12f4		       30 0a		      bmi	.true
      3  12f6		       8a		      txa
      4  12f7		       18		      clc
      5  12f8		       69 06		      adc	#6
      6  12fa		       aa		      tax
      7  12fb		       9a		      txs
      0  12fc					      pfalse
      1  12fc		       a9 00		      lda	#$00
      2  12fe				  -	      IF	!FPUSH
      3  12fe				  -	      pha
      4  12fe					      ENDIF
      9  12fe		       f0 08		      beq	.q
     10  1300				   .true
     11  1300		       8a		      txa
     12  1301		       18		      clc
     13  1302		       69 06		      adc	#6
     14  1304		       aa		      tax
     15  1305		       9a		      txs
      0  1306					      ptrue
      1  1306		       a9 ff		      lda	#$FF
      2  1308				  -	      IF	!FPUSH
      3  1308				  -	      pha
      4  1308					      ENDIF
     17  1308				   .q
    334  1308				   FPULL      SET	1
      0  1308					      andbyte
      1  1308				  -	      IF	!FPULL
      2  1308				  -	      pla
      3  1308					      ENDIF
      4  1308		       85 02		      sta	R0
      5  130a		       68		      pla
      6  130b		       25 02		      and	R0
      7  130d				  -	      IF	!FPUSH
      8  130d				  -	      pha
      9  130d					      ENDIF
    336  130d				   FPUSH      SET	0
      0  130d					      cond_stmt	_EI_3, _EL_3
      1  130d				  -	      IF	!FPULL
      2  130d				  -	      pla
      3  130d					      ENDIF
      4  130d		       d0 03		      bne	* + 5
      5  130f					      IF	_EL_3 > 0 && _EL_3 < $10000
      6  130f		       4c cd 13 	      jmp	_EL_3
      7  1312				  -	      ELSE
      8  1312				  -	      jmp	_EI_3
      9  1312					      ENDIF
    338  1312				   FPULL      SET	0
      0  1312					      pbytevar	V_src2.t
      1  1312		       ad 72 34 	      lda	V_src2.t
      2  1315					      IF	!FPUSH
      3  1315		       48		      pha
      4  1316					      ENDIF
    340  1316				   FPUSH      SET	1
      0  1316					      pwordvar	V_src2.pos_man
      1  1316				  -	      IF	!FPUSH
      2  1316				  -	      lda	V_src2.pos_man
      3  1316				  -	      pha
      4  1316				  -	      lda	V_src2.pos_man+1
      5  1316				  -	      pha
      6  1316					      ELSE
      7  1316		       ad 50 34 	      lda	V_src2.pos_man
      8  1319		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  131c					      ENDIF
    342  131c				   FPULL      SET	1
    343  131c				   FPUSH      SET	0
      0  131c					      poke
      1  131c				  -	      IF	!FPULL
      2  131c				  -	      pla
      3  131c				  -	      sta	.l + 2
      4  131c				  -	      pla
      5  131c				  -	      sta	.l + 1
      6  131c					      ELSE
      7  131c		       8d 24 13 	      sta	.l + 1
      8  131f		       8c 25 13 	      sty	.l + 2
      9  1322					      ENDIF
     10  1322		       68		      pla
     11  1323		       8d ff ff    .l	      sta	$ffff
    345  1323				   FPULL      SET	0
      0  1326					      pbytevar	V_src2.t
      1  1326		       ad 72 34 	      lda	V_src2.t
      2  1329					      IF	!FPUSH
      3  1329		       48		      pha
      4  132a					      ENDIF
    347  132a				   FPUSH      SET	1
      0  132a					      pbyte	56
      1  132a		       a9 38		      lda	#56
      2  132c				  -	      IF	!FPUSH
      3  132c				  -	      pha
      4  132c					      ENDIF
    349  132c				   FPULL      SET	1
      0  132c					      subbyte
      1  132c				  -	      IF	!FPULL
      2  132c				  -	      pla
      3  132c					      ENDIF
      4  132c		       85 02		      sta	R0
      5  132e		       68		      pla
      6  132f		       38		      sec
      7  1330		       e5 02		      sbc	R0
      8  1332				  -	      IF	!FPUSH
      9  1332				  -	      pha
     10  1332					      ENDIF
    351  1332				   FPUSH      SET	0
      0  1332					      pbytearrayfast	V_src2.d
      1  1332				  -	      IF	!FPULL
      2  1332				  -	      pla
      3  1332					      ENDIF
      4  1332		       aa		      tax
      5  1333		       bd 68 34 	      lda	V_src2.d,x
      6  1336					      IF	!FPUSH
      7  1336		       48		      pha
      8  1337					      ENDIF
    353  1337				   FPULL      SET	0
      0  1337					      pwordvar	V_src2.pos_man
      1  1337					      IF	!FPUSH
      2  1337		       ad 50 34 	      lda	V_src2.pos_man
      3  133a		       48		      pha
      4  133b		       ad 51 34 	      lda	V_src2.pos_man+1
      5  133e		       48		      pha
      6  133f				  -	      ELSE
      7  133f				  -	      lda	V_src2.pos_man
      8  133f				  -	      ldy	V_src2.pos_man+1
      9  133f					      ENDIF
      0  133f					      F_cint_word
      0  133f					      pint	30720
      0  133f					      pword	30720
      1  133f					      IF	!FPUSH
      2  133f		       a9 00		      lda	#<30720
      3  1341		       48		      pha
      4  1342		       a9 78		      lda	#>30720
      5  1344		       48		      pha
      6  1345				  -	      ELSE
      7  1345				  -	      lda	#<30720
      8  1345				  -	      ldy	#>30720
      9  1345					      ENDIF
      0  1345					      addint
      0  1345					      addword
      1  1345		       ba		      tsx
      2  1346		       bd 02 01 	      lda.wx	stack + 2
      3  1349		       18		      clc
      4  134a		       7d 04 01 	      adc.wx	stack + 4
      5  134d		       9d 04 01 	      sta.wx	stack + 4
      6  1350		       68		      pla
      7  1351		       7d 03 01 	      adc.wx	stack + 3
      8  1354		       9d 03 01 	      sta.wx	stack + 3
      9  1357		       68		      pla
      0  1358					      F_cword_int
      0  1358					      poke
      1  1358					      IF	!FPULL
      2  1358		       68		      pla
      3  1359		       8d 63 13 	      sta	.l + 2
      4  135c		       68		      pla
      5  135d		       8d 62 13 	      sta	.l + 1
      6  1360				  -	      ELSE
      7  1360				  -	      sta	.l + 1
      8  1360				  -	      sty	.l + 2
      9  1360					      ENDIF
     10  1360		       68		      pla
     11  1361		       8d ff ff    .l	      sta	$ffff
    360  1361				   FPUSH      SET	1
      0  1364					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 22
      0  1364					      pintvar_pint_addint	V_src2.pos_man, 22
      1  1364		       ad 50 34 	      lda	V_src2.pos_man
      2  1367		       18		      clc
      3  1368		       69 16		      adc	#<22
      4  136a				  -	      IF	!FPUSH
      5  136a				  -	      pha
      6  136a					      ELSE
      7  136a		       aa		      tax
      8  136b					      ENDIF
      9  136b		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  136e		       69 00		      adc	#>22
     11  1370				  -	      IF	!FPUSH
     12  1370				  -	      pha
     13  1370					      ELSE
     14  1370		       a8		      tay
     15  1371		       8a		      txa
     16  1372					      ENDIF
    362  1372				   FPULL      SET	1
    363  1372				   FPUSH      SET	0
      0  1372					      plwordvar	V_src2.pos_man
      1  1372				  -	      IF	!FPULL
      2  1372				  -	      pla
      3  1372				  -	      sta	V_src2.pos_man+1
      4  1372				  -	      pla
      5  1372				  -	      sta	V_src2.pos_man
      6  1372					      ELSE
      7  1372		       8d 50 34 	      sta	V_src2.pos_man
      8  1375		       8c 51 34 	      sty	V_src2.pos_man+1
      9  1378					      ENDIF
    365  1378				   FPULL      SET	0
    366  1378				   FPUSH      SET	1
      0  1378					      pwordvar	V_src2.pos_man
      1  1378				  -	      IF	!FPUSH
      2  1378				  -	      lda	V_src2.pos_man
      3  1378				  -	      pha
      4  1378				  -	      lda	V_src2.pos_man+1
      5  1378				  -	      pha
      6  1378					      ELSE
      7  1378		       ad 50 34 	      lda	V_src2.pos_man
      8  137b		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  137e					      ENDIF
    368  137e				   FPULL      SET	1
      0  137e					      F_peek_word
      1  137e				  -	      IF	!FPULL
      2  137e				  -	      pla
      3  137e				  -	      sta	.l + 2
      4  137e				  -	      pla
      5  137e				  -	      sta	.l + 1
      6  137e					      ELSE
      7  137e		       8d 85 13 	      sta	.l + 1
      8  1381		       8c 86 13 	      sty	.l + 2
      9  1384					      ENDIF
     10  1384		       ad ff ff    .l	      lda	$FFFF
     11  1387				  -	      IF	!FPUSH
     12  1387				  -	      pha
     13  1387					      ENDIF
    370  1387				   FPUSH      SET	0
      0  1387					      plbytevar	V_src2.t
      1  1387				  -	      IF	!FPULL
      2  1387				  -	      pla
      3  1387					      ENDIF
      4  1387		       8d 72 34 	      sta	V_src2.t
    372  1387				   FPULL      SET	0
      0  138a					      pbyte	58
      1  138a		       a9 3a		      lda	#58
      2  138c					      IF	!FPUSH
      3  138c		       48		      pha
      4  138d					      ENDIF
    374  138d				   FPUSH      SET	1
      0  138d					      pwordvar	V_src2.pos_man
      1  138d				  -	      IF	!FPUSH
      2  138d				  -	      lda	V_src2.pos_man
      3  138d				  -	      pha
      4  138d				  -	      lda	V_src2.pos_man+1
      5  138d				  -	      pha
      6  138d					      ELSE
      7  138d		       ad 50 34 	      lda	V_src2.pos_man
      8  1390		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1393					      ENDIF
    376  1393				   FPULL      SET	1
    377  1393				   FPUSH      SET	0
      0  1393					      poke
      1  1393				  -	      IF	!FPULL
      2  1393				  -	      pla
      3  1393				  -	      sta	.l + 2
      4  1393				  -	      pla
      5  1393				  -	      sta	.l + 1
      6  1393					      ELSE
      7  1393		       8d 9b 13 	      sta	.l + 1
      8  1396		       8c 9c 13 	      sty	.l + 2
      9  1399					      ENDIF
     10  1399		       68		      pla
     11  139a		       8d ff ff    .l	      sta	$ffff
    379  139a				   FPULL      SET	0
      0  139d					      pbyte	0
      1  139d		       a9 00		      lda	#0
      2  139f					      IF	!FPUSH
      3  139f		       48		      pha
      4  13a0					      ENDIF
      0  13a0					      pwordvar	V_src2.pos_man
      1  13a0					      IF	!FPUSH
      2  13a0		       ad 50 34 	      lda	V_src2.pos_man
      3  13a3		       48		      pha
      4  13a4		       ad 51 34 	      lda	V_src2.pos_man+1
      5  13a7		       48		      pha
      6  13a8				  -	      ELSE
      7  13a8				  -	      lda	V_src2.pos_man
      8  13a8				  -	      ldy	V_src2.pos_man+1
      9  13a8					      ENDIF
      0  13a8					      F_cint_word
      0  13a8					      pint	30720
      0  13a8					      pword	30720
      1  13a8					      IF	!FPUSH
      2  13a8		       a9 00		      lda	#<30720
      3  13aa		       48		      pha
      4  13ab		       a9 78		      lda	#>30720
      5  13ad		       48		      pha
      6  13ae				  -	      ELSE
      7  13ae				  -	      lda	#<30720
      8  13ae				  -	      ldy	#>30720
      9  13ae					      ENDIF
      0  13ae					      addint
      0  13ae					      addword
      1  13ae		       ba		      tsx
      2  13af		       bd 02 01 	      lda.wx	stack + 2
      3  13b2		       18		      clc
      4  13b3		       7d 04 01 	      adc.wx	stack + 4
      5  13b6		       9d 04 01 	      sta.wx	stack + 4
      6  13b9		       68		      pla
      7  13ba		       7d 03 01 	      adc.wx	stack + 3
      8  13bd		       9d 03 01 	      sta.wx	stack + 3
      9  13c0		       68		      pla
      0  13c1					      F_cword_int
      0  13c1					      poke
      1  13c1					      IF	!FPULL
      2  13c1		       68		      pla
      3  13c2		       8d cc 13 	      sta	.l + 2
      4  13c5		       68		      pla
      5  13c6		       8d cb 13 	      sta	.l + 1
      6  13c9				  -	      ELSE
      7  13c9				  -	      sta	.l + 1
      8  13c9				  -	      sty	.l + 2
      9  13c9					      ENDIF
     10  13c9		       68		      pla
     11  13ca		       8d ff ff    .l	      sta	$ffff
    387  13cd				   _EL_3
    388  13cd
    389  13cd
    390  13cd
    391  13cd				   _EI_3
      0  13cd					      pbyte	1
      1  13cd		       a9 01		      lda	#1
      2  13cf					      IF	!FPUSH
      3  13cf		       48		      pha
      4  13d0					      ENDIF
      0  13d0					      F_cword_byte
      1  13d0		       a9 00		      lda	#$00
      2  13d2		       48		      pha
      0  13d3					      plwordvar	V_src2.n
      1  13d3					      IF	!FPULL
      2  13d3		       68		      pla
      3  13d4		       8d 6e 34 	      sta	V_src2.n+1
      4  13d7		       68		      pla
      5  13d8		       8d 6d 34 	      sta	V_src2.n
      6  13db				  -	      ELSE
      7  13db				  -	      sta	V_src2.n
      8  13db				  -	      sty	V_src2.n+1
      9  13db					      ENDIF
    395  13db				   _FOR_4
      0  13db					      forword	4, V_src2.n, 17, "_void_", 1
      1  13db
      2  13db					      IF	1 == 1
      3  13db		       a9 11		      lda	#<17
      4  13dd		       cd 6d 34 	      cmp	V_src2.n
      5  13e0		       a9 00		      lda	#>17
      6  13e2		       ed 6e 34 	      sbc	V_src2.n + 1
      7  13e5				  -	      ELSE
      8  13e5				  -	      lda	17
      9  13e5				  -	      cmp	V_src2.n
     10  13e5				  -	      lda	17 + 1
     11  13e5				  -	      sbc	V_src2.n + 1
     12  13e5					      ENDIF
     13  13e5		       b0 03		      bcs	.enter
     14  13e7		       4c f7 13 	      jmp	_ENDFOR_4
     15  13ea				   .enter
    397  13ea
    398  13ea
    399  13ea
    400  13ea				   _CO_4
      0  13ea					      nextword	4, V_src2.n, "_void_"
      1  13ea
      2  13ea				  -	      IFCONST	"_void_"
      3  13ea				  -
      4  13ea				  -	      clc
      5  13ea				  -	      lda	"_void_"
      6  13ea				  -	      adc	V_src2.n
      7  13ea				  -	      sta	V_src2.n
      8  13ea				  -	      lda	"_void_" + 1
      9  13ea				  -	      adc	V_src2.n + 1
     10  13ea				  -	      sta	V_src2.n + 1
     11  13ea				  -
     12  13ea				  -	      bcs	_ENDFOR_4
     13  13ea					      ELSE
     14  13ea
     15  13ea		       ee 6d 34 	      inc	V_src2.n
     16  13ed		       d0 05		      bne	.skip
     17  13ef		       ee 6e 34 	      inc	V_src2.n + 1
     18  13f2
     19  13f2		       f0 03		      beq	_ENDFOR_4
     20  13f4				   .skip
     21  13f4					      ENDIF
     22  13f4		       4c db 13 	      jmp	_FOR_4
    402  13f7
    403  13f7
    404  13f7
    405  13f7				   _ENDFOR_4
    406  13f7
      0  13f7					      pbytevar_pbyte_subbyte_plbytevar	V_src2.freq, 5, V_src2.freq
      1  13f7				  -	      IF	V_src2.freq == V_src2.freq && 5 == 1
      2  13f7				  -	      dec	V_src2.freq
      3  13f7					      ELSE
      4  13f7		       ad 73 34 	      lda	V_src2.freq
      5  13fa		       38		      sec
      6  13fb		       e9 05		      sbc	#5
      7  13fd		       8d 73 34 	      sta	V_src2.freq
      8  1400					      ENDIF
    408  1400
    409  1400
    410  1400
    411  1400				   _CO_2
    412  1400
    413  1400				   FPUSH      SET	1
      0  1400					      pbytevar_pbyte_cmpbytegt	V_src2.freq, 150
      1  1400		       a9 96		      lda	#150
      2  1402		       cd 73 34 	      cmp	V_src2.freq
      3  1405		       90 04		      bcc	.true
      0  1407					      pfalse
      1  1407		       a9 00		      lda	#$00
      2  1409				  -	      IF	!FPUSH
      3  1409				  -	      pha
      4  1409					      ENDIF
      5  1409		       f0 02		      beq	.end
      6  140b				   .true
      0  140b					      ptrue
      1  140b		       a9 ff		      lda	#$FF
      2  140d				  -	      IF	!FPUSH
      3  140d				  -	      pha
      4  140d					      ENDIF
      8  140d				   .end
    415  140d				   FPULL      SET	1
    416  140d				   FPUSH      SET	0
      0  140d					      cond_stmt	_ED_2, $10000
      1  140d				  -	      IF	!FPULL
      2  140d				  -	      pla
      3  140d					      ENDIF
      4  140d		       d0 03		      bne	* + 5
      5  140f				  -	      IF	$10000 > 0 && $10000 < $10000
      6  140f				  -	      jmp	$10000
      7  140f					      ELSE
      8  140f		       4c 15 14 	      jmp	_ED_2
      9  1412					      ENDIF
    418  1412		       4c 90 12 	      jmp	_DO_2
    419  1415
    420  1415
    421  1415
    422  1415				   _ED_2
    423  1415				   FPULL      SET	0
    424  1415				   FPUSH      SET	1
      0  1415					      pbyte	0
      1  1415		       a9 00		      lda	#0
      2  1417				  -	      IF	!FPUSH
      3  1417				  -	      pha
      4  1417					      ENDIF
    426  1417				   FPULL      SET	1
    427  1417				   FPUSH      SET	0
      0  1417					      poke_constaddr	$900A
      1  1417				  -	      IF	!FPULL
      2  1417				  -	      pla
      3  1417					      ENDIF
      4  1417		       8d 0a 90 	      sta	$900A
    429  1417				   FPULL      SET	0
      0  141a					      pintvar	V_src2.lives
      0  141a					      pwordvar	V_src2.lives
      1  141a					      IF	!FPUSH
      2  141a		       ad 5d 34 	      lda	V_src2.lives
      3  141d		       48		      pha
      4  141e		       ad 5e 34 	      lda	V_src2.lives+1
      5  1421		       48		      pha
      6  1422				  -	      ELSE
      7  1422				  -	      lda	V_src2.lives
      8  1422				  -	      ldy	V_src2.lives+1
      9  1422					      ENDIF
      0  1422					      pbyte	1
      1  1422		       a9 01		      lda	#1
      2  1424					      IF	!FPUSH
      3  1424		       48		      pha
      4  1425					      ENDIF
      0  1425					      F_cint_byte
      0  1425					      F_cword_byte
      1  1425		       a9 00		      lda	#$00
      2  1427		       48		      pha
      0  1428					      subint
      0  1428					      subword
      1  1428		       ba		      tsx
      2  1429		       bd 04 01 	      lda.wx	stack + 4
      3  142c		       38		      sec
      4  142d		       fd 02 01 	      sbc.wx	stack + 2
      5  1430		       9d 04 01 	      sta.wx	stack + 4
      6  1433		       bd 03 01 	      lda.wx	stack + 3
      7  1436		       fd 01 01 	      sbc.wx	stack + 1
      8  1439		       9d 03 01 	      sta.wx	stack + 3
      9  143c		       e8		      inx
     10  143d		       e8		      inx
     11  143e		       9a		      txs
      0  143f					      plintvar	V_src2.lives
      0  143f					      plwordvar	V_src2.lives
      1  143f					      IF	!FPULL
      2  143f		       68		      pla
      3  1440		       8d 5e 34 	      sta	V_src2.lives+1
      4  1443		       68		      pla
      5  1444		       8d 5d 34 	      sta	V_src2.lives
      6  1447				  -	      ELSE
      7  1447				  -	      sta	V_src2.lives
      8  1447				  -	      sty	V_src2.lives+1
      9  1447					      ENDIF
      0  1447					      pintvar	V_src2.lives
      0  1447					      pwordvar	V_src2.lives
      1  1447					      IF	!FPUSH
      2  1447		       ad 5d 34 	      lda	V_src2.lives
      3  144a		       48		      pha
      4  144b		       ad 5e 34 	      lda	V_src2.lives+1
      5  144e		       48		      pha
      6  144f				  -	      ELSE
      7  144f				  -	      lda	V_src2.lives
      8  144f				  -	      ldy	V_src2.lives+1
      9  144f					      ENDIF
    436  144f				   FPUSH      SET	1
      0  144f					      pint	-1
      0  144f					      pword	-1
      1  144f				  -	      IF	!FPUSH
      2  144f				  -	      lda	#<-1
      3  144f				  -	      pha
      4  144f				  -	      lda	#>-1
      5  144f				  -	      pha
      6  144f					      ELSE
      7  144f		       a9 ff		      lda	#<-1
      8  1451		       a0 ff		      ldy	#>-1
      9  1453					      ENDIF
    438  1453				   FPULL      SET	1
      0  1453					      cmpinteq
      0  1453					      cmpwordeq
      1  1453				  -	      IF	!FPULL
      2  1453				  -	      pla
      3  1453				  -	      sta	R2
      4  1453				  -	      pla
      5  1453				  -	      sta	R1
      6  1453					      ELSE
      7  1453		       85 03		      sta	R1
      8  1455		       84 04		      sty	R2
      9  1457					      ENDIF
     10  1457		       68		      pla
     11  1458		       c5 04		      cmp	R2
     12  145a		       d0 09		      bne	.phf
     13  145c		       68		      pla
     14  145d		       c5 03		      cmp	R1
     15  145f		       d0 05		      bne	.phf + 1
      0  1461					      ptrue
      1  1461		       a9 ff		      lda	#$FF
      2  1463				  -	      IF	!FPUSH
      3  1463				  -	      pha
      4  1463					      ENDIF
     17  1463		       d0 03		      bne	.q
     18  1465				   .phf
     19  1465		       68		      pla
      0  1466					      pfalse
      1  1466		       a9 00		      lda	#$00
      2  1468				  -	      IF	!FPUSH
      3  1468				  -	      pha
      4  1468					      ENDIF
     21  1468				   .q
    440  1468				   FPUSH      SET	0
      0  1468					      cond_stmt	_EI_5, _EL_5
      1  1468				  -	      IF	!FPULL
      2  1468				  -	      pla
      3  1468					      ENDIF
      4  1468		       d0 03		      bne	* + 5
      5  146a					      IF	_EL_5 > 0 && _EL_5 < $10000
      6  146a		       4c dc 14 	      jmp	_EL_5
      7  146d				  -	      ELSE
      8  146d				  -	      jmp	_EI_5
      9  146d					      ENDIF
    442  146d				   FPULL      SET	0
    443  146d				   FPUSH      SET	1
      0  146d					      pbyte	255
      1  146d		       a9 ff		      lda	#255
      2  146f				  -	      IF	!FPUSH
      3  146f				  -	      pha
      4  146f					      ENDIF
    445  146f				   FPULL      SET	1
    446  146f				   FPUSH      SET	0
      0  146f					      pbytearray	V_src2.d
      0  146f					      getaddr	V_src2.d
      1  146f
      2  146f				  -	      IF	!FPULL
      3  146f				  -	      pla
      4  146f				  -	      sta	R0+1
      5  146f				  -	      pla
      6  146f				  -	      sta	R0
      7  146f					      ELSE
      8  146f		       85 02		      sta	R0
      9  1471		       84 03		      sty	R0+1
     10  1473					      ENDIF
     11  1473
     12  1473		       a9 68		      lda	#<[V_src2.d]
     13  1475		       18		      clc
     14  1476		       65 02		      adc	R0
     15  1478		       85 02		      sta	R0
     16  147a		       a9 34		      lda	#>[V_src2.d]
     17  147c		       65 03		      adc	R0+1
     18  147e		       85 03		      sta	R0+1
      2  1480
      3  1480		       a0 00		      ldy	#0
      4  1482		       b1 02		      lda	(R0),y
      5  1484					      IF	!FPUSH
      6  1484		       48		      pha
      7  1485					      ENDIF
      0  1485					      F_cword_byte
      1  1485		       a9 00		      lda	#$00
      2  1487		       48		      pha
    449  1487				   FPULL      SET	0
      0  1488					      poke
      1  1488					      IF	!FPULL
      2  1488		       68		      pla
      3  1489		       8d 93 14 	      sta	.l + 2
      4  148c		       68		      pla
      5  148d		       8d 92 14 	      sta	.l + 1
      6  1490				  -	      ELSE
      7  1490				  -	      sta	.l + 1
      8  1490				  -	      sty	.l + 2
      9  1490					      ENDIF
     10  1490		       68		      pla
     11  1491		       8d ff ff    .l	      sta	$ffff
    451  1491				   FPUSH      SET	1
      0  1494					      pbyte	240
      1  1494		       a9 f0		      lda	#240
      2  1496				  -	      IF	!FPUSH
      3  1496				  -	      pha
      4  1496					      ENDIF
    453  1496				   FPULL      SET	1
    454  1496				   FPUSH      SET	0
      0  1496					      poke_constaddr	$9005
      1  1496				  -	      IF	!FPULL
      2  1496				  -	      pla
      3  1496					      ENDIF
      4  1496		       8d 05 90 	      sta	$9005
      0  1499					      pstringvar	_S3
      1  1499		       a9 8d		      lda	#<_S3
      2  149b		       85 02		      sta	R0
      3  149d		       a9 33		      lda	#>_S3
      4  149f		       85 03		      sta	R0 + 1
      5  14a1		       ad 8d 33 	      lda	_S3
      0  14a4					      import	I_STRMOV
      1  14a4				   I_STRMOV_IMPORTED SET	1
      7  14a4		       20 93 32 	      jsr	STRMOV
      0  14a7					      printstring
      1  14a7		       a6 0e		      ldx	SP
      2  14a9		       e8		      inx
      3  14aa		       8a		      txa
      4  14ab		       a0 1d		      ldy	#>STRING_WORKAREA
      0  14ad					      import	I_STDLIB_PRINTSTR
      1  14ad				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  14ad		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  14b0
      8  14b0		       98		      tya
      9  14b1		       18		      clc
     10  14b2		       65 0e		      adc	SP
     11  14b4		       85 0e		      sta	SP
    458  14b4				   FPULL      SET	0
    459  14b4				   FPUSH      SET	1
      0  14b6					      pwordvar	V_src2.score
      1  14b6				  -	      IF	!FPUSH
      2  14b6				  -	      lda	V_src2.score
      3  14b6				  -	      pha
      4  14b6				  -	      lda	V_src2.score+1
      5  14b6				  -	      pha
      6  14b6					      ELSE
      7  14b6		       ad 59 34 	      lda	V_src2.score
      8  14b9		       ac 5a 34 	      ldy	V_src2.score+1
      9  14bc					      ENDIF
    461  14bc				   FPULL      SET	1
    462  14bc				   FPUSH      SET	0
      0  14bc					      printword
      0  14bc					      F_str@_word
      1  14bc				  -	      IF	!FPULL
      2  14bc				  -	      pla
      3  14bc				  -	      sta	R2 + 1
      4  14bc				  -	      pla
      5  14bc				  -	      sta	R2
      6  14bc					      ELSE
      7  14bc		       85 04		      sta	R2
      8  14be		       84 05		      sty	R2 + 1
      9  14c0					      ENDIF
      0  14c0					      import	I_STR_WTOS
      1  14c0				   I_STR_WTOS_IMPORTED SET	1
     11  14c0		       a2 00		      ldx	#0
     12  14c2		       20 19 32 	      jsr	STR_WTOS
      0  14c5					      printstring
      1  14c5		       a6 0e		      ldx	SP
      2  14c7		       e8		      inx
      3  14c8		       8a		      txa
      4  14c9		       a0 1d		      ldy	#>STRING_WORKAREA
      0  14cb					      import	I_STDLIB_PRINTSTR
      1  14cb				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  14cb		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  14ce
      8  14ce		       98		      tya
      9  14cf		       18		      clc
     10  14d0		       65 0e		      adc	SP
     11  14d2		       85 0e		      sta	SP
      0  14d4					      printnl
      1  14d4		       a9 0d		      lda	#13
      0  14d6					      kerncall	KERNAL_CHROUT
      1  14d6		       20 d2 ff 	      jsr	KERNAL_CHROUT
      0  14d9					      xend
      1  14d9				  -	      IF	USEIRQ == 1
      2  14d9				  -	      jsr	IRQRESET
      3  14d9					      ENDIF
      4  14d9				  -	      IF	TARGET == c64
      5  14d9				  -
      6  14d9				  -	      lda	$01
      7  14d9				  -	      ora	#%00000001
      8  14d9				  -	      sta	$01
      9  14d9					      ENDIF
     10  14d9				  -	      IF	TARGET == c128
     11  14d9				  -
     12  14d9				  -	      lda	#%0
     13  14d9				  -	      sta	MMU
     14  14d9				  -
     15  14d9				  -	      lda	#$00
     16  14d9				  -	      sta	$D8
     17  14d9				  -
     18  14d9				  -	      lda	INIT_STATUS
     19  14d9				  -	      ora	#1
     20  14d9				  -	      sta	INIT_STATUS
     21  14d9					      ENDIF
     22  14d9
     23  14d9					      IF	TARGET & vic20
     24  14d9		       6c 02 c0 	      jmp	($C002)
     25  14dc					      ENDIF
     26  14dc				  -	      IF	TARGET & c264
     27  14dc				  -	      jmp	$8003
     28  14dc					      ENDIF
     29  14dc				  -	      IF	TARGET == c64
     30  14dc				  -	      jmp	($A002)
     31  14dc					      ENDIF
     32  14dc				  -	      IF	TARGET == c128
     33  14dc				  -	      jmp	($0A00)
     34  14dc					      ENDIF
     35  14dc				  -	      IF	TARGET & pet && TARGET < pet4
     36  14dc				  -	      jmp	$C389
     37  14dc					      ENDIF
     38  14dc				  -	      IF	TARGET & pet && TARGET >= pet4
     39  14dc				  -	      jmp	$B3FF
     40  14dc					      ENDIF
    466  14dc				   _EL_5
    467  14dc
    468  14dc
    469  14dc
    470  14dc				   _EI_5
      0  14dc					      import	I_F_src2.update_score
      1  14dc				   I_F_src2.update_score_IMPORTED SET	1
    472  14dc		       20 61 2a 	      jsr	F_src2.update_score
    473  14dc				   FPULL      SET	0
      0  14df					      pbytevar	V_src2.w
      1  14df		       ad 6f 34 	      lda	V_src2.w
      2  14e2					      IF	!FPUSH
      3  14e2		       48		      pha
      4  14e3					      ENDIF
    475  14e3				   FPUSH      SET	1
      0  14e3					      pwordvar	V_src2.pos_barrel
      1  14e3				  -	      IF	!FPUSH
      2  14e3				  -	      lda	V_src2.pos_barrel
      3  14e3				  -	      pha
      4  14e3				  -	      lda	V_src2.pos_barrel+1
      5  14e3				  -	      pha
      6  14e3					      ELSE
      7  14e3		       ad 54 34 	      lda	V_src2.pos_barrel
      8  14e6		       ac 55 34 	      ldy	V_src2.pos_barrel+1
      9  14e9					      ENDIF
    477  14e9				   FPULL      SET	1
    478  14e9				   FPUSH      SET	0
      0  14e9					      poke
      1  14e9				  -	      IF	!FPULL
      2  14e9				  -	      pla
      3  14e9				  -	      sta	.l + 2
      4  14e9				  -	      pla
      5  14e9				  -	      sta	.l + 1
      6  14e9					      ELSE
      7  14e9		       8d f1 14 	      sta	.l + 1
      8  14ec		       8c f2 14 	      sty	.l + 2
      9  14ef					      ENDIF
     10  14ef		       68		      pla
     11  14f0		       8d ff ff    .l	      sta	$ffff
    480  14f0				   FPULL      SET	0
      0  14f3					      pbytevar	V_src2.w
      1  14f3		       ad 6f 34 	      lda	V_src2.w
      2  14f6					      IF	!FPUSH
      3  14f6		       48		      pha
      4  14f7					      ENDIF
    482  14f7				   FPUSH      SET	1
      0  14f7					      pbyte	56
      1  14f7		       a9 38		      lda	#56
      2  14f9				  -	      IF	!FPUSH
      3  14f9				  -	      pha
      4  14f9					      ENDIF
    484  14f9				   FPULL      SET	1
      0  14f9					      subbyte
      1  14f9				  -	      IF	!FPULL
      2  14f9				  -	      pla
      3  14f9					      ENDIF
      4  14f9		       85 02		      sta	R0
      5  14fb		       68		      pla
      6  14fc		       38		      sec
      7  14fd		       e5 02		      sbc	R0
      8  14ff				  -	      IF	!FPUSH
      9  14ff				  -	      pha
     10  14ff					      ENDIF
    486  14ff				   FPUSH      SET	0
      0  14ff					      pbytearrayfast	V_src2.d
      1  14ff				  -	      IF	!FPULL
      2  14ff				  -	      pla
      3  14ff					      ENDIF
      4  14ff		       aa		      tax
      5  1500		       bd 68 34 	      lda	V_src2.d,x
      6  1503					      IF	!FPUSH
      7  1503		       48		      pha
      8  1504					      ENDIF
    488  1504				   FPULL      SET	0
      0  1504					      pwordvar	V_src2.pos_barrel
      1  1504					      IF	!FPUSH
      2  1504		       ad 54 34 	      lda	V_src2.pos_barrel
      3  1507		       48		      pha
      4  1508		       ad 55 34 	      lda	V_src2.pos_barrel+1
      5  150b		       48		      pha
      6  150c				  -	      ELSE
      7  150c				  -	      lda	V_src2.pos_barrel
      8  150c				  -	      ldy	V_src2.pos_barrel+1
      9  150c					      ENDIF
      0  150c					      F_cint_word
      0  150c					      pint	30720
      0  150c					      pword	30720
      1  150c					      IF	!FPUSH
      2  150c		       a9 00		      lda	#<30720
      3  150e		       48		      pha
      4  150f		       a9 78		      lda	#>30720
      5  1511		       48		      pha
      6  1512				  -	      ELSE
      7  1512				  -	      lda	#<30720
      8  1512				  -	      ldy	#>30720
      9  1512					      ENDIF
      0  1512					      addint
      0  1512					      addword
      1  1512		       ba		      tsx
      2  1513		       bd 02 01 	      lda.wx	stack + 2
      3  1516		       18		      clc
      4  1517		       7d 04 01 	      adc.wx	stack + 4
      5  151a		       9d 04 01 	      sta.wx	stack + 4
      6  151d		       68		      pla
      7  151e		       7d 03 01 	      adc.wx	stack + 3
      8  1521		       9d 03 01 	      sta.wx	stack + 3
      9  1524		       68		      pla
      0  1525					      F_cword_int
      0  1525					      poke
      1  1525					      IF	!FPULL
      2  1525		       68		      pla
      3  1526		       8d 30 15 	      sta	.l + 2
      4  1529		       68		      pla
      5  152a		       8d 2f 15 	      sta	.l + 1
      6  152d				  -	      ELSE
      7  152d				  -	      sta	.l + 1
      8  152d				  -	      sty	.l + 2
      9  152d					      ENDIF
     10  152d		       68		      pla
     11  152e		       8d ff ff    .l	      sta	$ffff
      0  1531					      pbytevar_pbyte_addbyte_plbytevar	V_src2.cbarrel, 1, V_src2.cbarrel
      1  1531					      IF	V_src2.cbarrel == V_src2.cbarrel && 1 == 1
      2  1531		       ee 58 34 	      inc	V_src2.cbarrel
      3  1534				  -	      ELSE
      4  1534				  -	      lda	V_src2.cbarrel
      5  1534				  -	      clc
      6  1534				  -	      adc	#1
      7  1534				  -	      sta	V_src2.cbarrel
      8  1534					      ENDIF
    496  1534
    497  1534				   FPUSH      SET	1
      0  1534					      pbytevar_pbyte_cmpbyteeq	V_src2.w, 58
      1  1534		       ad 6f 34 	      lda	V_src2.w
      2  1537		       c9 3a		      cmp	#58
      3  1539		       f0 04		      beq	.true
      0  153b					      pfalse
      1  153b		       a9 00		      lda	#$00
      2  153d				  -	      IF	!FPUSH
      3  153d				  -	      pha
      4  153d					      ENDIF
      5  153d		       f0 02		      beq	.end
      6  153f				   .true
      0  153f					      ptrue
      1  153f		       a9 ff		      lda	#$FF
      2  1541				  -	      IF	!FPUSH
      3  1541				  -	      pha
      4  1541					      ENDIF
      8  1541				   .end
    499  1541				   FPULL      SET	1
    500  1541				   FPUSH      SET	0
      0  1541					      cond_stmt	_EI_6, _EL_6
      1  1541				  -	      IF	!FPULL
      2  1541				  -	      pla
      3  1541					      ENDIF
      4  1541		       d0 03		      bne	* + 5
      5  1543					      IF	_EL_6 > 0 && _EL_6 < $10000
      6  1543		       4c 98 15 	      jmp	_EL_6
      7  1546				  -	      ELSE
      8  1546				  -	      jmp	_EI_6
      9  1546					      ENDIF
    502  1546				   FPULL      SET	0
      0  1546					      pbytevar	V_src2.t
      1  1546		       ad 72 34 	      lda	V_src2.t
      2  1549					      IF	!FPUSH
      3  1549		       48		      pha
      4  154a					      ENDIF
    504  154a				   FPUSH      SET	1
      0  154a					      pwordvar	V_src2.pos_barrel
      1  154a				  -	      IF	!FPUSH
      2  154a				  -	      lda	V_src2.pos_barrel
      3  154a				  -	      pha
      4  154a				  -	      lda	V_src2.pos_barrel+1
      5  154a				  -	      pha
      6  154a					      ELSE
      7  154a		       ad 54 34 	      lda	V_src2.pos_barrel
      8  154d		       ac 55 34 	      ldy	V_src2.pos_barrel+1
      9  1550					      ENDIF
    506  1550				   FPULL      SET	1
    507  1550				   FPUSH      SET	0
      0  1550					      poke
      1  1550				  -	      IF	!FPULL
      2  1550				  -	      pla
      3  1550				  -	      sta	.l + 2
      4  1550				  -	      pla
      5  1550				  -	      sta	.l + 1
      6  1550					      ELSE
      7  1550		       8d 58 15 	      sta	.l + 1
      8  1553		       8c 59 15 	      sty	.l + 2
      9  1556					      ENDIF
     10  1556		       68		      pla
     11  1557		       8d ff ff    .l	      sta	$ffff
    509  1557				   FPULL      SET	0
      0  155a					      pbytevar	V_src2.t
      1  155a		       ad 72 34 	      lda	V_src2.t
      2  155d					      IF	!FPUSH
      3  155d		       48		      pha
      4  155e					      ENDIF
    511  155e				   FPUSH      SET	1
      0  155e					      pbyte	56
      1  155e		       a9 38		      lda	#56
      2  1560				  -	      IF	!FPUSH
      3  1560				  -	      pha
      4  1560					      ENDIF
    513  1560				   FPULL      SET	1
      0  1560					      subbyte
      1  1560				  -	      IF	!FPULL
      2  1560				  -	      pla
      3  1560					      ENDIF
      4  1560		       85 02		      sta	R0
      5  1562		       68		      pla
      6  1563		       38		      sec
      7  1564		       e5 02		      sbc	R0
      8  1566				  -	      IF	!FPUSH
      9  1566				  -	      pha
     10  1566					      ENDIF
    515  1566				   FPUSH      SET	0
      0  1566					      pbytearrayfast	V_src2.d
      1  1566				  -	      IF	!FPULL
      2  1566				  -	      pla
      3  1566					      ENDIF
      4  1566		       aa		      tax
      5  1567		       bd 68 34 	      lda	V_src2.d,x
      6  156a					      IF	!FPUSH
      7  156a		       48		      pha
      8  156b					      ENDIF
    517  156b				   FPULL      SET	0
      0  156b					      pwordvar	V_src2.pos_barrel
      1  156b					      IF	!FPUSH
      2  156b		       ad 54 34 	      lda	V_src2.pos_barrel
      3  156e		       48		      pha
      4  156f		       ad 55 34 	      lda	V_src2.pos_barrel+1
      5  1572		       48		      pha
      6  1573				  -	      ELSE
      7  1573				  -	      lda	V_src2.pos_barrel
      8  1573				  -	      ldy	V_src2.pos_barrel+1
      9  1573					      ENDIF
      0  1573					      F_cint_word
      0  1573					      pint	30720
      0  1573					      pword	30720
      1  1573					      IF	!FPUSH
      2  1573		       a9 00		      lda	#<30720
      3  1575		       48		      pha
      4  1576		       a9 78		      lda	#>30720
      5  1578		       48		      pha
      6  1579				  -	      ELSE
      7  1579				  -	      lda	#<30720
      8  1579				  -	      ldy	#>30720
      9  1579					      ENDIF
      0  1579					      addint
      0  1579					      addword
      1  1579		       ba		      tsx
      2  157a		       bd 02 01 	      lda.wx	stack + 2
      3  157d		       18		      clc
      4  157e		       7d 04 01 	      adc.wx	stack + 4
      5  1581		       9d 04 01 	      sta.wx	stack + 4
      6  1584		       68		      pla
      7  1585		       7d 03 01 	      adc.wx	stack + 3
      8  1588		       9d 03 01 	      sta.wx	stack + 3
      9  158b		       68		      pla
      0  158c					      F_cword_int
      0  158c					      poke
      1  158c					      IF	!FPULL
      2  158c		       68		      pla
      3  158d		       8d 97 15 	      sta	.l + 2
      4  1590		       68		      pla
      5  1591		       8d 96 15 	      sta	.l + 1
      6  1594				  -	      ELSE
      7  1594				  -	      sta	.l + 1
      8  1594				  -	      sty	.l + 2
      9  1594					      ENDIF
     10  1594		       68		      pla
     11  1595		       8d ff ff    .l	      sta	$ffff
    524  1598				   _EL_6
    525  1598
    526  1598
    527  1598
    528  1598				   _EI_6
    529  1598
    530  1598				   FPUSH      SET	1
      0  1598					      pbytevar_pbyte_cmpbytegt	V_src2.cbarrel, 10
      1  1598		       a9 0a		      lda	#10
      2  159a		       cd 58 34 	      cmp	V_src2.cbarrel
      3  159d		       90 04		      bcc	.true
      0  159f					      pfalse
      1  159f		       a9 00		      lda	#$00
      2  15a1				  -	      IF	!FPUSH
      3  15a1				  -	      pha
      4  15a1					      ENDIF
      5  15a1		       f0 02		      beq	.end
      6  15a3				   .true
      0  15a3					      ptrue
      1  15a3		       a9 ff		      lda	#$FF
      2  15a5				  -	      IF	!FPUSH
      3  15a5				  -	      pha
      4  15a5					      ENDIF
      8  15a5				   .end
    532  15a5				   FPULL      SET	1
    533  15a5				   FPUSH      SET	0
      0  15a5					      cond_stmt	_EI_65541, 0
      1  15a5				  -	      IF	!FPULL
      2  15a5				  -	      pla
      3  15a5					      ENDIF
      4  15a5		       d0 03		      bne	* + 5
      5  15a7				  -	      IF	0 > 0 && 0 < $10000
      6  15a7				  -	      jmp	0
      7  15a7					      ELSE
      8  15a7		       4c ad 15 	      jmp	_EI_65541
      9  15aa					      ENDIF
    535  15aa		       4c c7 10 	      jmp	L_src2.15
    536  15ad
    537  15ad
    538  15ad
    539  15ad				   _EI_65541
    540  15ad				   FPULL      SET	0
      0  15ad					      pwordvar	V_src2.pos_man
      1  15ad					      IF	!FPUSH
      2  15ad		       ad 50 34 	      lda	V_src2.pos_man
      3  15b0		       48		      pha
      4  15b1		       ad 51 34 	      lda	V_src2.pos_man+1
      5  15b4		       48		      pha
      6  15b5				  -	      ELSE
      7  15b5				  -	      lda	V_src2.pos_man
      8  15b5				  -	      ldy	V_src2.pos_man+1
      9  15b5					      ENDIF
      0  15b5					      F_clong_word
      1  15b5		       a9 00		      lda	#$00
      2  15b7		       48		      pha
      0  15b8					      pint	8163
      0  15b8					      pword	8163
      1  15b8					      IF	!FPUSH
      2  15b8		       a9 e3		      lda	#<8163
      3  15ba		       48		      pha
      4  15bb		       a9 1f		      lda	#>8163
      5  15bd		       48		      pha
      6  15be				  -	      ELSE
      7  15be				  -	      lda	#<8163
      8  15be				  -	      ldy	#>8163
      9  15be					      ENDIF
      0  15be					      F_clong_int
      1  15be		       ba		      tsx
      2  15bf		       bd 01 01 	      lda	stack + 1,x
      3  15c2		       10 04		      bpl	.pos
      4  15c4		       a9 ff		      lda	#$ff
      5  15c6		       30 02		      bmi	.end
      6  15c8				   .pos
      7  15c8		       a9 00		      lda	#$00
      8  15ca				   .end
      9  15ca		       48		      pha
    545  15ca				   FPUSH      SET	1
      0  15cb					      cmplonggt
      1  15cb		       ba		      tsx
      2  15cc		       bd 03 01 	      lda.wx	stack+3
      3  15cf		       dd 06 01 	      cmp.wx	stack+6
      4  15d2		       bd 02 01 	      lda.wx	stack+2
      5  15d5		       fd 05 01 	      sbc.wx	stack+5
      6  15d8		       bd 01 01 	      lda.wx	stack+1
      7  15db		       fd 04 01 	      sbc.wx	stack+4
      8  15de		       50 02		      bvc	.1
      9  15e0		       49 80		      eor	#$80
     10  15e2				   .1
     11  15e2		       30 0a		      bmi	.pht
     12  15e4		       8a		      txa
     13  15e5		       18		      clc
     14  15e6		       69 06		      adc	#6
     15  15e8		       aa		      tax
     16  15e9		       9a		      txs
      0  15ea					      pfalse
      1  15ea		       a9 00		      lda	#$00
      2  15ec				  -	      IF	!FPUSH
      3  15ec				  -	      pha
      4  15ec					      ENDIF
     18  15ec		       f0 08		      beq	.q
     19  15ee				   .pht
     20  15ee		       8a		      txa
     21  15ef		       18		      clc
     22  15f0		       69 06		      adc	#6
     23  15f2		       aa		      tax
     24  15f3		       9a		      txs
      0  15f4					      ptrue
      1  15f4		       a9 ff		      lda	#$FF
      2  15f6				  -	      IF	!FPUSH
      3  15f6				  -	      pha
      4  15f6					      ENDIF
     26  15f6				   .q
    547  15f6				   FPULL      SET	1
    548  15f6				   FPUSH      SET	0
      0  15f6					      cond_stmt	_EI_7, _EL_7
      1  15f6				  -	      IF	!FPULL
      2  15f6				  -	      pla
      3  15f6					      ENDIF
      4  15f6		       d0 03		      bne	* + 5
      5  15f8					      IF	_EL_7 > 0 && _EL_7 < $10000
      6  15f8		       4c 12 16 	      jmp	_EL_7
      7  15fb				  -	      ELSE
      8  15fb				  -	      jmp	_EI_7
      9  15fb					      ENDIF
    550  15fb				   FPULL      SET	0
      0  15fb					      pbytevar	V_src2.t
      1  15fb		       ad 72 34 	      lda	V_src2.t
      2  15fe					      IF	!FPUSH
      3  15fe		       48		      pha
      4  15ff					      ENDIF
    552  15ff				   FPUSH      SET	1
      0  15ff					      pwordvar	V_src2.pos_man
      1  15ff				  -	      IF	!FPUSH
      2  15ff				  -	      lda	V_src2.pos_man
      3  15ff				  -	      pha
      4  15ff				  -	      lda	V_src2.pos_man+1
      5  15ff				  -	      pha
      6  15ff					      ELSE
      7  15ff		       ad 50 34 	      lda	V_src2.pos_man
      8  1602		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1605					      ENDIF
    554  1605				   FPULL      SET	1
    555  1605				   FPUSH      SET	0
      0  1605					      poke
      1  1605				  -	      IF	!FPULL
      2  1605				  -	      pla
      3  1605				  -	      sta	.l + 2
      4  1605				  -	      pla
      5  1605				  -	      sta	.l + 1
      6  1605					      ELSE
      7  1605		       8d 0d 16 	      sta	.l + 1
      8  1608		       8c 0e 16 	      sty	.l + 2
      9  160b					      ENDIF
     10  160b		       68		      pla
     11  160c		       8d ff ff    .l	      sta	$ffff
    557  160f		       4c d4 10 	      jmp	L_src2.16
    558  1612				   _EL_7
    559  1612
    560  1612
    561  1612
    562  1612				   _EI_7
    563  1612				   FPULL      SET	0
      0  1612					      pbyte	58
      1  1612		       a9 3a		      lda	#58
      2  1614					      IF	!FPUSH
      3  1614		       48		      pha
      4  1615					      ENDIF
    565  1615				   FPUSH      SET	1
      0  1615					      pwordvar	V_src2.pos_man
      1  1615				  -	      IF	!FPUSH
      2  1615				  -	      lda	V_src2.pos_man
      3  1615				  -	      pha
      4  1615				  -	      lda	V_src2.pos_man+1
      5  1615				  -	      pha
      6  1615					      ELSE
      7  1615		       ad 50 34 	      lda	V_src2.pos_man
      8  1618		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  161b					      ENDIF
    567  161b				   FPULL      SET	1
    568  161b				   FPUSH      SET	0
      0  161b					      poke
      1  161b				  -	      IF	!FPULL
      2  161b				  -	      pla
      3  161b				  -	      sta	.l + 2
      4  161b				  -	      pla
      5  161b				  -	      sta	.l + 1
      6  161b					      ELSE
      7  161b		       8d 23 16 	      sta	.l + 1
      8  161e		       8c 24 16 	      sty	.l + 2
      9  1621					      ENDIF
     10  1621		       68		      pla
     11  1622		       8d ff ff    .l	      sta	$ffff
    570  1622				   FPULL      SET	0
      0  1625					      pbyte	0
      1  1625		       a9 00		      lda	#0
      2  1627					      IF	!FPUSH
      3  1627		       48		      pha
      4  1628					      ENDIF
      0  1628					      pwordvar	V_src2.pos_man
      1  1628					      IF	!FPUSH
      2  1628		       ad 50 34 	      lda	V_src2.pos_man
      3  162b		       48		      pha
      4  162c		       ad 51 34 	      lda	V_src2.pos_man+1
      5  162f		       48		      pha
      6  1630				  -	      ELSE
      7  1630				  -	      lda	V_src2.pos_man
      8  1630				  -	      ldy	V_src2.pos_man+1
      9  1630					      ENDIF
      0  1630					      F_cint_word
      0  1630					      pint	30720
      0  1630					      pword	30720
      1  1630					      IF	!FPUSH
      2  1630		       a9 00		      lda	#<30720
      3  1632		       48		      pha
      4  1633		       a9 78		      lda	#>30720
      5  1635		       48		      pha
      6  1636				  -	      ELSE
      7  1636				  -	      lda	#<30720
      8  1636				  -	      ldy	#>30720
      9  1636					      ENDIF
      0  1636					      addint
      0  1636					      addword
      1  1636		       ba		      tsx
      2  1637		       bd 02 01 	      lda.wx	stack + 2
      3  163a		       18		      clc
      4  163b		       7d 04 01 	      adc.wx	stack + 4
      5  163e		       9d 04 01 	      sta.wx	stack + 4
      6  1641		       68		      pla
      7  1642		       7d 03 01 	      adc.wx	stack + 3
      8  1645		       9d 03 01 	      sta.wx	stack + 3
      9  1648		       68		      pla
      0  1649					      F_cword_int
      0  1649					      poke
      1  1649					      IF	!FPULL
      2  1649		       68		      pla
      3  164a		       8d 54 16 	      sta	.l + 2
      4  164d		       68		      pla
      5  164e		       8d 53 16 	      sta	.l + 1
      6  1651				  -	      ELSE
      7  1651				  -	      sta	.l + 1
      8  1651				  -	      sty	.l + 2
      9  1651					      ENDIF
     10  1651		       68		      pla
     11  1652		       8d ff ff    .l	      sta	$ffff
    578  1655		       4c c6 11 	      jmp	L_src2.newbarrel
    579  1658				   L_src2.newlevel
      0  1658					      pbytevar	V_src2.cbarrel
      1  1658		       ad 58 34 	      lda	V_src2.cbarrel
      2  165b					      IF	!FPUSH
      3  165b		       48		      pha
      4  165c					      ENDIF
      0  165c					      pbyte	12
      1  165c		       a9 0c		      lda	#12
      2  165e					      IF	!FPUSH
      3  165e		       48		      pha
      4  165f					      ENDIF
    582  165f				   FPUSH      SET	1
      0  165f					      pbyte	1
      1  165f		       a9 01		      lda	#1
      2  1661				  -	      IF	!FPUSH
      3  1661				  -	      pha
      4  1661					      ENDIF
    584  1661				   FPULL      SET	1
      0  1661					      subbyte
      1  1661				  -	      IF	!FPULL
      2  1661				  -	      pla
      3  1661					      ENDIF
      4  1661		       85 02		      sta	R0
      5  1663		       68		      pla
      6  1664		       38		      sec
      7  1665		       e5 02		      sbc	R0
      8  1667				  -	      IF	!FPUSH
      9  1667				  -	      pha
     10  1667					      ENDIF
      0  1667					      cmpbytelt
      1  1667				  -	      IF	!FPULL
      2  1667				  -	      pla
      3  1667					      ENDIF
      4  1667		       85 02		      sta	R0
      5  1669		       68		      pla
      6  166a		       c5 02		      cmp	R0
      7  166c		       b0 04		      bcs	.phf
      0  166e					      ptrue
      1  166e		       a9 ff		      lda	#$FF
      2  1670				  -	      IF	!FPUSH
      3  1670				  -	      pha
      4  1670					      ENDIF
      9  1670		       d0 02		      bne	.q
      0  1672				   .phf       pfalse
      1  1672		       a9 00		      lda	#$00
      2  1674				  -	      IF	!FPUSH
      3  1674				  -	      pha
      4  1674					      ENDIF
     11  1674				   .q
    587  1674				   FPUSH      SET	0
      0  1674					      cond_stmt	_EI_8, _EL_8
      1  1674				  -	      IF	!FPULL
      2  1674				  -	      pla
      3  1674					      ENDIF
      4  1674		       d0 03		      bne	* + 5
      5  1676					      IF	_EL_8 > 0 && _EL_8 < $10000
      6  1676		       4c 46 17 	      jmp	_EL_8
      7  1679				  -	      ELSE
      8  1679				  -	      jmp	_EI_8
      9  1679					      ENDIF
    589  1679				   FPULL      SET	0
      0  1679					      pbytevar	V_src2.cbarrel
      1  1679		       ad 58 34 	      lda	V_src2.cbarrel
      2  167c					      IF	!FPUSH
      3  167c		       48		      pha
      4  167d					      ENDIF
    591  167d				   FPUSH      SET	1
      0  167d					      pbyte	1
      1  167d		       a9 01		      lda	#1
      2  167f				  -	      IF	!FPUSH
      3  167f				  -	      pha
      4  167f					      ENDIF
    593  167f				   FPULL      SET	1
    594  167f				   FPUSH      SET	0
      0  167f					      addbyte
      1  167f				  -	      IF	!FPULL
      2  167f				  -	      pla
      3  167f					      ENDIF
      4  167f		       85 02		      sta	R0
      5  1681		       68		      pla
      6  1682		       18		      clc
      7  1683		       65 02		      adc	R0
      8  1685					      IF	!FPUSH
      9  1685		       48		      pha
     10  1686					      ENDIF
      0  1686					      F_cword_byte
      1  1686		       a9 00		      lda	#$00
      2  1688		       48		      pha
    597  1688				   FPULL      SET	0
      0  1689					      plwordvar	V_src2.n
      1  1689					      IF	!FPULL
      2  1689		       68		      pla
      3  168a		       8d 6e 34 	      sta	V_src2.n+1
      4  168d		       68		      pla
      5  168e		       8d 6d 34 	      sta	V_src2.n
      6  1691				  -	      ELSE
      7  1691				  -	      sta	V_src2.n
      8  1691				  -	      sty	V_src2.n+1
      9  1691					      ENDIF
      0  1691					      pbyte	12
      1  1691		       a9 0c		      lda	#12
      2  1693					      IF	!FPUSH
      3  1693		       48		      pha
      4  1694					      ENDIF
    600  1694				   FPUSH      SET	1
      0  1694					      pbyte	1
      1  1694		       a9 01		      lda	#1
      2  1696				  -	      IF	!FPUSH
      3  1696				  -	      pha
      4  1696					      ENDIF
    602  1696				   FPULL      SET	1
    603  1696				   FPUSH      SET	0
      0  1696					      subbyte
      1  1696				  -	      IF	!FPULL
      2  1696				  -	      pla
      3  1696					      ENDIF
      4  1696		       85 02		      sta	R0
      5  1698		       68		      pla
      6  1699		       38		      sec
      7  169a		       e5 02		      sbc	R0
      8  169c					      IF	!FPUSH
      9  169c		       48		      pha
     10  169d					      ENDIF
      0  169d					      F_cword_byte
      1  169d		       a9 00		      lda	#$00
      2  169f		       48		      pha
    606  169f				   FPULL      SET	0
      0  16a0					      plwordvar	X_src2.forlim9
      1  16a0					      IF	!FPULL
      2  16a0		       68		      pla
      3  16a1		       8d 8f 34 	      sta	X_src2.forlim9+1
      4  16a4		       68		      pla
      5  16a5		       8d 8e 34 	      sta	X_src2.forlim9
      6  16a8				  -	      ELSE
      7  16a8				  -	      sta	X_src2.forlim9
      8  16a8				  -	      sty	X_src2.forlim9+1
      9  16a8					      ENDIF
    608  16a8				   _FOR_9
      0  16a8					      forword	9, V_src2.n, X_src2.forlim9, "_void_", 0
      1  16a8
      2  16a8				  -	      IF	0 == 1
      3  16a8				  -	      lda	#<X_src2.forlim9
      4  16a8				  -	      cmp	V_src2.n
      5  16a8				  -	      lda	#>X_src2.forlim9
      6  16a8				  -	      sbc	V_src2.n + 1
      7  16a8					      ELSE
      8  16a8		       ad 8e 34 	      lda	X_src2.forlim9
      9  16ab		       cd 6d 34 	      cmp	V_src2.n
     10  16ae		       ad 8f 34 	      lda	X_src2.forlim9 + 1
     11  16b1		       ed 6e 34 	      sbc	V_src2.n + 1
     12  16b4					      ENDIF
     13  16b4		       b0 03		      bcs	.enter
     14  16b6		       4c 46 17 	      jmp	_ENDFOR_9
     15  16b9				   .enter
      0  16b9					      pbyte	62
      1  16b9		       a9 3e		      lda	#62
      2  16bb					      IF	!FPUSH
      3  16bb		       48		      pha
      4  16bc					      ENDIF
      0  16bc					      pint	7712
      0  16bc					      pword	7712
      1  16bc					      IF	!FPUSH
      2  16bc		       a9 20		      lda	#<7712
      3  16be		       48		      pha
      4  16bf		       a9 1e		      lda	#>7712
      5  16c1		       48		      pha
      6  16c2				  -	      ELSE
      7  16c2				  -	      lda	#<7712
      8  16c2				  -	      ldy	#>7712
      9  16c2					      ENDIF
      0  16c2					      pwordvar	V_src2.n
      1  16c2					      IF	!FPUSH
      2  16c2		       ad 6d 34 	      lda	V_src2.n
      3  16c5		       48		      pha
      4  16c6		       ad 6e 34 	      lda	V_src2.n+1
      5  16c9		       48		      pha
      6  16ca				  -	      ELSE
      7  16ca				  -	      lda	V_src2.n
      8  16ca				  -	      ldy	V_src2.n+1
      9  16ca					      ENDIF
      0  16ca					      F_cbyte_word
      1  16ca		       68		      pla
      0  16cb					      pbytearrayfast	V_src2.bstack
      1  16cb					      IF	!FPULL
      2  16cb		       68		      pla
      3  16cc					      ENDIF
      4  16cc		       aa		      tax
      5  16cd		       bd b2 33 	      lda	V_src2.bstack,x
      6  16d0					      IF	!FPUSH
      7  16d0		       48		      pha
      8  16d1					      ENDIF
      0  16d1					      F_cint_byte
      0  16d1					      F_cword_byte
      1  16d1		       a9 00		      lda	#$00
      2  16d3		       48		      pha
      0  16d4					      addint
      0  16d4					      addword
      1  16d4		       ba		      tsx
      2  16d5		       bd 02 01 	      lda.wx	stack + 2
      3  16d8		       18		      clc
      4  16d9		       7d 04 01 	      adc.wx	stack + 4
      5  16dc		       9d 04 01 	      sta.wx	stack + 4
      6  16df		       68		      pla
      7  16e0		       7d 03 01 	      adc.wx	stack + 3
      8  16e3		       9d 03 01 	      sta.wx	stack + 3
      9  16e6		       68		      pla
      0  16e7					      F_cword_int
      0  16e7					      poke
      1  16e7					      IF	!FPULL
      2  16e7		       68		      pla
      3  16e8		       8d f2 16 	      sta	.l + 2
      4  16eb		       68		      pla
      5  16ec		       8d f1 16 	      sta	.l + 1
      6  16ef				  -	      ELSE
      7  16ef				  -	      sta	.l + 1
      8  16ef				  -	      sty	.l + 2
      9  16ef					      ENDIF
     10  16ef		       68		      pla
     11  16f0		       8d ff ff    .l	      sta	$ffff
    619  16f0				   FPUSH      SET	1
      0  16f3					      pwordvar_pbyte_F_cword_byte_addword	V_src2.score, 100
      0  16f3					      pintvar_pint_addint	V_src2.score, 100
      1  16f3		       ad 59 34 	      lda	V_src2.score
      2  16f6		       18		      clc
      3  16f7		       69 64		      adc	#<100
      4  16f9				  -	      IF	!FPUSH
      5  16f9				  -	      pha
      6  16f9					      ELSE
      7  16f9		       aa		      tax
      8  16fa					      ENDIF
      9  16fa		       ad 5a 34 	      lda	V_src2.score + 1
     10  16fd		       69 00		      adc	#>100
     11  16ff				  -	      IF	!FPUSH
     12  16ff				  -	      pha
     13  16ff					      ELSE
     14  16ff		       a8		      tay
     15  1700		       8a		      txa
     16  1701					      ENDIF
    621  1701				   FPULL      SET	1
    622  1701				   FPUSH      SET	0
      0  1701					      plwordvar	V_src2.score
      1  1701				  -	      IF	!FPULL
      2  1701				  -	      pla
      3  1701				  -	      sta	V_src2.score+1
      4  1701				  -	      pla
      5  1701				  -	      sta	V_src2.score
      6  1701					      ELSE
      7  1701		       8d 59 34 	      sta	V_src2.score
      8  1704		       8c 5a 34 	      sty	V_src2.score+1
      9  1707					      ENDIF
      0  1707					      import	I_F_src2.update_score
      1  1707				   I_F_src2.update_score_IMPORTED SET	1
    625  1707		       20 61 2a 	      jsr	F_src2.update_score
      0  170a					      import	I_F_src2.check_bonus_vita
      1  170a				   I_F_src2.check_bonus_vita_IMPORTED SET	1
    627  170a		       20 19 29 	      jsr	F_src2.check_bonus_vita
    628  170a				   FPULL      SET	0
    629  170a				   FPUSH      SET	1
      0  170d					      pbyte	250
      1  170d		       a9 fa		      lda	#250
      2  170f				  -	      IF	!FPUSH
      3  170f				  -	      pha
      4  170f					      ENDIF
    631  170f				   FPULL      SET	1
    632  170f				   FPUSH      SET	0
      0  170f					      poke_constaddr	$900D
      1  170f				  -	      IF	!FPULL
      2  170f				  -	      pla
      3  170f					      ENDIF
      4  170f		       8d 0d 90 	      sta	$900D
    634  170f				   FPULL      SET	0
    635  170f				   FPUSH      SET	1
      0  1712					      pbyte	240
      1  1712		       a9 f0		      lda	#240
      2  1714				  -	      IF	!FPUSH
      3  1714				  -	      pha
      4  1714					      ENDIF
    637  1714				   FPULL      SET	1
    638  1714				   FPUSH      SET	0
      0  1714					      plbytevar	V_src2.m
      1  1714				  -	      IF	!FPULL
      2  1714				  -	      pla
      3  1714					      ENDIF
      4  1714		       8d 70 34 	      sta	V_src2.m
    640  1717				   _FOR_10
      0  1717					      forbyte	10, V_src2.m, 250, "_void_", 1
      1  1717
      2  1717					      IF	1 == 1
      3  1717		       a9 fa		      lda	#250
      4  1719				  -	      ELSE
      5  1719				  -	      lda	250
      6  1719					      ENDIF
      7  1719		       cd 70 34 	      cmp	V_src2.m
      8  171c		       b0 03		      bcs	.enter
      9  171e
     10  171e		       4c 2f 17 	      jmp	_ENDFOR_10
     11  1721				   .enter
    642  1721				   FPULL      SET	0
    643  1721				   FPUSH      SET	1
      0  1721					      pbytevar	V_src2.m
      1  1721		       ad 70 34 	      lda	V_src2.m
      2  1724				  -	      IF	!FPUSH
      3  1724				  -	      pha
      4  1724					      ENDIF
    645  1724				   FPULL      SET	1
    646  1724				   FPUSH      SET	0
      0  1724					      poke_constaddr	$900C
      1  1724				  -	      IF	!FPULL
      2  1724				  -	      pla
      3  1724					      ENDIF
      4  1724		       8d 0c 90 	      sta	$900C
    648  1727				   _CO_10
      0  1727					      nextbyte	10, V_src2.m, "_void_"
      1  1727
      2  1727				  -	      IFCONST	"_void_"
      3  1727				  -
      4  1727				  -	      clc
      5  1727				  -	      lda	"_void_"
      6  1727				  -	      adc	V_src2.m
      7  1727				  -	      sta	V_src2.m
      8  1727				  -
      9  1727				  -	      bcs	_ENDFOR_10
     10  1727					      ELSE
     11  1727
     12  1727		       ee 70 34 	      inc	V_src2.m
     13  172a
     14  172a		       f0 03		      beq	_ENDFOR_10
     15  172c					      ENDIF
     16  172c		       4c 17 17 	      jmp	_FOR_10
    650  172f
    651  172f
    652  172f
    653  172f				   _ENDFOR_10
    654  172f				   FPULL      SET	0
    655  172f				   FPUSH      SET	1
      0  172f					      pbyte	0
      1  172f		       a9 00		      lda	#0
      2  1731				  -	      IF	!FPUSH
      3  1731				  -	      pha
      4  1731					      ENDIF
    657  1731				   FPULL      SET	1
    658  1731				   FPUSH      SET	0
      0  1731					      poke_constaddr	$900C
      1  1731				  -	      IF	!FPULL
      2  1731				  -	      pla
      3  1731					      ENDIF
      4  1731		       8d 0c 90 	      sta	$900C
    660  1731				   FPULL      SET	0
    661  1731				   FPUSH      SET	1
      0  1734					      pbyte	0
      1  1734		       a9 00		      lda	#0
      2  1736				  -	      IF	!FPUSH
      3  1736				  -	      pha
      4  1736					      ENDIF
    663  1736				   FPULL      SET	1
    664  1736				   FPUSH      SET	0
      0  1736					      poke_constaddr	$900D
      1  1736				  -	      IF	!FPULL
      2  1736				  -	      pla
      3  1736					      ENDIF
      4  1736		       8d 0d 90 	      sta	$900D
    666  1739				   _CO_9
      0  1739					      nextword	9, V_src2.n, "_void_"
      1  1739
      2  1739				  -	      IFCONST	"_void_"
      3  1739				  -
      4  1739				  -	      clc
      5  1739				  -	      lda	"_void_"
      6  1739				  -	      adc	V_src2.n
      7  1739				  -	      sta	V_src2.n
      8  1739				  -	      lda	"_void_" + 1
      9  1739				  -	      adc	V_src2.n + 1
     10  1739				  -	      sta	V_src2.n + 1
     11  1739				  -
     12  1739				  -	      bcs	_ENDFOR_9
     13  1739					      ELSE
     14  1739
     15  1739		       ee 6d 34 	      inc	V_src2.n
     16  173c		       d0 05		      bne	.skip
     17  173e		       ee 6e 34 	      inc	V_src2.n + 1
     18  1741
     19  1741		       f0 03		      beq	_ENDFOR_9
     20  1743				   .skip
     21  1743					      ENDIF
     22  1743		       4c a8 16 	      jmp	_FOR_9
    668  1746
    669  1746
    670  1746
    671  1746				   _ENDFOR_9
    672  1746
    673  1746
    674  1746
    675  1746				   _EL_8
    676  1746
    677  1746
    678  1746
    679  1746				   _EI_8
    680  1746				   FPULL      SET	0
      0  1746					      pfloatvar	V_src2.divert_chance
      1  1746		       ad 67 34 	      lda	V_src2.divert_chance + 3
      2  1749		       48		      pha
      3  174a					      IF	!FPUSH
      4  174a		       ad 66 34 	      lda	V_src2.divert_chance + 2
      5  174d		       48		      pha
      6  174e		       ad 65 34 	      lda	V_src2.divert_chance + 1
      7  1751		       48		      pha
      8  1752		       ad 64 34 	      lda	V_src2.divert_chance
      9  1755		       48		      pha
     10  1756				  -	      ELSE
     11  1756				  -	      lda	V_src2.divert_chance + 2
     12  1756				  -	      ldy	V_src2.divert_chance + 1
     13  1756				  -	      ldx	V_src2.divert_chance
     14  1756					      ENDIF
      0  1756					      pfloat	7c,4c,cc,cd
      1  1756		       a9 cd		      lda	#$cd
      2  1758		       48		      pha
      3  1759					      IF	!FPUSH
      4  1759		       a9 cc		      lda	#$cc
      5  175b		       48		      pha
      6  175c		       a9 4c		      lda	#$4c
      7  175e		       48		      pha
      8  175f		       a9 7c		      lda	#$7c
      9  1761		       48		      pha
     10  1762				  -	      ELSE
     11  1762				  -	      lda	#$cc
     12  1762				  -	      ldy	#$4c
     13  1762				  -	      ldx	#$7c
     14  1762					      ENDIF
    683  1762				   FPUSH      SET	1
      0  1762					      addfloat
      0  1762					      plfloattofac
      1  1762					      IF	!FPULL
      2  1762		       68		      pla
      3  1763		       85 28		      sta	FAC
      4  1765		       68		      pla
      5  1766		       85 2c		      sta	FACSIGN
      6  1768		       09 80		      ora	#%10000000
      7  176a		       85 29		      sta	FAC + 1
      8  176c		       68		      pla
      9  176d		       85 2a		      sta	FAC + 2
     10  176f				  -	      ELSE
     11  176f				  -	      sta	FAC + 2
     12  176f				  -	      tya
     13  176f				  -	      sta	FACSIGN
     14  176f				  -	      ora	#%10000000
     15  176f				  -	      sta	FAC + 1
     16  176f				  -	      stx	FAC
     17  176f					      ENDIF
     18  176f		       68		      pla
     19  1770		       85 2b		      sta	FAC + 3
     20  1772		       a9 00		      lda	#$00
     21  1774		       85 35		      sta	FACEXTENSION
      0  1776					      plfloattoarg
      1  1776					      IF	!FPULL
      2  1776		       68		      pla
      3  1777		       85 2f		      sta	ARG
      4  1779		       68		      pla
      5  177a		       85 33		      sta	ARGSIGN
      6  177c		       45 2c		      eor	FACSIGN
      7  177e		       85 34		      sta	SGNCPR
      8  1780		       a5 33		      lda	ARGSIGN
      9  1782		       09 80		      ora	#%10000000
     10  1784		       85 30		      sta	ARG + 1
     11  1786		       68		      pla
     12  1787		       85 31		      sta	ARG + 2
     13  1789				  -	      ELSE
     14  1789				  -	      sta	ARG
     15  1789				  -	      tya
     16  1789				  -	      sta	ARGSIGN
     17  1789				  -	      eor	FACSIGN
     18  1789				  -	      sta	SGNCPR
     19  1789				  -	      lda	ARGSIGN
     20  1789				  -	      ora	#%10000000
     21  1789				  -	      sta	ARG + 1
     22  1789				  -	      stx	ARG + 2
     23  1789					      ENDIF
     24  1789		       68		      pla
     25  178a		       85 32		      sta	ARG + 3
     26  178c		       a5 28		      lda	FAC
      0  178e					      import	I_FPLIB
      1  178e				   I_FPLIB_IMPORTED SET	1
      4  178e		       20 dc 2c 	      jsr	FADDT
      0  1791					      pfac
      0  1791					      import	I_FPLIB
      1  1791				   I_FPLIB_IMPORTED SET	1
      2  1791		       20 28 30 	      jsr	ROUND_FAC
      3  1794		       a9 00		      lda	#$00
      4  1796		       85 35		      sta	FACEXTENSION
      5  1798		       a5 2b		      lda	FAC + 3
      6  179a		       48		      pha
      7  179b				  -	      IF	!FPUSH
      8  179b				  -	      lda	FAC + 2
      9  179b				  -	      pha
     10  179b				  -	      lda	FACSIGN
     11  179b				  -	      ora	#$7F
     12  179b				  -	      and	FAC + 1
     13  179b				  -	      pha
     14  179b				  -	      lda	FAC
     15  179b				  -	      pha
     16  179b					      ELSE
     17  179b		       a5 2c		      lda	FACSIGN
     18  179d		       09 7f		      ora	#$7F
     19  179f		       25 29		      and	FAC + 1
     20  17a1		       a8		      tay
     21  17a2		       a6 28		      ldx	FAC
     22  17a4		       a5 2a		      lda	FAC + 2
     23  17a6					      ENDIF
    685  17a6				   FPULL      SET	1
    686  17a6				   FPUSH      SET	0
      0  17a6					      plfloatvar	V_src2.divert_chance
      1  17a6				  -	      IF	!FPULL
      2  17a6				  -	      pla
      3  17a6				  -	      sta	V_src2.divert_chance
      4  17a6				  -	      pla
      5  17a6				  -	      sta	V_src2.divert_chance + 1
      6  17a6				  -	      pla
      7  17a6				  -	      sta	V_src2.divert_chance + 2
      8  17a6					      ELSE
      9  17a6		       8e 64 34 	      stx	V_src2.divert_chance
     10  17a9		       8c 65 34 	      sty	V_src2.divert_chance + 1
     11  17ac		       8d 66 34 	      sta	V_src2.divert_chance + 2
     12  17af					      ENDIF
     13  17af		       68		      pla
     14  17b0		       8d 67 34 	      sta	V_src2.divert_chance + 3
    688  17b3
      0  17b3					      pbytevar_pbyte_addbyte_plbytevar	V_src2.level, 1, V_src2.level
      1  17b3					      IF	V_src2.level == V_src2.level && 1 == 1
      2  17b3		       ee 5c 34 	      inc	V_src2.level
      3  17b6				  -	      ELSE
      4  17b6				  -	      lda	V_src2.level
      5  17b6				  -	      clc
      6  17b6				  -	      adc	#1
      7  17b6				  -	      sta	V_src2.level
      8  17b6					      ENDIF
    690  17b6
      0  17b6					      pbytevar_pbyte_addbyte_plbytevar	V_src2.holes, 1, V_src2.holes
      1  17b6					      IF	V_src2.holes == V_src2.holes && 1 == 1
      2  17b6		       ee 61 34 	      inc	V_src2.holes
      3  17b9				  -	      ELSE
      4  17b9				  -	      lda	V_src2.holes
      5  17b9				  -	      clc
      6  17b9				  -	      adc	#1
      7  17b9				  -	      sta	V_src2.holes
      8  17b9					      ENDIF
    692  17b9
    693  17b9				   FPULL      SET	0
    694  17b9				   FPUSH      SET	1
      0  17b9					      pbytevar_pbyte_cmpbytegt	V_src2.holes, 8
      1  17b9		       a9 08		      lda	#8
      2  17bb		       cd 61 34 	      cmp	V_src2.holes
      3  17be		       90 04		      bcc	.true
      0  17c0					      pfalse
      1  17c0		       a9 00		      lda	#$00
      2  17c2				  -	      IF	!FPUSH
      3  17c2				  -	      pha
      4  17c2					      ENDIF
      5  17c2		       f0 02		      beq	.end
      6  17c4				   .true
      0  17c4					      ptrue
      1  17c4		       a9 ff		      lda	#$FF
      2  17c6				  -	      IF	!FPUSH
      3  17c6				  -	      pha
      4  17c6					      ENDIF
      8  17c6				   .end
    696  17c6				   FPULL      SET	1
    697  17c6				   FPUSH      SET	0
      0  17c6					      cond_stmt	_EI_65542, 0
      1  17c6				  -	      IF	!FPULL
      2  17c6				  -	      pla
      3  17c6					      ENDIF
      4  17c6		       d0 03		      bne	* + 5
      5  17c8				  -	      IF	0 > 0 && 0 < $10000
      6  17c8				  -	      jmp	0
      7  17c8					      ELSE
      8  17c8		       4c d0 17 	      jmp	_EI_65542
      9  17cb					      ENDIF
    699  17cb				   FPULL      SET	0
    700  17cb				   FPUSH      SET	1
      0  17cb					      pbyte	8
      1  17cb		       a9 08		      lda	#8
      2  17cd				  -	      IF	!FPUSH
      3  17cd				  -	      pha
      4  17cd					      ENDIF
    702  17cd				   FPULL      SET	1
    703  17cd				   FPUSH      SET	0
      0  17cd					      plbytevar	V_src2.holes
      1  17cd				  -	      IF	!FPULL
      2  17cd				  -	      pla
      3  17cd					      ENDIF
      4  17cd		       8d 61 34 	      sta	V_src2.holes
    705  17d0				   _EI_65542
    706  17d0		       4c c7 10 	      jmp	L_src2.15
      0  17d3					      xend
      1  17d3				  -	      IF	USEIRQ == 1
      2  17d3				  -	      jsr	IRQRESET
      3  17d3					      ENDIF
      4  17d3				  -	      IF	TARGET == c64
      5  17d3				  -
      6  17d3				  -	      lda	$01
      7  17d3				  -	      ora	#%00000001
      8  17d3				  -	      sta	$01
      9  17d3					      ENDIF
     10  17d3				  -	      IF	TARGET == c128
     11  17d3				  -
     12  17d3				  -	      lda	#%0
     13  17d3				  -	      sta	MMU
     14  17d3				  -
     15  17d3				  -	      lda	#$00
     16  17d3				  -	      sta	$D8
     17  17d3				  -
     18  17d3				  -	      lda	INIT_STATUS
     19  17d3				  -	      ora	#1
     20  17d3				  -	      sta	INIT_STATUS
     21  17d3					      ENDIF
     22  17d3
     23  17d3					      IF	TARGET & vic20
     24  17d3		       6c 02 c0 	      jmp	($C002)
     25  17d6					      ENDIF
     26  17d6				  -	      IF	TARGET & c264
     27  17d6				  -	      jmp	$8003
     28  17d6					      ENDIF
     29  17d6				  -	      IF	TARGET == c64
     30  17d6				  -	      jmp	($A002)
     31  17d6					      ENDIF
     32  17d6				  -	      IF	TARGET == c128
     33  17d6				  -	      jmp	($0A00)
     34  17d6					      ENDIF
     35  17d6				  -	      IF	TARGET & pet && TARGET < pet4
     36  17d6				  -	      jmp	$C389
     37  17d6					      ENDIF
     38  17d6				  -	      IF	TARGET & pet && TARGET >= pet4
     39  17d6				  -	      jmp	$B3FF
     40  17d6					      ENDIF
    708  17d6
    709  17d6
    710  17d6
    711  17d6
    712  17d6
    713  17d6
    714  17d6
    715  17d6
    716  17d6
    717  17d6
    718  17d6
    719  17d6				   routines_start
    720  17d6					      IFCONST	I_F_src2.playermove_IMPORTED
    721  17d6				   F_src2.playermove SUBROUTINE
      0  17d6					      sys_constaddr	$33C, 1
      1  17d6				  -	      IF	1 == 0
      2  17d6				  -	      lda	SPREG
      3  17d6				  -	      pha
      4  17d6				  -	      lda	SAREG
      5  17d6				  -	      ldx	SXREG
      6  17d6				  -	      ldy	SYREG
      7  17d6				  -	      plp
      8  17d6					      ENDIF
      9  17d6				   .jsr
     10  17d6		       20 3c 03 	      jsr	$33C
     11  17d9				  -	      IF	1 == 0
     12  17d9				  -	      php
     13  17d9				  -	      sta	SAREG
     14  17d9				  -	      stx	SXREG
     15  17d9				  -	      sty	SYREG
     16  17d9				  -	      pla
     17  17d9				  -	      sta	SPREG
     18  17d9					      ENDIF
    723  17d9				   FPULL      SET	0
      0  17d9					      pbyte	1
      1  17d9		       a9 01		      lda	#1
      2  17db					      IF	!FPUSH
      3  17db		       48		      pha
      4  17dc					      ENDIF
      0  17dc					      F_cword_byte
      1  17dc		       a9 00		      lda	#$00
      2  17de		       48		      pha
    726  17de				   FPUSH      SET	1
      0  17df					      F_peek_word
      1  17df					      IF	!FPULL
      2  17df		       68		      pla
      3  17e0		       8d e9 17 	      sta	.l + 2
      4  17e3		       68		      pla
      5  17e4		       8d e8 17 	      sta	.l + 1
      6  17e7				  -	      ELSE
      7  17e7				  -	      sta	.l + 1
      8  17e7				  -	      sty	.l + 2
      9  17e7					      ENDIF
     10  17e7		       ad ff ff    .l	      lda	$FFFF
     11  17ea				  -	      IF	!FPUSH
     12  17ea				  -	      pha
     13  17ea					      ENDIF
    728  17ea				   FPULL      SET	1
    729  17ea				   FPUSH      SET	0
      0  17ea					      ongoto	_ON_LB1, _ON_HB1
      1  17ea				  -	      IF	!FPULL
      2  17ea				  -	      pla
      3  17ea					      ENDIF
      4  17ea		       aa		      tax
      5  17eb		       bd fa 17 	      lda.wx	_ON_LB1
      6  17ee		       8d f8 17 	      sta	.jump + 1
      7  17f1		       bd 00 18 	      lda.wx	_ON_HB1
      8  17f4		       8d f9 17 	      sta	.jump + 2
      9  17f7				   .jump
     10  17f7		       4c ff ff 	      jmp	$ffff
    731  17fa		       06 58 33 cb*_ON_LB1    DC.B	<L_src2.playermove_.nomove,<L_src2.playermove_.fire,<L_src2.playermove_.down,<L_src2.playermove_.left,<L_src2.playermove_.up,<L_src2.playermove_.right
    732  1800		       18 1b 18 18*_ON_HB1    DC.B	>L_src2.playermove_.nomove,>L_src2.playermove_.fire,>L_src2.playermove_.down,>L_src2.playermove_.left,>L_src2.playermove_.up,>L_src2.playermove_.right
    733  1806				   _ON_END1
    734  1806
    735  1806
    736  1806
    737  1806				   L_src2.playermove_.nomove
    738  1806				   FPULL      SET	0
      0  1806					      pbyte	1
      1  1806		       a9 01		      lda	#1
      2  1808					      IF	!FPUSH
      3  1808		       48		      pha
      4  1809					      ENDIF
      0  1809					      F_cword_byte
      1  1809		       a9 00		      lda	#$00
      2  180b		       48		      pha
      0  180c					      plwordvar	V_src2.n
      1  180c					      IF	!FPULL
      2  180c		       68		      pla
      3  180d		       8d 6e 34 	      sta	V_src2.n+1
      4  1810		       68		      pla
      5  1811		       8d 6d 34 	      sta	V_src2.n
      6  1814				  -	      ELSE
      7  1814				  -	      sta	V_src2.n
      8  1814				  -	      sty	V_src2.n+1
      9  1814					      ENDIF
    742  1814				   _FOR_11
      0  1814					      forword	11, V_src2.n, 23, "_void_", 1
      1  1814
      2  1814					      IF	1 == 1
      3  1814		       a9 17		      lda	#<23
      4  1816		       cd 6d 34 	      cmp	V_src2.n
      5  1819		       a9 00		      lda	#>23
      6  181b		       ed 6e 34 	      sbc	V_src2.n + 1
      7  181e				  -	      ELSE
      8  181e				  -	      lda	23
      9  181e				  -	      cmp	V_src2.n
     10  181e				  -	      lda	23 + 1
     11  181e				  -	      sbc	V_src2.n + 1
     12  181e					      ENDIF
     13  181e		       b0 03		      bcs	.enter
     14  1820		       4c 30 18 	      jmp	_ENDFOR_11
     15  1823				   .enter
    744  1823
    745  1823
    746  1823
    747  1823				   _CO_11
      0  1823					      nextword	11, V_src2.n, "_void_"
      1  1823
      2  1823				  -	      IFCONST	"_void_"
      3  1823				  -
      4  1823				  -	      clc
      5  1823				  -	      lda	"_void_"
      6  1823				  -	      adc	V_src2.n
      7  1823				  -	      sta	V_src2.n
      8  1823				  -	      lda	"_void_" + 1
      9  1823				  -	      adc	V_src2.n + 1
     10  1823				  -	      sta	V_src2.n + 1
     11  1823				  -
     12  1823				  -	      bcs	_ENDFOR_11
     13  1823					      ELSE
     14  1823
     15  1823		       ee 6d 34 	      inc	V_src2.n
     16  1826		       d0 05		      bne	.skip
     17  1828		       ee 6e 34 	      inc	V_src2.n + 1
     18  182b
     19  182b		       f0 03		      beq	_ENDFOR_11
     20  182d				   .skip
     21  182d					      ENDIF
     22  182d		       4c 14 18 	      jmp	_FOR_11
    749  1830
    750  1830
    751  1830
    752  1830				   _ENDFOR_11
    753  1830		       4c 20 1e 	      jmp	L_src2.playermove_.41
    754  1833
    755  1833
    756  1833
    757  1833				   L_src2.playermove_.down
    758  1833
    759  1833				   FPUSH      SET	1
      0  1833					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 22
      0  1833					      pintvar_pint_addint	V_src2.pos_man, 22
      1  1833		       ad 50 34 	      lda	V_src2.pos_man
      2  1836		       18		      clc
      3  1837		       69 16		      adc	#<22
      4  1839				  -	      IF	!FPUSH
      5  1839				  -	      pha
      6  1839					      ELSE
      7  1839		       aa		      tax
      8  183a					      ENDIF
      9  183a		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  183d		       69 00		      adc	#>22
     11  183f				  -	      IF	!FPUSH
     12  183f				  -	      pha
     13  183f					      ELSE
     14  183f		       a8		      tay
     15  1840		       8a		      txa
     16  1841					      ENDIF
    761  1841				   FPULL      SET	1
    762  1841				   FPUSH      SET	0
      0  1841					      F_peek_word
      1  1841				  -	      IF	!FPULL
      2  1841				  -	      pla
      3  1841				  -	      sta	.l + 2
      4  1841				  -	      pla
      5  1841				  -	      sta	.l + 1
      6  1841					      ELSE
      7  1841		       8d 48 18 	      sta	.l + 1
      8  1844		       8c 49 18 	      sty	.l + 2
      9  1847					      ENDIF
     10  1847		       ad ff ff    .l	      lda	$FFFF
     11  184a					      IF	!FPUSH
     12  184a		       48		      pha
     13  184b					      ENDIF
    764  184b				   FPULL      SET	0
    765  184b				   FPUSH      SET	1
      0  184b					      pbyte	57
      1  184b		       a9 39		      lda	#57
      2  184d				  -	      IF	!FPUSH
      3  184d				  -	      pha
      4  184d					      ENDIF
    767  184d				   FPULL      SET	1
      0  184d					      cmpbyteeq
      1  184d				  -	      IF	!FPULL
      2  184d				  -	      pla
      3  184d					      ENDIF
      4  184d		       85 02		      sta	R0
      5  184f		       68		      pla
      6  1850		       c5 02		      cmp	R0
      7  1852		       f0 04		      beq	.pht
      0  1854					      pfalse
      1  1854		       a9 00		      lda	#$00
      2  1856				  -	      IF	!FPUSH
      3  1856				  -	      pha
      4  1856					      ENDIF
      9  1856		       f0 02		      beq	.q
      0  1858				   .pht       ptrue
      1  1858		       a9 ff		      lda	#$FF
      2  185a				  -	      IF	!FPUSH
      3  185a				  -	      pha
      4  185a					      ENDIF
     11  185a				   .q
    769  185a				   FPUSH      SET	0
      0  185a					      cond_stmt	_EI_12, _EL_12
      1  185a				  -	      IF	!FPULL
      2  185a				  -	      pla
      3  185a					      ENDIF
      4  185a		       d0 03		      bne	* + 5
      5  185c					      IF	_EL_12 > 0 && _EL_12 < $10000
      6  185c		       4c c8 18 	      jmp	_EL_12
      7  185f				  -	      ELSE
      8  185f				  -	      jmp	_EI_12
      9  185f					      ENDIF
    771  185f				   FPULL      SET	0
      0  185f					      pbytevar	V_src2.t
      1  185f		       ad 72 34 	      lda	V_src2.t
      2  1862					      IF	!FPUSH
      3  1862		       48		      pha
      4  1863					      ENDIF
    773  1863				   FPUSH      SET	1
      0  1863					      pwordvar	V_src2.pos_man
      1  1863				  -	      IF	!FPUSH
      2  1863				  -	      lda	V_src2.pos_man
      3  1863				  -	      pha
      4  1863				  -	      lda	V_src2.pos_man+1
      5  1863				  -	      pha
      6  1863					      ELSE
      7  1863		       ad 50 34 	      lda	V_src2.pos_man
      8  1866		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1869					      ENDIF
    775  1869				   FPULL      SET	1
    776  1869				   FPUSH      SET	0
      0  1869					      poke
      1  1869				  -	      IF	!FPULL
      2  1869				  -	      pla
      3  1869				  -	      sta	.l + 2
      4  1869				  -	      pla
      5  1869				  -	      sta	.l + 1
      6  1869					      ELSE
      7  1869		       8d 71 18 	      sta	.l + 1
      8  186c		       8c 72 18 	      sty	.l + 2
      9  186f					      ENDIF
     10  186f		       68		      pla
     11  1870		       8d ff ff    .l	      sta	$ffff
    778  1870				   FPULL      SET	0
      0  1873					      pbytevar	V_src2.t
      1  1873		       ad 72 34 	      lda	V_src2.t
      2  1876					      IF	!FPUSH
      3  1876		       48		      pha
      4  1877					      ENDIF
    780  1877				   FPUSH      SET	1
      0  1877					      pbyte	56
      1  1877		       a9 38		      lda	#56
      2  1879				  -	      IF	!FPUSH
      3  1879				  -	      pha
      4  1879					      ENDIF
    782  1879				   FPULL      SET	1
      0  1879					      subbyte
      1  1879				  -	      IF	!FPULL
      2  1879				  -	      pla
      3  1879					      ENDIF
      4  1879		       85 02		      sta	R0
      5  187b		       68		      pla
      6  187c		       38		      sec
      7  187d		       e5 02		      sbc	R0
      8  187f				  -	      IF	!FPUSH
      9  187f				  -	      pha
     10  187f					      ENDIF
    784  187f				   FPUSH      SET	0
      0  187f					      pbytearrayfast	V_src2.d
      1  187f				  -	      IF	!FPULL
      2  187f				  -	      pla
      3  187f					      ENDIF
      4  187f		       aa		      tax
      5  1880		       bd 68 34 	      lda	V_src2.d,x
      6  1883					      IF	!FPUSH
      7  1883		       48		      pha
      8  1884					      ENDIF
    786  1884				   FPULL      SET	0
      0  1884					      pwordvar	V_src2.pos_man
      1  1884					      IF	!FPUSH
      2  1884		       ad 50 34 	      lda	V_src2.pos_man
      3  1887		       48		      pha
      4  1888		       ad 51 34 	      lda	V_src2.pos_man+1
      5  188b		       48		      pha
      6  188c				  -	      ELSE
      7  188c				  -	      lda	V_src2.pos_man
      8  188c				  -	      ldy	V_src2.pos_man+1
      9  188c					      ENDIF
      0  188c					      F_cint_word
      0  188c					      pint	30720
      0  188c					      pword	30720
      1  188c					      IF	!FPUSH
      2  188c		       a9 00		      lda	#<30720
      3  188e		       48		      pha
      4  188f		       a9 78		      lda	#>30720
      5  1891		       48		      pha
      6  1892				  -	      ELSE
      7  1892				  -	      lda	#<30720
      8  1892				  -	      ldy	#>30720
      9  1892					      ENDIF
      0  1892					      addint
      0  1892					      addword
      1  1892		       ba		      tsx
      2  1893		       bd 02 01 	      lda.wx	stack + 2
      3  1896		       18		      clc
      4  1897		       7d 04 01 	      adc.wx	stack + 4
      5  189a		       9d 04 01 	      sta.wx	stack + 4
      6  189d		       68		      pla
      7  189e		       7d 03 01 	      adc.wx	stack + 3
      8  18a1		       9d 03 01 	      sta.wx	stack + 3
      9  18a4		       68		      pla
      0  18a5					      F_cword_int
      0  18a5					      poke
      1  18a5					      IF	!FPULL
      2  18a5		       68		      pla
      3  18a6		       8d b0 18 	      sta	.l + 2
      4  18a9		       68		      pla
      5  18aa		       8d af 18 	      sta	.l + 1
      6  18ad				  -	      ELSE
      7  18ad				  -	      sta	.l + 1
      8  18ad				  -	      sty	.l + 2
      9  18ad					      ENDIF
     10  18ad		       68		      pla
     11  18ae		       8d ff ff    .l	      sta	$ffff
    793  18ae				   FPUSH      SET	1
      0  18b1					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 22
      0  18b1					      pintvar_pint_addint	V_src2.pos_man, 22
      1  18b1		       ad 50 34 	      lda	V_src2.pos_man
      2  18b4		       18		      clc
      3  18b5		       69 16		      adc	#<22
      4  18b7				  -	      IF	!FPUSH
      5  18b7				  -	      pha
      6  18b7					      ELSE
      7  18b7		       aa		      tax
      8  18b8					      ENDIF
      9  18b8		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  18bb		       69 00		      adc	#>22
     11  18bd				  -	      IF	!FPUSH
     12  18bd				  -	      pha
     13  18bd					      ELSE
     14  18bd		       a8		      tay
     15  18be		       8a		      txa
     16  18bf					      ENDIF
    795  18bf				   FPULL      SET	1
    796  18bf				   FPUSH      SET	0
      0  18bf					      plwordvar	V_src2.pos_man
      1  18bf				  -	      IF	!FPULL
      2  18bf				  -	      pla
      3  18bf				  -	      sta	V_src2.pos_man+1
      4  18bf				  -	      pla
      5  18bf				  -	      sta	V_src2.pos_man
      6  18bf					      ELSE
      7  18bf		       8d 50 34 	      sta	V_src2.pos_man
      8  18c2		       8c 51 34 	      sty	V_src2.pos_man+1
      9  18c5					      ENDIF
    798  18c5		       4c c1 1d 	      jmp	L_src2.playermove_.40
    799  18c8
    800  18c8
    801  18c8
    802  18c8				   _EL_12
    803  18c8
    804  18c8
    805  18c8
    806  18c8				   _EI_12
    807  18c8		       4c 20 1e 	      jmp	L_src2.playermove_.41
    808  18cb
    809  18cb
    810  18cb
    811  18cb				   L_src2.playermove_.left
    812  18cb				   FPULL      SET	0
      0  18cb					      pint	-1
      0  18cb					      pword	-1
      1  18cb					      IF	!FPUSH
      2  18cb		       a9 ff		      lda	#<-1
      3  18cd		       48		      pha
      4  18ce		       a9 ff		      lda	#>-1
      5  18d0		       48		      pha
      6  18d1				  -	      ELSE
      7  18d1				  -	      lda	#<-1
      8  18d1				  -	      ldy	#>-1
      9  18d1					      ENDIF
      0  18d1					      F_cword_int
      0  18d1					      plwordvar	V_src2.dir_man
      1  18d1					      IF	!FPULL
      2  18d1		       68		      pla
      3  18d2		       8d 53 34 	      sta	V_src2.dir_man+1
      4  18d5		       68		      pla
      5  18d6		       8d 52 34 	      sta	V_src2.dir_man
      6  18d9				  -	      ELSE
      7  18d9				  -	      sta	V_src2.dir_man
      8  18d9				  -	      sty	V_src2.dir_man+1
      9  18d9					      ENDIF
    816  18d9				   FPUSH      SET	1
      0  18d9					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 21
      0  18d9					      pintvar_pint_addint	V_src2.pos_man, 21
      1  18d9		       ad 50 34 	      lda	V_src2.pos_man
      2  18dc		       18		      clc
      3  18dd		       69 15		      adc	#<21
      4  18df				  -	      IF	!FPUSH
      5  18df				  -	      pha
      6  18df					      ELSE
      7  18df		       aa		      tax
      8  18e0					      ENDIF
      9  18e0		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  18e3		       69 00		      adc	#>21
     11  18e5				  -	      IF	!FPUSH
     12  18e5				  -	      pha
     13  18e5					      ELSE
     14  18e5		       a8		      tay
     15  18e6		       8a		      txa
     16  18e7					      ENDIF
    818  18e7				   FPULL      SET	1
    819  18e7				   FPUSH      SET	0
      0  18e7					      F_peek_word
      1  18e7				  -	      IF	!FPULL
      2  18e7				  -	      pla
      3  18e7				  -	      sta	.l + 2
      4  18e7				  -	      pla
      5  18e7				  -	      sta	.l + 1
      6  18e7					      ELSE
      7  18e7		       8d ee 18 	      sta	.l + 1
      8  18ea		       8c ef 18 	      sty	.l + 2
      9  18ed					      ENDIF
     10  18ed		       ad ff ff    .l	      lda	$FFFF
     11  18f0					      IF	!FPUSH
     12  18f0		       48		      pha
     13  18f1					      ENDIF
    821  18f1				   FPULL      SET	0
    822  18f1				   FPUSH      SET	1
      0  18f1					      pbyte	62
      1  18f1		       a9 3e		      lda	#62
      2  18f3				  -	      IF	!FPUSH
      3  18f3				  -	      pha
      4  18f3					      ENDIF
    824  18f3				   FPULL      SET	1
      0  18f3					      cmpbytelt
      1  18f3				  -	      IF	!FPULL
      2  18f3				  -	      pla
      3  18f3					      ENDIF
      4  18f3		       85 02		      sta	R0
      5  18f5		       68		      pla
      6  18f6		       c5 02		      cmp	R0
      7  18f8		       b0 04		      bcs	.phf
      0  18fa					      ptrue
      1  18fa		       a9 ff		      lda	#$FF
      2  18fc				  -	      IF	!FPUSH
      3  18fc				  -	      pha
      4  18fc					      ENDIF
      9  18fc		       d0 02		      bne	.q
      0  18fe				   .phf       pfalse
      1  18fe		       a9 00		      lda	#$00
      2  1900				  -	      IF	!FPUSH
      3  1900				  -	      pha
      4  1900					      ENDIF
     11  1900				   .q
    826  1900				   FPUSH      SET	0
      0  1900					      cond_stmt	_EI_13, _EL_13
      1  1900				  -	      IF	!FPULL
      2  1900				  -	      pla
      3  1900					      ENDIF
      4  1900		       d0 03		      bne	* + 5
      5  1902					      IF	_EL_13 > 0 && _EL_13 < $10000
      6  1902		       4c 87 19 	      jmp	_EL_13
      7  1905				  -	      ELSE
      8  1905				  -	      jmp	_EI_13
      9  1905					      ENDIF
    828  1905				   FPULL      SET	0
      0  1905					      pbytevar	V_src2.t
      1  1905		       ad 72 34 	      lda	V_src2.t
      2  1908					      IF	!FPUSH
      3  1908		       48		      pha
      4  1909					      ENDIF
    830  1909				   FPUSH      SET	1
      0  1909					      pwordvar	V_src2.pos_man
      1  1909				  -	      IF	!FPUSH
      2  1909				  -	      lda	V_src2.pos_man
      3  1909				  -	      pha
      4  1909				  -	      lda	V_src2.pos_man+1
      5  1909				  -	      pha
      6  1909					      ELSE
      7  1909		       ad 50 34 	      lda	V_src2.pos_man
      8  190c		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  190f					      ENDIF
    832  190f				   FPULL      SET	1
    833  190f				   FPUSH      SET	0
      0  190f					      poke
      1  190f				  -	      IF	!FPULL
      2  190f				  -	      pla
      3  190f				  -	      sta	.l + 2
      4  190f				  -	      pla
      5  190f				  -	      sta	.l + 1
      6  190f					      ELSE
      7  190f		       8d 17 19 	      sta	.l + 1
      8  1912		       8c 18 19 	      sty	.l + 2
      9  1915					      ENDIF
     10  1915		       68		      pla
     11  1916		       8d ff ff    .l	      sta	$ffff
    835  1916				   FPULL      SET	0
      0  1919					      pbytevar	V_src2.t
      1  1919		       ad 72 34 	      lda	V_src2.t
      2  191c					      IF	!FPUSH
      3  191c		       48		      pha
      4  191d					      ENDIF
    837  191d				   FPUSH      SET	1
      0  191d					      pbyte	56
      1  191d		       a9 38		      lda	#56
      2  191f				  -	      IF	!FPUSH
      3  191f				  -	      pha
      4  191f					      ENDIF
    839  191f				   FPULL      SET	1
      0  191f					      subbyte
      1  191f				  -	      IF	!FPULL
      2  191f				  -	      pla
      3  191f					      ENDIF
      4  191f		       85 02		      sta	R0
      5  1921		       68		      pla
      6  1922		       38		      sec
      7  1923		       e5 02		      sbc	R0
      8  1925				  -	      IF	!FPUSH
      9  1925				  -	      pha
     10  1925					      ENDIF
    841  1925				   FPUSH      SET	0
      0  1925					      pbytearrayfast	V_src2.d
      1  1925				  -	      IF	!FPULL
      2  1925				  -	      pla
      3  1925					      ENDIF
      4  1925		       aa		      tax
      5  1926		       bd 68 34 	      lda	V_src2.d,x
      6  1929					      IF	!FPUSH
      7  1929		       48		      pha
      8  192a					      ENDIF
    843  192a				   FPULL      SET	0
      0  192a					      pwordvar	V_src2.pos_man
      1  192a					      IF	!FPUSH
      2  192a		       ad 50 34 	      lda	V_src2.pos_man
      3  192d		       48		      pha
      4  192e		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1931		       48		      pha
      6  1932				  -	      ELSE
      7  1932				  -	      lda	V_src2.pos_man
      8  1932				  -	      ldy	V_src2.pos_man+1
      9  1932					      ENDIF
      0  1932					      F_cint_word
      0  1932					      pint	30720
      0  1932					      pword	30720
      1  1932					      IF	!FPUSH
      2  1932		       a9 00		      lda	#<30720
      3  1934		       48		      pha
      4  1935		       a9 78		      lda	#>30720
      5  1937		       48		      pha
      6  1938				  -	      ELSE
      7  1938				  -	      lda	#<30720
      8  1938				  -	      ldy	#>30720
      9  1938					      ENDIF
      0  1938					      addint
      0  1938					      addword
      1  1938		       ba		      tsx
      2  1939		       bd 02 01 	      lda.wx	stack + 2
      3  193c		       18		      clc
      4  193d		       7d 04 01 	      adc.wx	stack + 4
      5  1940		       9d 04 01 	      sta.wx	stack + 4
      6  1943		       68		      pla
      7  1944		       7d 03 01 	      adc.wx	stack + 3
      8  1947		       9d 03 01 	      sta.wx	stack + 3
      9  194a		       68		      pla
      0  194b					      F_cword_int
      0  194b					      poke
      1  194b					      IF	!FPULL
      2  194b		       68		      pla
      3  194c		       8d 56 19 	      sta	.l + 2
      4  194f		       68		      pla
      5  1950		       8d 55 19 	      sta	.l + 1
      6  1953				  -	      ELSE
      7  1953				  -	      sta	.l + 1
      8  1953				  -	      sty	.l + 2
      9  1953					      ENDIF
     10  1953		       68		      pla
     11  1954		       8d ff ff    .l	      sta	$ffff
      0  1957					      pwordvar	V_src2.pos_man
      1  1957					      IF	!FPUSH
      2  1957		       ad 50 34 	      lda	V_src2.pos_man
      3  195a		       48		      pha
      4  195b		       ad 51 34 	      lda	V_src2.pos_man+1
      5  195e		       48		      pha
      6  195f				  -	      ELSE
      7  195f				  -	      lda	V_src2.pos_man
      8  195f				  -	      ldy	V_src2.pos_man+1
      9  195f					      ENDIF
      0  195f					      pbyte	1
      1  195f		       a9 01		      lda	#1
      2  1961					      IF	!FPUSH
      3  1961		       48		      pha
      4  1962					      ENDIF
      0  1962					      F_cword_byte
      1  1962		       a9 00		      lda	#$00
      2  1964		       48		      pha
      0  1965					      subword
      1  1965		       ba		      tsx
      2  1966		       bd 04 01 	      lda.wx	stack + 4
      3  1969		       38		      sec
      4  196a		       fd 02 01 	      sbc.wx	stack + 2
      5  196d		       9d 04 01 	      sta.wx	stack + 4
      6  1970		       bd 03 01 	      lda.wx	stack + 3
      7  1973		       fd 01 01 	      sbc.wx	stack + 1
      8  1976		       9d 03 01 	      sta.wx	stack + 3
      9  1979		       e8		      inx
     10  197a		       e8		      inx
     11  197b		       9a		      txs
      0  197c					      plwordvar	V_src2.pos_man
      1  197c					      IF	!FPULL
      2  197c		       68		      pla
      3  197d		       8d 51 34 	      sta	V_src2.pos_man+1
      4  1980		       68		      pla
      5  1981		       8d 50 34 	      sta	V_src2.pos_man
      6  1984				  -	      ELSE
      7  1984				  -	      sta	V_src2.pos_man
      8  1984				  -	      sty	V_src2.pos_man+1
      9  1984					      ENDIF
    855  1984		       4c c1 1d 	      jmp	L_src2.playermove_.40
    856  1987				   _EL_13
    857  1987
    858  1987
    859  1987
    860  1987				   _EI_13
    861  1987
    862  1987
    863  1987
    864  1987				   L_src2.playermove_.29
      0  1987					      pbytevar	V_src2.t
      1  1987		       ad 72 34 	      lda	V_src2.t
      2  198a					      IF	!FPUSH
      3  198a		       48		      pha
      4  198b					      ENDIF
    866  198b				   FPUSH      SET	1
      0  198b					      pbyte	57
      1  198b		       a9 39		      lda	#57
      2  198d				  -	      IF	!FPUSH
      3  198d				  -	      pha
      4  198d					      ENDIF
    868  198d				   FPULL      SET	1
      0  198d					      cmpbyteneq
      1  198d				  -	      IF	!FPULL
      2  198d				  -	      pla
      3  198d					      ENDIF
      4  198d		       85 02		      sta	R0
      5  198f		       68		      pla
      6  1990		       c5 02		      cmp	R0
      7  1992		       d0 04		      bne	.pht
      0  1994					      pfalse
      1  1994		       a9 00		      lda	#$00
      2  1996				  -	      IF	!FPUSH
      3  1996				  -	      pha
      4  1996					      ENDIF
      9  1996		       f0 02		      beq	.q
      0  1998				   .pht       ptrue
      1  1998		       a9 ff		      lda	#$FF
      2  199a				  -	      IF	!FPUSH
      3  199a				  -	      pha
      4  199a					      ENDIF
     11  199a				   .q
    870  199a				   FPUSH      SET	0
      0  199a					      cond_stmt	_EI_14, _EL_14
      1  199a				  -	      IF	!FPULL
      2  199a				  -	      pla
      3  199a					      ENDIF
      4  199a		       d0 03		      bne	* + 5
      5  199c					      IF	_EL_14 > 0 && _EL_14 < $10000
      6  199c		       4c 18 1a 	      jmp	_EL_14
      7  199f				  -	      ELSE
      8  199f				  -	      jmp	_EI_14
      9  199f					      ENDIF
    872  199f				   FPULL      SET	0
      0  199f					      pbytevar	V_src2.t
      1  199f		       ad 72 34 	      lda	V_src2.t
      2  19a2					      IF	!FPUSH
      3  19a2		       48		      pha
      4  19a3					      ENDIF
    874  19a3				   FPUSH      SET	1
      0  19a3					      pwordvar	V_src2.pos_man
      1  19a3				  -	      IF	!FPUSH
      2  19a3				  -	      lda	V_src2.pos_man
      3  19a3				  -	      pha
      4  19a3				  -	      lda	V_src2.pos_man+1
      5  19a3				  -	      pha
      6  19a3					      ELSE
      7  19a3		       ad 50 34 	      lda	V_src2.pos_man
      8  19a6		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  19a9					      ENDIF
    876  19a9				   FPULL      SET	1
    877  19a9				   FPUSH      SET	0
      0  19a9					      poke
      1  19a9				  -	      IF	!FPULL
      2  19a9				  -	      pla
      3  19a9				  -	      sta	.l + 2
      4  19a9				  -	      pla
      5  19a9				  -	      sta	.l + 1
      6  19a9					      ELSE
      7  19a9		       8d b1 19 	      sta	.l + 1
      8  19ac		       8c b2 19 	      sty	.l + 2
      9  19af					      ENDIF
     10  19af		       68		      pla
     11  19b0		       8d ff ff    .l	      sta	$ffff
    879  19b0				   FPULL      SET	0
      0  19b3					      pbytevar	V_src2.t
      1  19b3		       ad 72 34 	      lda	V_src2.t
      2  19b6					      IF	!FPUSH
      3  19b6		       48		      pha
      4  19b7					      ENDIF
    881  19b7				   FPUSH      SET	1
      0  19b7					      pbyte	56
      1  19b7		       a9 38		      lda	#56
      2  19b9				  -	      IF	!FPUSH
      3  19b9				  -	      pha
      4  19b9					      ENDIF
    883  19b9				   FPULL      SET	1
      0  19b9					      subbyte
      1  19b9				  -	      IF	!FPULL
      2  19b9				  -	      pla
      3  19b9					      ENDIF
      4  19b9		       85 02		      sta	R0
      5  19bb		       68		      pla
      6  19bc		       38		      sec
      7  19bd		       e5 02		      sbc	R0
      8  19bf				  -	      IF	!FPUSH
      9  19bf				  -	      pha
     10  19bf					      ENDIF
    885  19bf				   FPUSH      SET	0
      0  19bf					      pbytearrayfast	V_src2.d
      1  19bf				  -	      IF	!FPULL
      2  19bf				  -	      pla
      3  19bf					      ENDIF
      4  19bf		       aa		      tax
      5  19c0		       bd 68 34 	      lda	V_src2.d,x
      6  19c3					      IF	!FPUSH
      7  19c3		       48		      pha
      8  19c4					      ENDIF
    887  19c4				   FPULL      SET	0
      0  19c4					      pwordvar	V_src2.pos_man
      1  19c4					      IF	!FPUSH
      2  19c4		       ad 50 34 	      lda	V_src2.pos_man
      3  19c7		       48		      pha
      4  19c8		       ad 51 34 	      lda	V_src2.pos_man+1
      5  19cb		       48		      pha
      6  19cc				  -	      ELSE
      7  19cc				  -	      lda	V_src2.pos_man
      8  19cc				  -	      ldy	V_src2.pos_man+1
      9  19cc					      ENDIF
      0  19cc					      F_cint_word
      0  19cc					      pint	30720
      0  19cc					      pword	30720
      1  19cc					      IF	!FPUSH
      2  19cc		       a9 00		      lda	#<30720
      3  19ce		       48		      pha
      4  19cf		       a9 78		      lda	#>30720
      5  19d1		       48		      pha
      6  19d2				  -	      ELSE
      7  19d2				  -	      lda	#<30720
      8  19d2				  -	      ldy	#>30720
      9  19d2					      ENDIF
      0  19d2					      addint
      0  19d2					      addword
      1  19d2		       ba		      tsx
      2  19d3		       bd 02 01 	      lda.wx	stack + 2
      3  19d6		       18		      clc
      4  19d7		       7d 04 01 	      adc.wx	stack + 4
      5  19da		       9d 04 01 	      sta.wx	stack + 4
      6  19dd		       68		      pla
      7  19de		       7d 03 01 	      adc.wx	stack + 3
      8  19e1		       9d 03 01 	      sta.wx	stack + 3
      9  19e4		       68		      pla
      0  19e5					      F_cword_int
      0  19e5					      poke
      1  19e5					      IF	!FPULL
      2  19e5		       68		      pla
      3  19e6		       8d f0 19 	      sta	.l + 2
      4  19e9		       68		      pla
      5  19ea		       8d ef 19 	      sta	.l + 1
      6  19ed				  -	      ELSE
      7  19ed				  -	      sta	.l + 1
      8  19ed				  -	      sty	.l + 2
      9  19ed					      ENDIF
     10  19ed		       68		      pla
     11  19ee		       8d ff ff    .l	      sta	$ffff
      0  19f1					      pwordvar_pwordvar_addword_plwordvar	V_src2.pos_man, V_src2.dir_man, V_src2.pos_man
      0  19f1					      pintvar_pintvar_addint	V_src2.pos_man, V_src2.dir_man, V_src2.pos_man
      1  19f1		       ad 50 34 	      lda	V_src2.pos_man
      2  19f4		       18		      clc
      3  19f5		       6d 52 34 	      adc	V_src2.dir_man
      4  19f8					      IF	!FPUSH
      5  19f8		       48		      pha
      6  19f9				  -	      ELSE
      7  19f9				  -	      tax
      8  19f9					      ENDIF
      9  19f9		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  19fc		       6d 53 34 	      adc	V_src2.dir_man + 1
     11  19ff					      IF	!FPUSH
     12  19ff		       48		      pha
     13  1a00				  -	      ELSE
     14  1a00				  -	      tay
     15  1a00				  -	      txa
     16  1a00					      ENDIF
    895  1a00				   FPUSH      SET	1
      0  1a00					      pwordvar	V_src2.pos_man
      1  1a00				  -	      IF	!FPUSH
      2  1a00				  -	      lda	V_src2.pos_man
      3  1a00				  -	      pha
      4  1a00				  -	      lda	V_src2.pos_man+1
      5  1a00				  -	      pha
      6  1a00					      ELSE
      7  1a00		       ad 50 34 	      lda	V_src2.pos_man
      8  1a03		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1a06					      ENDIF
    897  1a06				   FPULL      SET	1
      0  1a06					      F_peek_word
      1  1a06				  -	      IF	!FPULL
      2  1a06				  -	      pla
      3  1a06				  -	      sta	.l + 2
      4  1a06				  -	      pla
      5  1a06				  -	      sta	.l + 1
      6  1a06					      ELSE
      7  1a06		       8d 0d 1a 	      sta	.l + 1
      8  1a09		       8c 0e 1a 	      sty	.l + 2
      9  1a0c					      ENDIF
     10  1a0c		       ad ff ff    .l	      lda	$FFFF
     11  1a0f				  -	      IF	!FPUSH
     12  1a0f				  -	      pha
     13  1a0f					      ENDIF
    899  1a0f				   FPUSH      SET	0
      0  1a0f					      plbytevar	V_src2.t
      1  1a0f				  -	      IF	!FPULL
      2  1a0f				  -	      pla
      3  1a0f					      ENDIF
      4  1a0f		       8d 72 34 	      sta	V_src2.t
    901  1a0f				   FPULL      SET	0
    902  1a0f				   FPUSH      SET	1
      0  1a12					      pbyte	2
      1  1a12		       a9 02		      lda	#2
      2  1a14				  -	      IF	!FPUSH
      3  1a14				  -	      pha
      4  1a14					      ENDIF
    904  1a14				   FPULL      SET	1
    905  1a14				   FPUSH      SET	0
      0  1a14					      plbytevar	V_src2.playermove_.playermove
      1  1a14				  -	      IF	!FPULL
      2  1a14				  -	      pla
      3  1a14					      ENDIF
      4  1a14		       8d 4e 34 	      sta	V_src2.playermove_.playermove
    907  1a17		       60		      rts
    908  1a18				   _EL_14
    909  1a18
    910  1a18
    911  1a18
    912  1a18				   _EI_14
    913  1a18		       4c 20 1e 	      jmp	L_src2.playermove_.41
    914  1a1b
    915  1a1b
    916  1a1b
    917  1a1b				   L_src2.playermove_.up
    918  1a1b
    919  1a1b				   FPULL      SET	0
    920  1a1b				   FPUSH      SET	1
      0  1a1b					      pbytevar_pbyte_cmpbyteeq	V_src2.t, 57
      1  1a1b		       ad 72 34 	      lda	V_src2.t
      2  1a1e		       c9 39		      cmp	#57
      3  1a20		       f0 04		      beq	.true
      0  1a22					      pfalse
      1  1a22		       a9 00		      lda	#$00
      2  1a24				  -	      IF	!FPUSH
      3  1a24				  -	      pha
      4  1a24					      ENDIF
      5  1a24		       f0 02		      beq	.end
      6  1a26				   .true
      0  1a26					      ptrue
      1  1a26		       a9 ff		      lda	#$FF
      2  1a28				  -	      IF	!FPUSH
      3  1a28				  -	      pha
      4  1a28					      ENDIF
      8  1a28				   .end
    922  1a28				   FPULL      SET	1
    923  1a28				   FPUSH      SET	0
      0  1a28					      cond_stmt	_EI_15, _EL_15
      1  1a28				  -	      IF	!FPULL
      2  1a28				  -	      pla
      3  1a28					      ENDIF
      4  1a28		       d0 03		      bne	* + 5
      5  1a2a					      IF	_EL_15 > 0 && _EL_15 < $10000
      6  1a2a		       4c af 1a 	      jmp	_EL_15
      7  1a2d				  -	      ELSE
      8  1a2d				  -	      jmp	_EI_15
      9  1a2d					      ENDIF
    925  1a2d				   FPULL      SET	0
      0  1a2d					      pbytevar	V_src2.t
      1  1a2d		       ad 72 34 	      lda	V_src2.t
      2  1a30					      IF	!FPUSH
      3  1a30		       48		      pha
      4  1a31					      ENDIF
    927  1a31				   FPUSH      SET	1
      0  1a31					      pwordvar	V_src2.pos_man
      1  1a31				  -	      IF	!FPUSH
      2  1a31				  -	      lda	V_src2.pos_man
      3  1a31				  -	      pha
      4  1a31				  -	      lda	V_src2.pos_man+1
      5  1a31				  -	      pha
      6  1a31					      ELSE
      7  1a31		       ad 50 34 	      lda	V_src2.pos_man
      8  1a34		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1a37					      ENDIF
    929  1a37				   FPULL      SET	1
    930  1a37				   FPUSH      SET	0
      0  1a37					      poke
      1  1a37				  -	      IF	!FPULL
      2  1a37				  -	      pla
      3  1a37				  -	      sta	.l + 2
      4  1a37				  -	      pla
      5  1a37				  -	      sta	.l + 1
      6  1a37					      ELSE
      7  1a37		       8d 3f 1a 	      sta	.l + 1
      8  1a3a		       8c 40 1a 	      sty	.l + 2
      9  1a3d					      ENDIF
     10  1a3d		       68		      pla
     11  1a3e		       8d ff ff    .l	      sta	$ffff
    932  1a3e				   FPULL      SET	0
      0  1a41					      pbytevar	V_src2.t
      1  1a41		       ad 72 34 	      lda	V_src2.t
      2  1a44					      IF	!FPUSH
      3  1a44		       48		      pha
      4  1a45					      ENDIF
    934  1a45				   FPUSH      SET	1
      0  1a45					      pbyte	56
      1  1a45		       a9 38		      lda	#56
      2  1a47				  -	      IF	!FPUSH
      3  1a47				  -	      pha
      4  1a47					      ENDIF
    936  1a47				   FPULL      SET	1
      0  1a47					      subbyte
      1  1a47				  -	      IF	!FPULL
      2  1a47				  -	      pla
      3  1a47					      ENDIF
      4  1a47		       85 02		      sta	R0
      5  1a49		       68		      pla
      6  1a4a		       38		      sec
      7  1a4b		       e5 02		      sbc	R0
      8  1a4d				  -	      IF	!FPUSH
      9  1a4d				  -	      pha
     10  1a4d					      ENDIF
    938  1a4d				   FPUSH      SET	0
      0  1a4d					      pbytearrayfast	V_src2.d
      1  1a4d				  -	      IF	!FPULL
      2  1a4d				  -	      pla
      3  1a4d					      ENDIF
      4  1a4d		       aa		      tax
      5  1a4e		       bd 68 34 	      lda	V_src2.d,x
      6  1a51					      IF	!FPUSH
      7  1a51		       48		      pha
      8  1a52					      ENDIF
    940  1a52				   FPULL      SET	0
      0  1a52					      pwordvar	V_src2.pos_man
      1  1a52					      IF	!FPUSH
      2  1a52		       ad 50 34 	      lda	V_src2.pos_man
      3  1a55		       48		      pha
      4  1a56		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1a59		       48		      pha
      6  1a5a				  -	      ELSE
      7  1a5a				  -	      lda	V_src2.pos_man
      8  1a5a				  -	      ldy	V_src2.pos_man+1
      9  1a5a					      ENDIF
      0  1a5a					      F_cint_word
      0  1a5a					      pint	30720
      0  1a5a					      pword	30720
      1  1a5a					      IF	!FPUSH
      2  1a5a		       a9 00		      lda	#<30720
      3  1a5c		       48		      pha
      4  1a5d		       a9 78		      lda	#>30720
      5  1a5f		       48		      pha
      6  1a60				  -	      ELSE
      7  1a60				  -	      lda	#<30720
      8  1a60				  -	      ldy	#>30720
      9  1a60					      ENDIF
      0  1a60					      addint
      0  1a60					      addword
      1  1a60		       ba		      tsx
      2  1a61		       bd 02 01 	      lda.wx	stack + 2
      3  1a64		       18		      clc
      4  1a65		       7d 04 01 	      adc.wx	stack + 4
      5  1a68		       9d 04 01 	      sta.wx	stack + 4
      6  1a6b		       68		      pla
      7  1a6c		       7d 03 01 	      adc.wx	stack + 3
      8  1a6f		       9d 03 01 	      sta.wx	stack + 3
      9  1a72		       68		      pla
      0  1a73					      F_cword_int
      0  1a73					      poke
      1  1a73					      IF	!FPULL
      2  1a73		       68		      pla
      3  1a74		       8d 7e 1a 	      sta	.l + 2
      4  1a77		       68		      pla
      5  1a78		       8d 7d 1a 	      sta	.l + 1
      6  1a7b				  -	      ELSE
      7  1a7b				  -	      sta	.l + 1
      8  1a7b				  -	      sty	.l + 2
      9  1a7b					      ENDIF
     10  1a7b		       68		      pla
     11  1a7c		       8d ff ff    .l	      sta	$ffff
      0  1a7f					      pwordvar	V_src2.pos_man
      1  1a7f					      IF	!FPUSH
      2  1a7f		       ad 50 34 	      lda	V_src2.pos_man
      3  1a82		       48		      pha
      4  1a83		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1a86		       48		      pha
      6  1a87				  -	      ELSE
      7  1a87				  -	      lda	V_src2.pos_man
      8  1a87				  -	      ldy	V_src2.pos_man+1
      9  1a87					      ENDIF
      0  1a87					      pbyte	22
      1  1a87		       a9 16		      lda	#22
      2  1a89					      IF	!FPUSH
      3  1a89		       48		      pha
      4  1a8a					      ENDIF
      0  1a8a					      F_cword_byte
      1  1a8a		       a9 00		      lda	#$00
      2  1a8c		       48		      pha
      0  1a8d					      subword
      1  1a8d		       ba		      tsx
      2  1a8e		       bd 04 01 	      lda.wx	stack + 4
      3  1a91		       38		      sec
      4  1a92		       fd 02 01 	      sbc.wx	stack + 2
      5  1a95		       9d 04 01 	      sta.wx	stack + 4
      6  1a98		       bd 03 01 	      lda.wx	stack + 3
      7  1a9b		       fd 01 01 	      sbc.wx	stack + 1
      8  1a9e		       9d 03 01 	      sta.wx	stack + 3
      9  1aa1		       e8		      inx
     10  1aa2		       e8		      inx
     11  1aa3		       9a		      txs
      0  1aa4					      plwordvar	V_src2.pos_man
      1  1aa4					      IF	!FPULL
      2  1aa4		       68		      pla
      3  1aa5		       8d 51 34 	      sta	V_src2.pos_man+1
      4  1aa8		       68		      pla
      5  1aa9		       8d 50 34 	      sta	V_src2.pos_man
      6  1aac				  -	      ELSE
      7  1aac				  -	      sta	V_src2.pos_man
      8  1aac				  -	      sty	V_src2.pos_man+1
      9  1aac					      ENDIF
    952  1aac		       4c c1 1d 	      jmp	L_src2.playermove_.40
    953  1aaf				   _EL_15
    954  1aaf
    955  1aaf
    956  1aaf
    957  1aaf				   _EI_15
    958  1aaf		       4c 20 1e 	      jmp	L_src2.playermove_.41
    959  1ab2
    960  1ab2
    961  1ab2
    962  1ab2				   L_src2.playermove_.right
      0  1ab2					      pbyte	1
      1  1ab2		       a9 01		      lda	#1
      2  1ab4					      IF	!FPUSH
      3  1ab4		       48		      pha
      4  1ab5					      ENDIF
      0  1ab5					      F_cword_byte
      1  1ab5		       a9 00		      lda	#$00
      2  1ab7		       48		      pha
      0  1ab8					      plwordvar	V_src2.dir_man
      1  1ab8					      IF	!FPULL
      2  1ab8		       68		      pla
      3  1ab9		       8d 53 34 	      sta	V_src2.dir_man+1
      4  1abc		       68		      pla
      5  1abd		       8d 52 34 	      sta	V_src2.dir_man
      6  1ac0				  -	      ELSE
      7  1ac0				  -	      sta	V_src2.dir_man
      8  1ac0				  -	      sty	V_src2.dir_man+1
      9  1ac0					      ENDIF
    966  1ac0				   FPUSH      SET	1
      0  1ac0					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 23
      0  1ac0					      pintvar_pint_addint	V_src2.pos_man, 23
      1  1ac0		       ad 50 34 	      lda	V_src2.pos_man
      2  1ac3		       18		      clc
      3  1ac4		       69 17		      adc	#<23
      4  1ac6				  -	      IF	!FPUSH
      5  1ac6				  -	      pha
      6  1ac6					      ELSE
      7  1ac6		       aa		      tax
      8  1ac7					      ENDIF
      9  1ac7		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  1aca		       69 00		      adc	#>23
     11  1acc				  -	      IF	!FPUSH
     12  1acc				  -	      pha
     13  1acc					      ELSE
     14  1acc		       a8		      tay
     15  1acd		       8a		      txa
     16  1ace					      ENDIF
    968  1ace				   FPULL      SET	1
    969  1ace				   FPUSH      SET	0
      0  1ace					      F_peek_word
      1  1ace				  -	      IF	!FPULL
      2  1ace				  -	      pla
      3  1ace				  -	      sta	.l + 2
      4  1ace				  -	      pla
      5  1ace				  -	      sta	.l + 1
      6  1ace					      ELSE
      7  1ace		       8d d5 1a 	      sta	.l + 1
      8  1ad1		       8c d6 1a 	      sty	.l + 2
      9  1ad4					      ENDIF
     10  1ad4		       ad ff ff    .l	      lda	$FFFF
     11  1ad7					      IF	!FPUSH
     12  1ad7		       48		      pha
     13  1ad8					      ENDIF
    971  1ad8				   FPULL      SET	0
    972  1ad8				   FPUSH      SET	1
      0  1ad8					      pbyte	62
      1  1ad8		       a9 3e		      lda	#62
      2  1ada				  -	      IF	!FPUSH
      3  1ada				  -	      pha
      4  1ada					      ENDIF
    974  1ada				   FPULL      SET	1
      0  1ada					      cmpbytelt
      1  1ada				  -	      IF	!FPULL
      2  1ada				  -	      pla
      3  1ada					      ENDIF
      4  1ada		       85 02		      sta	R0
      5  1adc		       68		      pla
      6  1add		       c5 02		      cmp	R0
      7  1adf		       b0 04		      bcs	.phf
      0  1ae1					      ptrue
      1  1ae1		       a9 ff		      lda	#$FF
      2  1ae3				  -	      IF	!FPUSH
      3  1ae3				  -	      pha
      4  1ae3					      ENDIF
      9  1ae3		       d0 02		      bne	.q
      0  1ae5				   .phf       pfalse
      1  1ae5		       a9 00		      lda	#$00
      2  1ae7				  -	      IF	!FPUSH
      3  1ae7				  -	      pha
      4  1ae7					      ENDIF
     11  1ae7				   .q
    976  1ae7				   FPUSH      SET	0
      0  1ae7					      cond_stmt	_EI_16, _EL_16
      1  1ae7				  -	      IF	!FPULL
      2  1ae7				  -	      pla
      3  1ae7					      ENDIF
      4  1ae7		       d0 03		      bne	* + 5
      5  1ae9					      IF	_EL_16 > 0 && _EL_16 < $10000
      6  1ae9		       4c 55 1b 	      jmp	_EL_16
      7  1aec				  -	      ELSE
      8  1aec				  -	      jmp	_EI_16
      9  1aec					      ENDIF
    978  1aec				   FPULL      SET	0
      0  1aec					      pbytevar	V_src2.t
      1  1aec		       ad 72 34 	      lda	V_src2.t
      2  1aef					      IF	!FPUSH
      3  1aef		       48		      pha
      4  1af0					      ENDIF
    980  1af0				   FPUSH      SET	1
      0  1af0					      pwordvar	V_src2.pos_man
      1  1af0				  -	      IF	!FPUSH
      2  1af0				  -	      lda	V_src2.pos_man
      3  1af0				  -	      pha
      4  1af0				  -	      lda	V_src2.pos_man+1
      5  1af0				  -	      pha
      6  1af0					      ELSE
      7  1af0		       ad 50 34 	      lda	V_src2.pos_man
      8  1af3		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1af6					      ENDIF
    982  1af6				   FPULL      SET	1
    983  1af6				   FPUSH      SET	0
      0  1af6					      poke
      1  1af6				  -	      IF	!FPULL
      2  1af6				  -	      pla
      3  1af6				  -	      sta	.l + 2
      4  1af6				  -	      pla
      5  1af6				  -	      sta	.l + 1
      6  1af6					      ELSE
      7  1af6		       8d fe 1a 	      sta	.l + 1
      8  1af9		       8c ff 1a 	      sty	.l + 2
      9  1afc					      ENDIF
     10  1afc		       68		      pla
     11  1afd		       8d ff ff    .l	      sta	$ffff
    985  1afd				   FPULL      SET	0
      0  1b00					      pbytevar	V_src2.t
      1  1b00		       ad 72 34 	      lda	V_src2.t
      2  1b03					      IF	!FPUSH
      3  1b03		       48		      pha
      4  1b04					      ENDIF
    987  1b04				   FPUSH      SET	1
      0  1b04					      pbyte	56
      1  1b04		       a9 38		      lda	#56
      2  1b06				  -	      IF	!FPUSH
      3  1b06				  -	      pha
      4  1b06					      ENDIF
    989  1b06				   FPULL      SET	1
      0  1b06					      subbyte
      1  1b06				  -	      IF	!FPULL
      2  1b06				  -	      pla
      3  1b06					      ENDIF
      4  1b06		       85 02		      sta	R0
      5  1b08		       68		      pla
      6  1b09		       38		      sec
      7  1b0a		       e5 02		      sbc	R0
      8  1b0c				  -	      IF	!FPUSH
      9  1b0c				  -	      pha
     10  1b0c					      ENDIF
    991  1b0c				   FPUSH      SET	0
      0  1b0c					      pbytearrayfast	V_src2.d
      1  1b0c				  -	      IF	!FPULL
      2  1b0c				  -	      pla
      3  1b0c					      ENDIF
      4  1b0c		       aa		      tax
      5  1b0d		       bd 68 34 	      lda	V_src2.d,x
      6  1b10					      IF	!FPUSH
      7  1b10		       48		      pha
      8  1b11					      ENDIF
    993  1b11				   FPULL      SET	0
      0  1b11					      pwordvar	V_src2.pos_man
      1  1b11					      IF	!FPUSH
      2  1b11		       ad 50 34 	      lda	V_src2.pos_man
      3  1b14		       48		      pha
      4  1b15		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1b18		       48		      pha
      6  1b19				  -	      ELSE
      7  1b19				  -	      lda	V_src2.pos_man
      8  1b19				  -	      ldy	V_src2.pos_man+1
      9  1b19					      ENDIF
      0  1b19					      F_cint_word
      0  1b19					      pint	30720
      0  1b19					      pword	30720
      1  1b19					      IF	!FPUSH
      2  1b19		       a9 00		      lda	#<30720
      3  1b1b		       48		      pha
      4  1b1c		       a9 78		      lda	#>30720
      5  1b1e		       48		      pha
      6  1b1f				  -	      ELSE
      7  1b1f				  -	      lda	#<30720
      8  1b1f				  -	      ldy	#>30720
      9  1b1f					      ENDIF
      0  1b1f					      addint
      0  1b1f					      addword
      1  1b1f		       ba		      tsx
      2  1b20		       bd 02 01 	      lda.wx	stack + 2
      3  1b23		       18		      clc
      4  1b24		       7d 04 01 	      adc.wx	stack + 4
      5  1b27		       9d 04 01 	      sta.wx	stack + 4
      6  1b2a		       68		      pla
      7  1b2b		       7d 03 01 	      adc.wx	stack + 3
      8  1b2e		       9d 03 01 	      sta.wx	stack + 3
      9  1b31		       68		      pla
      0  1b32					      F_cword_int
      0  1b32					      poke
      1  1b32					      IF	!FPULL
      2  1b32		       68		      pla
      3  1b33		       8d 3d 1b 	      sta	.l + 2
      4  1b36		       68		      pla
      5  1b37		       8d 3c 1b 	      sta	.l + 1
      6  1b3a				  -	      ELSE
      7  1b3a				  -	      sta	.l + 1
      8  1b3a				  -	      sty	.l + 2
      9  1b3a					      ENDIF
     10  1b3a		       68		      pla
     11  1b3b		       8d ff ff    .l	      sta	$ffff
   1000  1b3b				   FPUSH      SET	1
      0  1b3e					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 1
      0  1b3e					      pintvar_pint_addint	V_src2.pos_man, 1
      1  1b3e		       ad 50 34 	      lda	V_src2.pos_man
      2  1b41		       18		      clc
      3  1b42		       69 01		      adc	#<1
      4  1b44				  -	      IF	!FPUSH
      5  1b44				  -	      pha
      6  1b44					      ELSE
      7  1b44		       aa		      tax
      8  1b45					      ENDIF
      9  1b45		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  1b48		       69 00		      adc	#>1
     11  1b4a				  -	      IF	!FPUSH
     12  1b4a				  -	      pha
     13  1b4a					      ELSE
     14  1b4a		       a8		      tay
     15  1b4b		       8a		      txa
     16  1b4c					      ENDIF
   1002  1b4c				   FPULL      SET	1
   1003  1b4c				   FPUSH      SET	0
      0  1b4c					      plwordvar	V_src2.pos_man
      1  1b4c				  -	      IF	!FPULL
      2  1b4c				  -	      pla
      3  1b4c				  -	      sta	V_src2.pos_man+1
      4  1b4c				  -	      pla
      5  1b4c				  -	      sta	V_src2.pos_man
      6  1b4c					      ELSE
      7  1b4c		       8d 50 34 	      sta	V_src2.pos_man
      8  1b4f		       8c 51 34 	      sty	V_src2.pos_man+1
      9  1b52					      ENDIF
   1005  1b52		       4c c1 1d 	      jmp	L_src2.playermove_.40
   1006  1b55
   1007  1b55
   1008  1b55
   1009  1b55				   _EL_16
   1010  1b55
   1011  1b55
   1012  1b55
   1013  1b55				   _EI_16
   1014  1b55		       4c 87 19 	      jmp	L_src2.playermove_.29
   1015  1b58
   1016  1b58
   1017  1b58
   1018  1b58				   L_src2.playermove_.fire
   1019  1b58				   FPULL      SET	0
   1020  1b58				   FPUSH      SET	1
      0  1b58					      pbyte	240
      1  1b58		       a9 f0		      lda	#240
      2  1b5a				  -	      IF	!FPUSH
      3  1b5a				  -	      pha
      4  1b5a					      ENDIF
   1022  1b5a				   FPULL      SET	1
   1023  1b5a				   FPUSH      SET	0
      0  1b5a					      poke_constaddr	$900C
      1  1b5a				  -	      IF	!FPULL
      2  1b5a				  -	      pla
      3  1b5a					      ENDIF
      4  1b5a		       8d 0c 90 	      sta	$900C
   1025  1b5a				   FPULL      SET	0
      0  1b5d					      pbytevar	V_src2.t
      1  1b5d		       ad 72 34 	      lda	V_src2.t
      2  1b60					      IF	!FPUSH
      3  1b60		       48		      pha
      4  1b61					      ENDIF
   1027  1b61				   FPUSH      SET	1
      0  1b61					      pwordvar	V_src2.pos_man
      1  1b61				  -	      IF	!FPUSH
      2  1b61				  -	      lda	V_src2.pos_man
      3  1b61				  -	      pha
      4  1b61				  -	      lda	V_src2.pos_man+1
      5  1b61				  -	      pha
      6  1b61					      ELSE
      7  1b61		       ad 50 34 	      lda	V_src2.pos_man
      8  1b64		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1b67					      ENDIF
   1029  1b67				   FPULL      SET	1
   1030  1b67				   FPUSH      SET	0
      0  1b67					      poke
      1  1b67				  -	      IF	!FPULL
      2  1b67				  -	      pla
      3  1b67				  -	      sta	.l + 2
      4  1b67				  -	      pla
      5  1b67				  -	      sta	.l + 1
      6  1b67					      ELSE
      7  1b67		       8d 6f 1b 	      sta	.l + 1
      8  1b6a		       8c 70 1b 	      sty	.l + 2
      9  1b6d					      ENDIF
     10  1b6d		       68		      pla
     11  1b6e		       8d ff ff    .l	      sta	$ffff
   1032  1b6e				   FPULL      SET	0
      0  1b71					      pbytevar	V_src2.t
      1  1b71		       ad 72 34 	      lda	V_src2.t
      2  1b74					      IF	!FPUSH
      3  1b74		       48		      pha
      4  1b75					      ENDIF
   1034  1b75				   FPUSH      SET	1
      0  1b75					      pbyte	56
      1  1b75		       a9 38		      lda	#56
      2  1b77				  -	      IF	!FPUSH
      3  1b77				  -	      pha
      4  1b77					      ENDIF
   1036  1b77				   FPULL      SET	1
      0  1b77					      subbyte
      1  1b77				  -	      IF	!FPULL
      2  1b77				  -	      pla
      3  1b77					      ENDIF
      4  1b77		       85 02		      sta	R0
      5  1b79		       68		      pla
      6  1b7a		       38		      sec
      7  1b7b		       e5 02		      sbc	R0
      8  1b7d				  -	      IF	!FPUSH
      9  1b7d				  -	      pha
     10  1b7d					      ENDIF
   1038  1b7d				   FPUSH      SET	0
      0  1b7d					      pbytearrayfast	V_src2.d
      1  1b7d				  -	      IF	!FPULL
      2  1b7d				  -	      pla
      3  1b7d					      ENDIF
      4  1b7d		       aa		      tax
      5  1b7e		       bd 68 34 	      lda	V_src2.d,x
      6  1b81					      IF	!FPUSH
      7  1b81		       48		      pha
      8  1b82					      ENDIF
   1040  1b82				   FPULL      SET	0
      0  1b82					      pwordvar	V_src2.pos_man
      1  1b82					      IF	!FPUSH
      2  1b82		       ad 50 34 	      lda	V_src2.pos_man
      3  1b85		       48		      pha
      4  1b86		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1b89		       48		      pha
      6  1b8a				  -	      ELSE
      7  1b8a				  -	      lda	V_src2.pos_man
      8  1b8a				  -	      ldy	V_src2.pos_man+1
      9  1b8a					      ENDIF
      0  1b8a					      F_cint_word
      0  1b8a					      pint	30720
      0  1b8a					      pword	30720
      1  1b8a					      IF	!FPUSH
      2  1b8a		       a9 00		      lda	#<30720
      3  1b8c		       48		      pha
      4  1b8d		       a9 78		      lda	#>30720
      5  1b8f		       48		      pha
      6  1b90				  -	      ELSE
      7  1b90				  -	      lda	#<30720
      8  1b90				  -	      ldy	#>30720
      9  1b90					      ENDIF
      0  1b90					      addint
      0  1b90					      addword
      1  1b90		       ba		      tsx
      2  1b91		       bd 02 01 	      lda.wx	stack + 2
      3  1b94		       18		      clc
      4  1b95		       7d 04 01 	      adc.wx	stack + 4
      5  1b98		       9d 04 01 	      sta.wx	stack + 4
      6  1b9b		       68		      pla
      7  1b9c		       7d 03 01 	      adc.wx	stack + 3
      8  1b9f		       9d 03 01 	      sta.wx	stack + 3
      9  1ba2		       68		      pla
      0  1ba3					      F_cword_int
      0  1ba3					      poke
      1  1ba3					      IF	!FPULL
      2  1ba3		       68		      pla
      3  1ba4		       8d ae 1b 	      sta	.l + 2
      4  1ba7		       68		      pla
      5  1ba8		       8d ad 1b 	      sta	.l + 1
      6  1bab				  -	      ELSE
      7  1bab				  -	      sta	.l + 1
      8  1bab				  -	      sty	.l + 2
      9  1bab					      ENDIF
     10  1bab		       68		      pla
     11  1bac		       8d ff ff    .l	      sta	$ffff
      0  1baf					      pwordvar	V_src2.pos_man
      1  1baf					      IF	!FPUSH
      2  1baf		       ad 50 34 	      lda	V_src2.pos_man
      3  1bb2		       48		      pha
      4  1bb3		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1bb6		       48		      pha
      6  1bb7				  -	      ELSE
      7  1bb7				  -	      lda	V_src2.pos_man
      8  1bb7				  -	      ldy	V_src2.pos_man+1
      9  1bb7					      ENDIF
      0  1bb7					      pbyte	22
      1  1bb7		       a9 16		      lda	#22
      2  1bb9					      IF	!FPUSH
      3  1bb9		       48		      pha
      4  1bba					      ENDIF
      0  1bba					      F_cword_byte
      1  1bba		       a9 00		      lda	#$00
      2  1bbc		       48		      pha
      0  1bbd					      subword
      1  1bbd		       ba		      tsx
      2  1bbe		       bd 04 01 	      lda.wx	stack + 4
      3  1bc1		       38		      sec
      4  1bc2		       fd 02 01 	      sbc.wx	stack + 2
      5  1bc5		       9d 04 01 	      sta.wx	stack + 4
      6  1bc8		       bd 03 01 	      lda.wx	stack + 3
      7  1bcb		       fd 01 01 	      sbc.wx	stack + 1
      8  1bce		       9d 03 01 	      sta.wx	stack + 3
      9  1bd1		       e8		      inx
     10  1bd2		       e8		      inx
     11  1bd3		       9a		      txs
      0  1bd4					      pwordvar	V_src2.dir_man
      1  1bd4					      IF	!FPUSH
      2  1bd4		       ad 52 34 	      lda	V_src2.dir_man
      3  1bd7		       48		      pha
      4  1bd8		       ad 53 34 	      lda	V_src2.dir_man+1
      5  1bdb		       48		      pha
      6  1bdc				  -	      ELSE
      7  1bdc				  -	      lda	V_src2.dir_man
      8  1bdc				  -	      ldy	V_src2.dir_man+1
      9  1bdc					      ENDIF
      0  1bdc					      addword
      1  1bdc		       ba		      tsx
      2  1bdd		       bd 02 01 	      lda.wx	stack + 2
      3  1be0		       18		      clc
      4  1be1		       7d 04 01 	      adc.wx	stack + 4
      5  1be4		       9d 04 01 	      sta.wx	stack + 4
      6  1be7		       68		      pla
      7  1be8		       7d 03 01 	      adc.wx	stack + 3
      8  1beb		       9d 03 01 	      sta.wx	stack + 3
      9  1bee		       68		      pla
      0  1bef					      plwordvar	V_src2.pos_man
      1  1bef					      IF	!FPULL
      2  1bef		       68		      pla
      3  1bf0		       8d 51 34 	      sta	V_src2.pos_man+1
      4  1bf3		       68		      pla
      5  1bf4		       8d 50 34 	      sta	V_src2.pos_man
      6  1bf7				  -	      ELSE
      7  1bf7				  -	      sta	V_src2.pos_man
      8  1bf7				  -	      sty	V_src2.pos_man+1
      9  1bf7					      ENDIF
   1054  1bf7				   FPUSH      SET	1
      0  1bf7					      pwordvar	V_src2.pos_man
      1  1bf7				  -	      IF	!FPUSH
      2  1bf7				  -	      lda	V_src2.pos_man
      3  1bf7				  -	      pha
      4  1bf7				  -	      lda	V_src2.pos_man+1
      5  1bf7				  -	      pha
      6  1bf7					      ELSE
      7  1bf7		       ad 50 34 	      lda	V_src2.pos_man
      8  1bfa		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1bfd					      ENDIF
   1056  1bfd				   FPULL      SET	1
      0  1bfd					      F_peek_word
      1  1bfd				  -	      IF	!FPULL
      2  1bfd				  -	      pla
      3  1bfd				  -	      sta	.l + 2
      4  1bfd				  -	      pla
      5  1bfd				  -	      sta	.l + 1
      6  1bfd					      ELSE
      7  1bfd		       8d 04 1c 	      sta	.l + 1
      8  1c00		       8c 05 1c 	      sty	.l + 2
      9  1c03					      ENDIF
     10  1c03		       ad ff ff    .l	      lda	$FFFF
     11  1c06				  -	      IF	!FPUSH
     12  1c06				  -	      pha
     13  1c06					      ENDIF
   1058  1c06				   FPUSH      SET	0
      0  1c06					      plbytevar	V_src2.t
      1  1c06				  -	      IF	!FPULL
      2  1c06				  -	      pla
      3  1c06					      ENDIF
      4  1c06		       8d 72 34 	      sta	V_src2.t
   1060  1c06				   FPULL      SET	0
      0  1c09					      pbyte	58
      1  1c09		       a9 3a		      lda	#58
      2  1c0b					      IF	!FPUSH
      3  1c0b		       48		      pha
      4  1c0c					      ENDIF
   1062  1c0c				   FPUSH      SET	1
      0  1c0c					      pwordvar	V_src2.pos_man
      1  1c0c				  -	      IF	!FPUSH
      2  1c0c				  -	      lda	V_src2.pos_man
      3  1c0c				  -	      pha
      4  1c0c				  -	      lda	V_src2.pos_man+1
      5  1c0c				  -	      pha
      6  1c0c					      ELSE
      7  1c0c		       ad 50 34 	      lda	V_src2.pos_man
      8  1c0f		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1c12					      ENDIF
   1064  1c12				   FPULL      SET	1
   1065  1c12				   FPUSH      SET	0
      0  1c12					      poke
      1  1c12				  -	      IF	!FPULL
      2  1c12				  -	      pla
      3  1c12				  -	      sta	.l + 2
      4  1c12				  -	      pla
      5  1c12				  -	      sta	.l + 1
      6  1c12					      ELSE
      7  1c12		       8d 1a 1c 	      sta	.l + 1
      8  1c15		       8c 1b 1c 	      sty	.l + 2
      9  1c18					      ENDIF
     10  1c18		       68		      pla
     11  1c19		       8d ff ff    .l	      sta	$ffff
      0  1c1c					      pbytevar_pbyte_cmpbyteeq_cond_stmt	V_src2.t, 60, _EI_65543, 0
      1  1c1c		       ad 72 34 	      lda	V_src2.t
      2  1c1f		       c9 3c		      cmp	#60
      3  1c21		       f0 03		      beq	.true
      4  1c23				  -	      IF	0 > 0 && 60 < $10000
      5  1c23				  -	      jmp	0
      6  1c23					      ELSE
      7  1c23		       4c 2c 1c 	      jmp	_EI_65543
      8  1c26					      ENDIF
      9  1c26				   .true
   1068  1c26				   FPULL      SET	0
   1069  1c26				   FPUSH      SET	1
      0  1c26					      pbyte	2
      1  1c26		       a9 02		      lda	#2
      2  1c28				  -	      IF	!FPUSH
      3  1c28				  -	      pha
      4  1c28					      ENDIF
   1071  1c28				   FPULL      SET	1
   1072  1c28				   FPUSH      SET	0
      0  1c28					      plbytevar	V_src2.playermove_.playermove
      1  1c28				  -	      IF	!FPULL
      2  1c28				  -	      pla
      3  1c28					      ENDIF
      4  1c28		       8d 4e 34 	      sta	V_src2.playermove_.playermove
   1074  1c2b		       60		      rts
   1075  1c2c				   _EI_65543
   1076  1c2c
   1077  1c2c				   FPULL      SET	0
   1078  1c2c				   FPUSH      SET	1
      0  1c2c					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 22
      0  1c2c					      pintvar_pint_addint	V_src2.pos_man, 22
      1  1c2c		       ad 50 34 	      lda	V_src2.pos_man
      2  1c2f		       18		      clc
      3  1c30		       69 16		      adc	#<22
      4  1c32				  -	      IF	!FPUSH
      5  1c32				  -	      pha
      6  1c32					      ELSE
      7  1c32		       aa		      tax
      8  1c33					      ENDIF
      9  1c33		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  1c36		       69 00		      adc	#>22
     11  1c38				  -	      IF	!FPUSH
     12  1c38				  -	      pha
     13  1c38					      ELSE
     14  1c38		       a8		      tay
     15  1c39		       8a		      txa
     16  1c3a					      ENDIF
   1080  1c3a				   FPULL      SET	1
   1081  1c3a				   FPUSH      SET	0
      0  1c3a					      F_peek_word
      1  1c3a				  -	      IF	!FPULL
      2  1c3a				  -	      pla
      3  1c3a				  -	      sta	.l + 2
      4  1c3a				  -	      pla
      5  1c3a				  -	      sta	.l + 1
      6  1c3a					      ELSE
      7  1c3a		       8d 41 1c 	      sta	.l + 1
      8  1c3d		       8c 42 1c 	      sty	.l + 2
      9  1c40					      ENDIF
     10  1c40		       ad ff ff    .l	      lda	$FFFF
     11  1c43					      IF	!FPUSH
     12  1c43		       48		      pha
     13  1c44					      ENDIF
   1083  1c44				   FPULL      SET	0
   1084  1c44				   FPUSH      SET	1
      0  1c44					      pbyte	60
      1  1c44		       a9 3c		      lda	#60
      2  1c46				  -	      IF	!FPUSH
      3  1c46				  -	      pha
      4  1c46					      ENDIF
   1086  1c46				   FPULL      SET	1
      0  1c46					      cmpbyteeq
      1  1c46				  -	      IF	!FPULL
      2  1c46				  -	      pla
      3  1c46					      ENDIF
      4  1c46		       85 02		      sta	R0
      5  1c48		       68		      pla
      6  1c49		       c5 02		      cmp	R0
      7  1c4b		       f0 04		      beq	.pht
      0  1c4d					      pfalse
      1  1c4d		       a9 00		      lda	#$00
      2  1c4f				  -	      IF	!FPUSH
      3  1c4f				  -	      pha
      4  1c4f					      ENDIF
      9  1c4f		       f0 02		      beq	.q
      0  1c51				   .pht       ptrue
      1  1c51		       a9 ff		      lda	#$FF
      2  1c53				  -	      IF	!FPUSH
      3  1c53				  -	      pha
      4  1c53					      ENDIF
     11  1c53				   .q
   1088  1c53				   FPUSH      SET	0
      0  1c53					      cond_stmt	_EI_17, _EL_17
      1  1c53				  -	      IF	!FPULL
      2  1c53				  -	      pla
      3  1c53					      ENDIF
      4  1c53		       d0 03		      bne	* + 5
      5  1c55					      IF	_EL_17 > 0 && _EL_17 < $10000
      6  1c55		       4c 84 1c 	      jmp	_EL_17
      7  1c58				  -	      ELSE
      8  1c58				  -	      jmp	_EI_17
      9  1c58					      ENDIF
   1090  1c58				   FPULL      SET	0
      0  1c58					      pwordvar	V_src2.score
      1  1c58					      IF	!FPUSH
      2  1c58		       ad 59 34 	      lda	V_src2.score
      3  1c5b		       48		      pha
      4  1c5c		       ad 5a 34 	      lda	V_src2.score+1
      5  1c5f		       48		      pha
      6  1c60				  -	      ELSE
      7  1c60				  -	      lda	V_src2.score
      8  1c60				  -	      ldy	V_src2.score+1
      9  1c60					      ENDIF
      0  1c60					      F_cint_word
      0  1c60					      pint	1000
      0  1c60					      pword	1000
      1  1c60					      IF	!FPUSH
      2  1c60		       a9 e8		      lda	#<1000
      3  1c62		       48		      pha
      4  1c63		       a9 03		      lda	#>1000
      5  1c65		       48		      pha
      6  1c66				  -	      ELSE
      7  1c66				  -	      lda	#<1000
      8  1c66				  -	      ldy	#>1000
      9  1c66					      ENDIF
      0  1c66					      addint
      0  1c66					      addword
      1  1c66		       ba		      tsx
      2  1c67		       bd 02 01 	      lda.wx	stack + 2
      3  1c6a		       18		      clc
      4  1c6b		       7d 04 01 	      adc.wx	stack + 4
      5  1c6e		       9d 04 01 	      sta.wx	stack + 4
      6  1c71		       68		      pla
      7  1c72		       7d 03 01 	      adc.wx	stack + 3
      8  1c75		       9d 03 01 	      sta.wx	stack + 3
      9  1c78		       68		      pla
      0  1c79					      F_cword_int
      0  1c79					      plwordvar	V_src2.score
      1  1c79					      IF	!FPULL
      2  1c79		       68		      pla
      3  1c7a		       8d 5a 34 	      sta	V_src2.score+1
      4  1c7d		       68		      pla
      5  1c7e		       8d 59 34 	      sta	V_src2.score
      6  1c81				  -	      ELSE
      7  1c81				  -	      sta	V_src2.score
      8  1c81				  -	      sty	V_src2.score+1
      9  1c81					      ENDIF
      0  1c81					      import	I_F_src2.update_score
      1  1c81				   I_F_src2.update_score_IMPORTED SET	1
   1098  1c81		       20 61 2a 	      jsr	F_src2.update_score
   1099  1c84				   _EL_17
   1100  1c84
   1101  1c84
   1102  1c84
   1103  1c84				   _EI_17
      0  1c84					      pbyte	1
      1  1c84		       a9 01		      lda	#1
      2  1c86					      IF	!FPUSH
      3  1c86		       48		      pha
      4  1c87					      ENDIF
      0  1c87					      F_cword_byte
      1  1c87		       a9 00		      lda	#$00
      2  1c89		       48		      pha
      0  1c8a					      plwordvar	V_src2.n
      1  1c8a					      IF	!FPULL
      2  1c8a		       68		      pla
      3  1c8b		       8d 6e 34 	      sta	V_src2.n+1
      4  1c8e		       68		      pla
      5  1c8f		       8d 6d 34 	      sta	V_src2.n
      6  1c92				  -	      ELSE
      7  1c92				  -	      sta	V_src2.n
      8  1c92				  -	      sty	V_src2.n+1
      9  1c92					      ENDIF
   1107  1c92				   _FOR_18
      0  1c92					      forword	18, V_src2.n, 5, "_void_", 1
      1  1c92
      2  1c92					      IF	1 == 1
      3  1c92		       a9 05		      lda	#<5
      4  1c94		       cd 6d 34 	      cmp	V_src2.n
      5  1c97		       a9 00		      lda	#>5
      6  1c99		       ed 6e 34 	      sbc	V_src2.n + 1
      7  1c9c				  -	      ELSE
      8  1c9c				  -	      lda	5
      9  1c9c				  -	      cmp	V_src2.n
     10  1c9c				  -	      lda	5 + 1
     11  1c9c				  -	      sbc	V_src2.n + 1
     12  1c9c					      ENDIF
     13  1c9c		       b0 03		      bcs	.enter
     14  1c9e		       4c ae 1c 	      jmp	_ENDFOR_18
     15  1ca1				   .enter
   1109  1ca1
   1110  1ca1
   1111  1ca1
   1112  1ca1				   _CO_18
      0  1ca1					      nextword	18, V_src2.n, "_void_"
      1  1ca1
      2  1ca1				  -	      IFCONST	"_void_"
      3  1ca1				  -
      4  1ca1				  -	      clc
      5  1ca1				  -	      lda	"_void_"
      6  1ca1				  -	      adc	V_src2.n
      7  1ca1				  -	      sta	V_src2.n
      8  1ca1				  -	      lda	"_void_" + 1
      9  1ca1				  -	      adc	V_src2.n + 1
     10  1ca1				  -	      sta	V_src2.n + 1
     11  1ca1				  -
     12  1ca1				  -	      bcs	_ENDFOR_18
     13  1ca1					      ELSE
     14  1ca1
     15  1ca1		       ee 6d 34 	      inc	V_src2.n
     16  1ca4		       d0 05		      bne	.skip
     17  1ca6		       ee 6e 34 	      inc	V_src2.n + 1
     18  1ca9
     19  1ca9		       f0 03		      beq	_ENDFOR_18
     20  1cab				   .skip
     21  1cab					      ENDIF
     22  1cab		       4c 92 1c 	      jmp	_FOR_18
   1114  1cae
   1115  1cae
   1116  1cae
   1117  1cae				   _ENDFOR_18
      0  1cae					      pbytevar	V_src2.t
      1  1cae		       ad 72 34 	      lda	V_src2.t
      2  1cb1					      IF	!FPUSH
      3  1cb1		       48		      pha
      4  1cb2					      ENDIF
   1119  1cb2				   FPUSH      SET	1
      0  1cb2					      pwordvar	V_src2.pos_man
      1  1cb2				  -	      IF	!FPUSH
      2  1cb2				  -	      lda	V_src2.pos_man
      3  1cb2				  -	      pha
      4  1cb2				  -	      lda	V_src2.pos_man+1
      5  1cb2				  -	      pha
      6  1cb2					      ELSE
      7  1cb2		       ad 50 34 	      lda	V_src2.pos_man
      8  1cb5		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1cb8					      ENDIF
   1121  1cb8				   FPULL      SET	1
   1122  1cb8				   FPUSH      SET	0
      0  1cb8					      poke
      1  1cb8				  -	      IF	!FPULL
      2  1cb8				  -	      pla
      3  1cb8				  -	      sta	.l + 2
      4  1cb8				  -	      pla
      5  1cb8				  -	      sta	.l + 1
      6  1cb8					      ELSE
      7  1cb8		       8d c0 1c 	      sta	.l + 1
      8  1cbb		       8c c1 1c 	      sty	.l + 2
      9  1cbe					      ENDIF
     10  1cbe		       68		      pla
     11  1cbf		       8d ff ff    .l	      sta	$ffff
   1124  1cbf				   FPULL      SET	0
      0  1cc2					      pbytevar	V_src2.t
      1  1cc2		       ad 72 34 	      lda	V_src2.t
      2  1cc5					      IF	!FPUSH
      3  1cc5		       48		      pha
      4  1cc6					      ENDIF
   1126  1cc6				   FPUSH      SET	1
      0  1cc6					      pbyte	56
      1  1cc6		       a9 38		      lda	#56
      2  1cc8				  -	      IF	!FPUSH
      3  1cc8				  -	      pha
      4  1cc8					      ENDIF
   1128  1cc8				   FPULL      SET	1
      0  1cc8					      subbyte
      1  1cc8				  -	      IF	!FPULL
      2  1cc8				  -	      pla
      3  1cc8					      ENDIF
      4  1cc8		       85 02		      sta	R0
      5  1cca		       68		      pla
      6  1ccb		       38		      sec
      7  1ccc		       e5 02		      sbc	R0
      8  1cce				  -	      IF	!FPUSH
      9  1cce				  -	      pha
     10  1cce					      ENDIF
   1130  1cce				   FPUSH      SET	0
      0  1cce					      pbytearrayfast	V_src2.d
      1  1cce				  -	      IF	!FPULL
      2  1cce				  -	      pla
      3  1cce					      ENDIF
      4  1cce		       aa		      tax
      5  1ccf		       bd 68 34 	      lda	V_src2.d,x
      6  1cd2					      IF	!FPUSH
      7  1cd2		       48		      pha
      8  1cd3					      ENDIF
   1132  1cd3				   FPULL      SET	0
      0  1cd3					      pwordvar	V_src2.pos_man
      1  1cd3					      IF	!FPUSH
      2  1cd3		       ad 50 34 	      lda	V_src2.pos_man
      3  1cd6		       48		      pha
      4  1cd7		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1cda		       48		      pha
      6  1cdb				  -	      ELSE
      7  1cdb				  -	      lda	V_src2.pos_man
      8  1cdb				  -	      ldy	V_src2.pos_man+1
      9  1cdb					      ENDIF
      0  1cdb					      F_cint_word
      0  1cdb					      pint	30720
      0  1cdb					      pword	30720
      1  1cdb					      IF	!FPUSH
      2  1cdb		       a9 00		      lda	#<30720
      3  1cdd		       48		      pha
      4  1cde		       a9 78		      lda	#>30720
      5  1ce0		       48		      pha
      6  1ce1				  -	      ELSE
      7  1ce1				  -	      lda	#<30720
      8  1ce1				  -	      ldy	#>30720
      9  1ce1					      ENDIF
      0  1ce1					      addint
      0  1ce1					      addword
      1  1ce1		       ba		      tsx
      2  1ce2		       bd 02 01 	      lda.wx	stack + 2
      3  1ce5		       18		      clc
      4  1ce6		       7d 04 01 	      adc.wx	stack + 4
      5  1ce9		       9d 04 01 	      sta.wx	stack + 4
      6  1cec		       68		      pla
      7  1ced		       7d 03 01 	      adc.wx	stack + 3
      8  1cf0		       9d 03 01 	      sta.wx	stack + 3
      9  1cf3		       68		      pla
      0  1cf4					      F_cword_int
      0  1cf4					      poke
      1  1cf4					      IF	!FPULL
      2  1cf4		       68		      pla
      3  1cf5		       8d ff 1c 	      sta	.l + 2
      4  1cf8		       68		      pla
      5  1cf9		       8d fe 1c 	      sta	.l + 1
      6  1cfc				  -	      ELSE
      7  1cfc				  -	      sta	.l + 1
      8  1cfc				  -	      sty	.l + 2
      9  1cfc					      ENDIF
     10  1cfc		       68		      pla
     11  1cfd		       8d ff ff    .l	      sta	$ffff
      0  1d00					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 22
      0  1d00					      pintvar_pint_addint	V_src2.pos_man, 22
      1  1d00		       ad 50 34 	      lda	V_src2.pos_man
      2  1d03		       18		      clc
      3  1d04		       69 16		      adc	#<22
      4  1d06					      IF	!FPUSH
      5  1d06		       48		      pha
      6  1d07				  -	      ELSE
      7  1d07				  -	      tax
      8  1d07					      ENDIF
      9  1d07		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  1d0a		       69 00		      adc	#>22
     11  1d0c					      IF	!FPUSH
     12  1d0c		       48		      pha
     13  1d0d				  -	      ELSE
     14  1d0d				  -	      tay
     15  1d0d				  -	      txa
     16  1d0d					      ENDIF
      0  1d0d					      pwordvar	V_src2.dir_man
      1  1d0d					      IF	!FPUSH
      2  1d0d		       ad 52 34 	      lda	V_src2.dir_man
      3  1d10		       48		      pha
      4  1d11		       ad 53 34 	      lda	V_src2.dir_man+1
      5  1d14		       48		      pha
      6  1d15				  -	      ELSE
      7  1d15				  -	      lda	V_src2.dir_man
      8  1d15				  -	      ldy	V_src2.dir_man+1
      9  1d15					      ENDIF
      0  1d15					      addword
      1  1d15		       ba		      tsx
      2  1d16		       bd 02 01 	      lda.wx	stack + 2
      3  1d19		       18		      clc
      4  1d1a		       7d 04 01 	      adc.wx	stack + 4
      5  1d1d		       9d 04 01 	      sta.wx	stack + 4
      6  1d20		       68		      pla
      7  1d21		       7d 03 01 	      adc.wx	stack + 3
      8  1d24		       9d 03 01 	      sta.wx	stack + 3
      9  1d27		       68		      pla
      0  1d28					      plwordvar	V_src2.pos_man
      1  1d28					      IF	!FPULL
      2  1d28		       68		      pla
      3  1d29		       8d 51 34 	      sta	V_src2.pos_man+1
      4  1d2c		       68		      pla
      5  1d2d		       8d 50 34 	      sta	V_src2.pos_man
      6  1d30				  -	      ELSE
      7  1d30				  -	      sta	V_src2.pos_man
      8  1d30				  -	      sty	V_src2.pos_man+1
      9  1d30					      ENDIF
   1143  1d30				   FPUSH      SET	1
      0  1d30					      pwordvar	V_src2.pos_man
      1  1d30				  -	      IF	!FPUSH
      2  1d30				  -	      lda	V_src2.pos_man
      3  1d30				  -	      pha
      4  1d30				  -	      lda	V_src2.pos_man+1
      5  1d30				  -	      pha
      6  1d30					      ELSE
      7  1d30		       ad 50 34 	      lda	V_src2.pos_man
      8  1d33		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1d36					      ENDIF
   1145  1d36				   FPULL      SET	1
      0  1d36					      F_peek_word
      1  1d36				  -	      IF	!FPULL
      2  1d36				  -	      pla
      3  1d36				  -	      sta	.l + 2
      4  1d36				  -	      pla
      5  1d36				  -	      sta	.l + 1
      6  1d36					      ELSE
      7  1d36		       8d 3d 1d 	      sta	.l + 1
      8  1d39		       8c 3e 1d 	      sty	.l + 2
      9  1d3c					      ENDIF
     10  1d3c		       ad ff ff    .l	      lda	$FFFF
     11  1d3f				  -	      IF	!FPUSH
     12  1d3f				  -	      pha
     13  1d3f					      ENDIF
   1147  1d3f				   FPUSH      SET	0
      0  1d3f					      plbytevar	V_src2.t
      1  1d3f				  -	      IF	!FPULL
      2  1d3f				  -	      pla
      3  1d3f					      ENDIF
      4  1d3f		       8d 72 34 	      sta	V_src2.t
   1149  1d3f				   FPULL      SET	0
      0  1d42					      pbyte	58
      1  1d42		       a9 3a		      lda	#58
      2  1d44					      IF	!FPUSH
      3  1d44		       48		      pha
      4  1d45					      ENDIF
   1151  1d45				   FPUSH      SET	1
      0  1d45					      pwordvar	V_src2.pos_man
      1  1d45				  -	      IF	!FPUSH
      2  1d45				  -	      lda	V_src2.pos_man
      3  1d45				  -	      pha
      4  1d45				  -	      lda	V_src2.pos_man+1
      5  1d45				  -	      pha
      6  1d45					      ELSE
      7  1d45		       ad 50 34 	      lda	V_src2.pos_man
      8  1d48		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1d4b					      ENDIF
   1153  1d4b				   FPULL      SET	1
   1154  1d4b				   FPUSH      SET	0
      0  1d4b					      poke
      1  1d4b				  -	      IF	!FPULL
      2  1d4b				  -	      pla
      3  1d4b				  -	      sta	.l + 2
      4  1d4b				  -	      pla
      5  1d4b				  -	      sta	.l + 1
      6  1d4b					      ELSE
      7  1d4b		       8d 53 1d 	      sta	.l + 1
      8  1d4e		       8c 54 1d 	      sty	.l + 2
      9  1d51					      ENDIF
     10  1d51		       68		      pla
     11  1d52		       8d ff ff    .l	      sta	$ffff
   1156  1d52				   FPULL      SET	0
   1157  1d52				   FPUSH      SET	1
      0  1d55					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_man, 22
      0  1d55					      pintvar_pint_addint	V_src2.pos_man, 22
      1  1d55		       ad 50 34 	      lda	V_src2.pos_man
      2  1d58		       18		      clc
      3  1d59		       69 16		      adc	#<22
      4  1d5b				  -	      IF	!FPUSH
      5  1d5b				  -	      pha
      6  1d5b					      ELSE
      7  1d5b		       aa		      tax
      8  1d5c					      ENDIF
      9  1d5c		       ad 51 34 	      lda	V_src2.pos_man + 1
     10  1d5f		       69 00		      adc	#>22
     11  1d61				  -	      IF	!FPUSH
     12  1d61				  -	      pha
     13  1d61					      ELSE
     14  1d61		       a8		      tay
     15  1d62		       8a		      txa
     16  1d63					      ENDIF
   1159  1d63				   FPULL      SET	1
   1160  1d63				   FPUSH      SET	0
      0  1d63					      F_peek_word
      1  1d63				  -	      IF	!FPULL
      2  1d63				  -	      pla
      3  1d63				  -	      sta	.l + 2
      4  1d63				  -	      pla
      5  1d63				  -	      sta	.l + 1
      6  1d63					      ELSE
      7  1d63		       8d 6a 1d 	      sta	.l + 1
      8  1d66		       8c 6b 1d 	      sty	.l + 2
      9  1d69					      ENDIF
     10  1d69		       ad ff ff    .l	      lda	$FFFF
     11  1d6c					      IF	!FPUSH
     12  1d6c		       48		      pha
     13  1d6d					      ENDIF
   1162  1d6d				   FPULL      SET	0
   1163  1d6d				   FPUSH      SET	1
      0  1d6d					      pbyte	61
      1  1d6d		       a9 3d		      lda	#61
      2  1d6f				  -	      IF	!FPUSH
      3  1d6f				  -	      pha
      4  1d6f					      ENDIF
   1165  1d6f				   FPULL      SET	1
      0  1d6f					      cmpbytegt
      1  1d6f				  -	      IF	!FPULL
      2  1d6f				  -	      pla
      3  1d6f					      ENDIF
      4  1d6f		       85 02		      sta	R0
      5  1d71		       68		      pla
      6  1d72		       c5 02		      cmp	R0
      7  1d74		       90 06		      bcc	.phf
      8  1d76		       f0 04		      beq	.phf
      0  1d78					      ptrue
      1  1d78		       a9 ff		      lda	#$FF
      2  1d7a				  -	      IF	!FPUSH
      3  1d7a				  -	      pha
      4  1d7a					      ENDIF
     10  1d7a		       d0 02		      bne	.q
      0  1d7c				   .phf       pfalse
      1  1d7c		       a9 00		      lda	#$00
      2  1d7e				  -	      IF	!FPUSH
      3  1d7e				  -	      pha
      4  1d7e					      ENDIF
     12  1d7e				   .q
   1167  1d7e				   FPUSH      SET	0
      0  1d7e					      cond_stmt	_EI_65544, 0
      1  1d7e				  -	      IF	!FPULL
      2  1d7e				  -	      pla
      3  1d7e					      ENDIF
      4  1d7e		       d0 03		      bne	* + 5
      5  1d80				  -	      IF	0 > 0 && 0 < $10000
      6  1d80				  -	      jmp	0
      7  1d80					      ELSE
      8  1d80		       4c 89 1d 	      jmp	_EI_65544
      9  1d83					      ENDIF
   1169  1d83				   FPULL      SET	0
   1170  1d83				   FPUSH      SET	1
      0  1d83					      pbyte	2
      1  1d83		       a9 02		      lda	#2
      2  1d85				  -	      IF	!FPUSH
      3  1d85				  -	      pha
      4  1d85					      ENDIF
   1172  1d85				   FPULL      SET	1
   1173  1d85				   FPUSH      SET	0
      0  1d85					      plbytevar	V_src2.playermove_.playermove
      1  1d85				  -	      IF	!FPULL
      2  1d85				  -	      pla
      3  1d85					      ENDIF
      4  1d85		       8d 4e 34 	      sta	V_src2.playermove_.playermove
   1175  1d88		       60		      rts
   1176  1d89				   _EI_65544
   1177  1d89				   FPULL      SET	0
      0  1d89					      pbyte	0
      1  1d89		       a9 00		      lda	#0
      2  1d8b					      IF	!FPUSH
      3  1d8b		       48		      pha
      4  1d8c					      ENDIF
      0  1d8c					      pwordvar	V_src2.pos_man
      1  1d8c					      IF	!FPUSH
      2  1d8c		       ad 50 34 	      lda	V_src2.pos_man
      3  1d8f		       48		      pha
      4  1d90		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1d93		       48		      pha
      6  1d94				  -	      ELSE
      7  1d94				  -	      lda	V_src2.pos_man
      8  1d94				  -	      ldy	V_src2.pos_man+1
      9  1d94					      ENDIF
      0  1d94					      F_cint_word
      0  1d94					      pint	30720
      0  1d94					      pword	30720
      1  1d94					      IF	!FPUSH
      2  1d94		       a9 00		      lda	#<30720
      3  1d96		       48		      pha
      4  1d97		       a9 78		      lda	#>30720
      5  1d99		       48		      pha
      6  1d9a				  -	      ELSE
      7  1d9a				  -	      lda	#<30720
      8  1d9a				  -	      ldy	#>30720
      9  1d9a					      ENDIF
      0  1d9a					      addint
      0  1d9a					      addword
      1  1d9a		       ba		      tsx
      2  1d9b		       bd 02 01 	      lda.wx	stack + 2
      3  1d9e		       18		      clc
      4  1d9f		       7d 04 01 	      adc.wx	stack + 4
      5  1da2		       9d 04 01 	      sta.wx	stack + 4
      6  1da5		       68		      pla
      7  1da6		       7d 03 01 	      adc.wx	stack + 3
      8  1da9		       9d 03 01 	      sta.wx	stack + 3
      9  1dac		       68		      pla
      0  1dad					      F_cword_int
      0  1dad					      poke
      1  1dad					      IF	!FPULL
      2  1dad		       68		      pla
      3  1dae		       8d b8 1d 	      sta	.l + 2
      4  1db1		       68		      pla
      5  1db2		       8d b7 1d 	      sta	.l + 1
      6  1db5				  -	      ELSE
      7  1db5				  -	      sta	.l + 1
      8  1db5				  -	      sty	.l + 2
      9  1db5					      ENDIF
     10  1db5		       68		      pla
     11  1db6		       8d ff ff    .l	      sta	$ffff
   1185  1db6				   FPUSH      SET	1
      0  1db9					      pbyte	0
      1  1db9		       a9 00		      lda	#0
      2  1dbb				  -	      IF	!FPUSH
      3  1dbb				  -	      pha
      4  1dbb					      ENDIF
   1187  1dbb				   FPULL      SET	1
   1188  1dbb				   FPUSH      SET	0
      0  1dbb					      poke_constaddr	$900C
      1  1dbb				  -	      IF	!FPULL
      2  1dbb				  -	      pla
      3  1dbb					      ENDIF
      4  1dbb		       8d 0c 90 	      sta	$900C
   1190  1dbe		       4c 20 1e 	      jmp	L_src2.playermove_.41
   1191  1dc1				   L_src2.playermove_.40
   1192  1dc1				   FPULL      SET	0
   1193  1dc1				   FPUSH      SET	1
      0  1dc1					      pbyte	200
      1  1dc1		       a9 c8		      lda	#200
      2  1dc3				  -	      IF	!FPUSH
      3  1dc3				  -	      pha
      4  1dc3					      ENDIF
   1195  1dc3				   FPULL      SET	1
   1196  1dc3				   FPUSH      SET	0
      0  1dc3					      poke_constaddr	$900C
      1  1dc3				  -	      IF	!FPULL
      2  1dc3				  -	      pla
      3  1dc3					      ENDIF
      4  1dc3		       8d 0c 90 	      sta	$900C
   1198  1dc3				   FPULL      SET	0
   1199  1dc3				   FPUSH      SET	1
      0  1dc6					      pbyte	0
      1  1dc6		       a9 00		      lda	#0
      2  1dc8				  -	      IF	!FPUSH
      3  1dc8				  -	      pha
      4  1dc8					      ENDIF
   1201  1dc8				   FPULL      SET	1
   1202  1dc8				   FPUSH      SET	0
      0  1dc8					      poke_constaddr	$900C
      1  1dc8				  -	      IF	!FPULL
      2  1dc8				  -	      pla
      3  1dc8					      ENDIF
      4  1dc8		       8d 0c 90 	      sta	$900C
   1204  1dc8				   FPULL      SET	0
   1205  1dc8				   FPUSH      SET	1
      0  1dcb					      pwordvar	V_src2.pos_man
      1  1dcb				  -	      IF	!FPUSH
      2  1dcb				  -	      lda	V_src2.pos_man
      3  1dcb				  -	      pha
      4  1dcb				  -	      lda	V_src2.pos_man+1
      5  1dcb				  -	      pha
      6  1dcb					      ELSE
      7  1dcb		       ad 50 34 	      lda	V_src2.pos_man
      8  1dce		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1dd1					      ENDIF
   1207  1dd1				   FPULL      SET	1
      0  1dd1					      F_peek_word
      1  1dd1				  -	      IF	!FPULL
      2  1dd1				  -	      pla
      3  1dd1				  -	      sta	.l + 2
      4  1dd1				  -	      pla
      5  1dd1				  -	      sta	.l + 1
      6  1dd1					      ELSE
      7  1dd1		       8d d8 1d 	      sta	.l + 1
      8  1dd4		       8c d9 1d 	      sty	.l + 2
      9  1dd7					      ENDIF
     10  1dd7		       ad ff ff    .l	      lda	$FFFF
     11  1dda				  -	      IF	!FPUSH
     12  1dda				  -	      pha
     13  1dda					      ENDIF
   1209  1dda				   FPUSH      SET	0
      0  1dda					      plbytevar	V_src2.t
      1  1dda				  -	      IF	!FPULL
      2  1dda				  -	      pla
      3  1dda					      ENDIF
      4  1dda		       8d 72 34 	      sta	V_src2.t
   1211  1dda				   FPULL      SET	0
      0  1ddd					      pbyte	58
      1  1ddd		       a9 3a		      lda	#58
      2  1ddf					      IF	!FPUSH
      3  1ddf		       48		      pha
      4  1de0					      ENDIF
   1213  1de0				   FPUSH      SET	1
      0  1de0					      pwordvar	V_src2.pos_man
      1  1de0				  -	      IF	!FPUSH
      2  1de0				  -	      lda	V_src2.pos_man
      3  1de0				  -	      pha
      4  1de0				  -	      lda	V_src2.pos_man+1
      5  1de0				  -	      pha
      6  1de0					      ELSE
      7  1de0		       ad 50 34 	      lda	V_src2.pos_man
      8  1de3		       ac 51 34 	      ldy	V_src2.pos_man+1
      9  1de6					      ENDIF
   1215  1de6				   FPULL      SET	1
   1216  1de6				   FPUSH      SET	0
      0  1de6					      poke
      1  1de6				  -	      IF	!FPULL
      2  1de6				  -	      pla
      3  1de6				  -	      sta	.l + 2
      4  1de6				  -	      pla
      5  1de6				  -	      sta	.l + 1
      6  1de6					      ELSE
      7  1de6		       8d ee 1d 	      sta	.l + 1
      8  1de9		       8c ef 1d 	      sty	.l + 2
      9  1dec					      ENDIF
     10  1dec		       68		      pla
     11  1ded		       8d ff ff    .l	      sta	$ffff
   1218  1ded				   FPULL      SET	0
      0  1df0					      pbyte	0
      1  1df0		       a9 00		      lda	#0
      2  1df2					      IF	!FPUSH
      3  1df2		       48		      pha
      4  1df3					      ENDIF
      0  1df3					      pwordvar	V_src2.pos_man
      1  1df3					      IF	!FPUSH
      2  1df3		       ad 50 34 	      lda	V_src2.pos_man
      3  1df6		       48		      pha
      4  1df7		       ad 51 34 	      lda	V_src2.pos_man+1
      5  1dfa		       48		      pha
      6  1dfb				  -	      ELSE
      7  1dfb				  -	      lda	V_src2.pos_man
      8  1dfb				  -	      ldy	V_src2.pos_man+1
      9  1dfb					      ENDIF
      0  1dfb					      F_cint_word
      0  1dfb					      pint	30720
      0  1dfb					      pword	30720
      1  1dfb					      IF	!FPUSH
      2  1dfb		       a9 00		      lda	#<30720
      3  1dfd		       48		      pha
      4  1dfe		       a9 78		      lda	#>30720
      5  1e00		       48		      pha
      6  1e01				  -	      ELSE
      7  1e01				  -	      lda	#<30720
      8  1e01				  -	      ldy	#>30720
      9  1e01					      ENDIF
      0  1e01					      addint
      0  1e01					      addword
      1  1e01		       ba		      tsx
      2  1e02		       bd 02 01 	      lda.wx	stack + 2
      3  1e05		       18		      clc
      4  1e06		       7d 04 01 	      adc.wx	stack + 4
      5  1e09		       9d 04 01 	      sta.wx	stack + 4
      6  1e0c		       68		      pla
      7  1e0d		       7d 03 01 	      adc.wx	stack + 3
      8  1e10		       9d 03 01 	      sta.wx	stack + 3
      9  1e13		       68		      pla
      0  1e14					      F_cword_int
      0  1e14					      poke
      1  1e14					      IF	!FPULL
      2  1e14		       68		      pla
      3  1e15		       8d 1f 1e 	      sta	.l + 2
      4  1e18		       68		      pla
      5  1e19		       8d 1e 1e 	      sta	.l + 1
      6  1e1c				  -	      ELSE
      7  1e1c				  -	      sta	.l + 1
      8  1e1c				  -	      sty	.l + 2
      9  1e1c					      ENDIF
     10  1e1c		       68		      pla
     11  1e1d		       8d ff ff    .l	      sta	$ffff
   1226  1e20				   L_src2.playermove_.41
   1227  1e20
   1228  1e20				   FPUSH      SET	1
      0  1e20					      pbytevar_pbyte_cmpbyteeq	V_src2.t, 61
      1  1e20		       ad 72 34 	      lda	V_src2.t
      2  1e23		       c9 3d		      cmp	#61
      3  1e25		       f0 04		      beq	.true
      0  1e27					      pfalse
      1  1e27		       a9 00		      lda	#$00
      2  1e29				  -	      IF	!FPUSH
      3  1e29				  -	      pha
      4  1e29					      ENDIF
      5  1e29		       f0 02		      beq	.end
      6  1e2b				   .true
      0  1e2b					      ptrue
      1  1e2b		       a9 ff		      lda	#$FF
      2  1e2d				  -	      IF	!FPUSH
      3  1e2d				  -	      pha
      4  1e2d					      ENDIF
      8  1e2d				   .end
   1230  1e2d				   FPULL      SET	1
   1231  1e2d				   FPUSH      SET	0
      0  1e2d					      cond_stmt	_EI_19, _EL_19
      1  1e2d				  -	      IF	!FPULL
      2  1e2d				  -	      pla
      3  1e2d					      ENDIF
      4  1e2d		       d0 03		      bne	* + 5
      5  1e2f					      IF	_EL_19 > 0 && _EL_19 < $10000
      6  1e2f		       4c 69 1e 	      jmp	_EL_19
      7  1e32				  -	      ELSE
      8  1e32				  -	      jmp	_EI_19
      9  1e32					      ENDIF
   1233  1e32
   1234  1e32				   FPULL      SET	0
   1235  1e32				   FPUSH      SET	1
      0  1e32					      pwordvar_pbyte_F_cword_byte_addword	V_src2.score, 150
      0  1e32					      pintvar_pint_addint	V_src2.score, 150
      1  1e32		       ad 59 34 	      lda	V_src2.score
      2  1e35		       18		      clc
      3  1e36		       69 96		      adc	#<150
      4  1e38				  -	      IF	!FPUSH
      5  1e38				  -	      pha
      6  1e38					      ELSE
      7  1e38		       aa		      tax
      8  1e39					      ENDIF
      9  1e39		       ad 5a 34 	      lda	V_src2.score + 1
     10  1e3c		       69 00		      adc	#>150
     11  1e3e				  -	      IF	!FPUSH
     12  1e3e				  -	      pha
     13  1e3e					      ELSE
     14  1e3e		       a8		      tay
     15  1e3f		       8a		      txa
     16  1e40					      ENDIF
   1237  1e40				   FPULL      SET	1
   1238  1e40				   FPUSH      SET	0
      0  1e40					      plwordvar	V_src2.score
      1  1e40				  -	      IF	!FPULL
      2  1e40				  -	      pla
      3  1e40				  -	      sta	V_src2.score+1
      4  1e40				  -	      pla
      5  1e40				  -	      sta	V_src2.score
      6  1e40					      ELSE
      7  1e40		       8d 59 34 	      sta	V_src2.score
      8  1e43		       8c 5a 34 	      sty	V_src2.score+1
      9  1e46					      ENDIF
      0  1e46					      import	I_F_src2.update_score
      1  1e46				   I_F_src2.update_score_IMPORTED SET	1
   1241  1e46		       20 61 2a 	      jsr	F_src2.update_score
   1242  1e49
      0  1e49					      pbytevar_pbyte_addbyte_plbytevar	V_src2.nbags, 1, V_src2.nbags
      1  1e49					      IF	V_src2.nbags == V_src2.nbags && 1 == 1
      2  1e49		       ee 5b 34 	      inc	V_src2.nbags
      3  1e4c				  -	      ELSE
      4  1e4c				  -	      lda	V_src2.nbags
      5  1e4c				  -	      clc
      6  1e4c				  -	      adc	#1
      7  1e4c				  -	      sta	V_src2.nbags
      8  1e4c					      ENDIF
   1244  1e4c				   FPULL      SET	0
   1245  1e4c				   FPUSH      SET	1
      0  1e4c					      pbyte	62
      1  1e4c		       a9 3e		      lda	#62
      2  1e4e				  -	      IF	!FPUSH
      3  1e4e				  -	      pha
      4  1e4e					      ENDIF
   1247  1e4e				   FPULL      SET	1
   1248  1e4e				   FPUSH      SET	0
      0  1e4e					      plbytevar	V_src2.t
      1  1e4e				  -	      IF	!FPULL
      2  1e4e				  -	      pla
      3  1e4e					      ENDIF
      4  1e4e		       8d 72 34 	      sta	V_src2.t
   1250  1e4e				   FPULL      SET	0
   1251  1e4e				   FPUSH      SET	1
      0  1e51					      pbytevar_pbyte_cmpbyteeq	V_src2.nbags, 16
      1  1e51		       ad 5b 34 	      lda	V_src2.nbags
      2  1e54		       c9 10		      cmp	#16
      3  1e56		       f0 04		      beq	.true
      0  1e58					      pfalse
      1  1e58		       a9 00		      lda	#$00
      2  1e5a				  -	      IF	!FPUSH
      3  1e5a				  -	      pha
      4  1e5a					      ENDIF
      5  1e5a		       f0 02		      beq	.end
      6  1e5c				   .true
      0  1e5c					      ptrue
      1  1e5c		       a9 ff		      lda	#$FF
      2  1e5e				  -	      IF	!FPUSH
      3  1e5e				  -	      pha
      4  1e5e					      ENDIF
      8  1e5e				   .end
   1253  1e5e				   FPULL      SET	1
   1254  1e5e				   FPUSH      SET	0
      0  1e5e					      cond_stmt	_EI_65545, 0
      1  1e5e				  -	      IF	!FPULL
      2  1e5e				  -	      pla
      3  1e5e					      ENDIF
      4  1e5e		       d0 03		      bne	* + 5
      5  1e60				  -	      IF	0 > 0 && 0 < $10000
      6  1e60				  -	      jmp	0
      7  1e60					      ELSE
      8  1e60		       4c 69 1e 	      jmp	_EI_65545
      9  1e63					      ENDIF
   1256  1e63				   FPULL      SET	0
   1257  1e63				   FPUSH      SET	1
      0  1e63					      pbyte	1
      1  1e63		       a9 01		      lda	#1
      2  1e65				  -	      IF	!FPUSH
      3  1e65				  -	      pha
      4  1e65					      ENDIF
   1259  1e65				   FPULL      SET	1
   1260  1e65				   FPUSH      SET	0
      0  1e65					      plbytevar	V_src2.playermove_.playermove
      1  1e65				  -	      IF	!FPULL
      2  1e65				  -	      pla
      3  1e65					      ENDIF
      4  1e65		       8d 4e 34 	      sta	V_src2.playermove_.playermove
   1262  1e68		       60		      rts
   1263  1e69				   _EI_65545
   1264  1e69
   1265  1e69
   1266  1e69
   1267  1e69				   _EL_19
   1268  1e69
   1269  1e69
   1270  1e69
   1271  1e69				   _EI_19
   1272  1e69
   1273  1e69
   1274  1e69
   1275  1e69				   L_src2.playermove_.42
   1276  1e69
   1277  1e69				   FPULL      SET	0
   1278  1e69				   FPUSH      SET	1
      0  1e69					      pbytevar_pbyte_cmpbyteeq	V_src2.t, 60
      1  1e69		       ad 72 34 	      lda	V_src2.t
      2  1e6c		       c9 3c		      cmp	#60
      3  1e6e		       f0 04		      beq	.true
      0  1e70					      pfalse
      1  1e70		       a9 00		      lda	#$00
      2  1e72				  -	      IF	!FPUSH
      3  1e72				  -	      pha
      4  1e72					      ENDIF
      5  1e72		       f0 02		      beq	.end
      6  1e74				   .true
      0  1e74					      ptrue
      1  1e74		       a9 ff		      lda	#$FF
      2  1e76				  -	      IF	!FPUSH
      3  1e76				  -	      pha
      4  1e76					      ENDIF
      8  1e76				   .end
   1280  1e76				   FPULL      SET	1
   1281  1e76				   FPUSH      SET	0
      0  1e76					      cond_stmt	_EI_65546, 0
      1  1e76				  -	      IF	!FPULL
      2  1e76				  -	      pla
      3  1e76					      ENDIF
      4  1e76		       d0 03		      bne	* + 5
      5  1e78				  -	      IF	0 > 0 && 0 < $10000
      6  1e78				  -	      jmp	0
      7  1e78					      ELSE
      8  1e78		       4c 81 1e 	      jmp	_EI_65546
      9  1e7b					      ENDIF
   1283  1e7b				   FPULL      SET	0
   1284  1e7b				   FPUSH      SET	1
      0  1e7b					      pbyte	2
      1  1e7b		       a9 02		      lda	#2
      2  1e7d				  -	      IF	!FPUSH
      3  1e7d				  -	      pha
      4  1e7d					      ENDIF
   1286  1e7d				   FPULL      SET	1
   1287  1e7d				   FPUSH      SET	0
      0  1e7d					      plbytevar	V_src2.playermove_.playermove
      1  1e7d				  -	      IF	!FPULL
      2  1e7d				  -	      pla
      3  1e7d					      ENDIF
      4  1e7d		       8d 4e 34 	      sta	V_src2.playermove_.playermove
   1289  1e80		       60		      rts
   1290  1e81				   _EI_65546
   1291  1e81
   1292  1e81
   1293  1e81
   1294  1e81				   L_src2.playermove_.43
      0  1e81					      import	I_F_src2.check_bonus_vita
      1  1e81				   I_F_src2.check_bonus_vita_IMPORTED SET	1
   1296  1e81		       20 19 29 	      jsr	F_src2.check_bonus_vita
   1297  1e81				   FPULL      SET	0
   1298  1e81				   FPUSH      SET	1
      0  1e84					      pbyte	0
      1  1e84		       a9 00		      lda	#0
      2  1e86				  -	      IF	!FPUSH
      3  1e86				  -	      pha
      4  1e86					      ENDIF
   1300  1e86				   FPULL      SET	1
   1301  1e86				   FPUSH      SET	0
      0  1e86					      plbytevar	V_src2.playermove_.playermove
      1  1e86				  -	      IF	!FPULL
      2  1e86				  -	      pla
      3  1e86					      ENDIF
      4  1e86		       8d 4e 34 	      sta	V_src2.playermove_.playermove
   1303  1e89		       60		      rts
   1304  1e8a		       60		      rts
   1305  1e8b					      ENDIF
   1306  1e8b
   1307  1e8b					      IFCONST	I_F_src2.barrel_move_IMPORTED
   1308  1e8b				   F_src2.barrel_move SUBROUTINE
   1309  1e8b				   FPULL      SET	0
      0  1e8b					      pbytevar	V_src2.w
      1  1e8b		       ad 6f 34 	      lda	V_src2.w
      2  1e8e					      IF	!FPUSH
      3  1e8e		       48		      pha
      4  1e8f					      ENDIF
   1311  1e8f				   FPUSH      SET	1
      0  1e8f					      pwordvar	V_src2.pos_barrel
      1  1e8f				  -	      IF	!FPUSH
      2  1e8f				  -	      lda	V_src2.pos_barrel
      3  1e8f				  -	      pha
      4  1e8f				  -	      lda	V_src2.pos_barrel+1
      5  1e8f				  -	      pha
      6  1e8f					      ELSE
      7  1e8f		       ad 54 34 	      lda	V_src2.pos_barrel
      8  1e92		       ac 55 34 	      ldy	V_src2.pos_barrel+1
      9  1e95					      ENDIF
   1313  1e95				   FPULL      SET	1
   1314  1e95				   FPUSH      SET	0
      0  1e95					      poke
      1  1e95				  -	      IF	!FPULL
      2  1e95				  -	      pla
      3  1e95				  -	      sta	.l + 2
      4  1e95				  -	      pla
      5  1e95				  -	      sta	.l + 1
      6  1e95					      ELSE
      7  1e95		       8d 9d 1e 	      sta	.l + 1
      8  1e98		       8c 9e 1e 	      sty	.l + 2
      9  1e9b					      ENDIF
     10  1e9b		       68		      pla
     11  1e9c		       8d ff ff    .l	      sta	$ffff
   1316  1e9c				   FPULL      SET	0
      0  1e9f					      pbytevar	V_src2.w
      1  1e9f		       ad 6f 34 	      lda	V_src2.w
      2  1ea2					      IF	!FPUSH
      3  1ea2		       48		      pha
      4  1ea3					      ENDIF
   1318  1ea3				   FPUSH      SET	1
      0  1ea3					      pbyte	56
      1  1ea3		       a9 38		      lda	#56
      2  1ea5				  -	      IF	!FPUSH
      3  1ea5				  -	      pha
      4  1ea5					      ENDIF
   1320  1ea5				   FPULL      SET	1
      0  1ea5					      subbyte
      1  1ea5				  -	      IF	!FPULL
      2  1ea5				  -	      pla
      3  1ea5					      ENDIF
      4  1ea5		       85 02		      sta	R0
      5  1ea7		       68		      pla
      6  1ea8		       38		      sec
      7  1ea9		       e5 02		      sbc	R0
      8  1eab				  -	      IF	!FPUSH
      9  1eab				  -	      pha
     10  1eab					      ENDIF
   1322  1eab				   FPUSH      SET	0
      0  1eab					      pbytearrayfast	V_src2.d
      1  1eab				  -	      IF	!FPULL
      2  1eab				  -	      pla
      3  1eab					      ENDIF
      4  1eab		       aa		      tax
      5  1eac		       bd 68 34 	      lda	V_src2.d,x
      6  1eaf					      IF	!FPUSH
      7  1eaf		       48		      pha
      8  1eb0					      ENDIF
   1324  1eb0				   FPULL      SET	0
      0  1eb0					      pwordvar	V_src2.pos_barrel
      1  1eb0					      IF	!FPUSH
      2  1eb0		       ad 54 34 	      lda	V_src2.pos_barrel
      3  1eb3		       48		      pha
      4  1eb4		       ad 55 34 	      lda	V_src2.pos_barrel+1
      5  1eb7		       48		      pha
      6  1eb8				  -	      ELSE
      7  1eb8				  -	      lda	V_src2.pos_barrel
      8  1eb8				  -	      ldy	V_src2.pos_barrel+1
      9  1eb8					      ENDIF
      0  1eb8					      F_cint_word
      0  1eb8					      pint	30720
      0  1eb8					      pword	30720
      1  1eb8					      IF	!FPUSH
      2  1eb8		       a9 00		      lda	#<30720
      3  1eba		       48		      pha
      4  1ebb		       a9 78		      lda	#>30720
      5  1ebd		       48		      pha
      6  1ebe				  -	      ELSE
      7  1ebe				  -	      lda	#<30720
      8  1ebe				  -	      ldy	#>30720
      9  1ebe					      ENDIF
      0  1ebe					      addint
      0  1ebe					      addword
      1  1ebe		       ba		      tsx
      2  1ebf		       bd 02 01 	      lda.wx	stack + 2
      3  1ec2		       18		      clc
      4  1ec3		       7d 04 01 	      adc.wx	stack + 4
      5  1ec6		       9d 04 01 	      sta.wx	stack + 4
      6  1ec9		       68		      pla
      7  1eca		       7d 03 01 	      adc.wx	stack + 3
      8  1ecd		       9d 03 01 	      sta.wx	stack + 3
      9  1ed0		       68		      pla
      0  1ed1					      F_cword_int
      0  1ed1					      poke
      1  1ed1					      IF	!FPULL
      2  1ed1		       68		      pla
      3  1ed2		       8d dc 1e 	      sta	.l + 2
      4  1ed5		       68		      pla
      5  1ed6		       8d db 1e 	      sta	.l + 1
      6  1ed9				  -	      ELSE
      7  1ed9				  -	      sta	.l + 1
      8  1ed9				  -	      sty	.l + 2
      9  1ed9					      ENDIF
     10  1ed9		       68		      pla
     11  1eda		       8d ff ff    .l	      sta	$ffff
      0  1edd					      pwordvar	V_src2.pos_barrel
      1  1edd					      IF	!FPUSH
      2  1edd		       ad 54 34 	      lda	V_src2.pos_barrel
      3  1ee0		       48		      pha
      4  1ee1		       ad 55 34 	      lda	V_src2.pos_barrel+1
      5  1ee4		       48		      pha
      6  1ee5				  -	      ELSE
      7  1ee5				  -	      lda	V_src2.pos_barrel
      8  1ee5				  -	      ldy	V_src2.pos_barrel+1
      9  1ee5					      ENDIF
      0  1ee5					      F_cint_word
      0  1ee5					      pintvar	V_src2.dir_barrel
      0  1ee5					      pwordvar	V_src2.dir_barrel
      1  1ee5					      IF	!FPUSH
      2  1ee5		       ad 56 34 	      lda	V_src2.dir_barrel
      3  1ee8		       48		      pha
      4  1ee9		       ad 57 34 	      lda	V_src2.dir_barrel+1
      5  1eec		       48		      pha
      6  1eed				  -	      ELSE
      7  1eed				  -	      lda	V_src2.dir_barrel
      8  1eed				  -	      ldy	V_src2.dir_barrel+1
      9  1eed					      ENDIF
      0  1eed					      addint
      0  1eed					      addword
      1  1eed		       ba		      tsx
      2  1eee		       bd 02 01 	      lda.wx	stack + 2
      3  1ef1		       18		      clc
      4  1ef2		       7d 04 01 	      adc.wx	stack + 4
      5  1ef5		       9d 04 01 	      sta.wx	stack + 4
      6  1ef8		       68		      pla
      7  1ef9		       7d 03 01 	      adc.wx	stack + 3
      8  1efc		       9d 03 01 	      sta.wx	stack + 3
      9  1eff		       68		      pla
      0  1f00					      F_cword_int
      0  1f00					      plwordvar	V_src2.pos_barrel
      1  1f00					      IF	!FPULL
      2  1f00		       68		      pla
      3  1f01		       8d 55 34 	      sta	V_src2.pos_barrel+1
      4  1f04		       68		      pla
      5  1f05		       8d 54 34 	      sta	V_src2.pos_barrel
      6  1f08				  -	      ELSE
      7  1f08				  -	      sta	V_src2.pos_barrel
      8  1f08				  -	      sty	V_src2.pos_barrel+1
      9  1f08					      ENDIF
   1337  1f08				   FPUSH      SET	1
      0  1f08					      pwordvar	V_src2.pos_barrel
      1  1f08				  -	      IF	!FPUSH
      2  1f08				  -	      lda	V_src2.pos_barrel
      3  1f08				  -	      pha
      4  1f08				  -	      lda	V_src2.pos_barrel+1
      5  1f08				  -	      pha
      6  1f08					      ELSE
      7  1f08		       ad 54 34 	      lda	V_src2.pos_barrel
      8  1f0b		       ac 55 34 	      ldy	V_src2.pos_barrel+1
      9  1f0e					      ENDIF
   1339  1f0e				   FPULL      SET	1
      0  1f0e					      F_peek_word
      1  1f0e				  -	      IF	!FPULL
      2  1f0e				  -	      pla
      3  1f0e				  -	      sta	.l + 2
      4  1f0e				  -	      pla
      5  1f0e				  -	      sta	.l + 1
      6  1f0e					      ELSE
      7  1f0e		       8d 15 1f 	      sta	.l + 1
      8  1f11		       8c 16 1f 	      sty	.l + 2
      9  1f14					      ENDIF
     10  1f14		       ad ff ff    .l	      lda	$FFFF
     11  1f17				  -	      IF	!FPUSH
     12  1f17				  -	      pha
     13  1f17					      ENDIF
   1341  1f17				   FPUSH      SET	0
      0  1f17					      plbytevar	V_src2.w
      1  1f17				  -	      IF	!FPULL
      2  1f17				  -	      pla
      3  1f17					      ENDIF
      4  1f17		       8d 6f 34 	      sta	V_src2.w
   1343  1f17				   FPULL      SET	0
      0  1f1a					      pbyte	60
      1  1f1a		       a9 3c		      lda	#60
      2  1f1c					      IF	!FPUSH
      3  1f1c		       48		      pha
      4  1f1d					      ENDIF
   1345  1f1d				   FPUSH      SET	1
      0  1f1d					      pwordvar	V_src2.pos_barrel
      1  1f1d				  -	      IF	!FPUSH
      2  1f1d				  -	      lda	V_src2.pos_barrel
      3  1f1d				  -	      pha
      4  1f1d				  -	      lda	V_src2.pos_barrel+1
      5  1f1d				  -	      pha
      6  1f1d					      ELSE
      7  1f1d		       ad 54 34 	      lda	V_src2.pos_barrel
      8  1f20		       ac 55 34 	      ldy	V_src2.pos_barrel+1
      9  1f23					      ENDIF
   1347  1f23				   FPULL      SET	1
   1348  1f23				   FPUSH      SET	0
      0  1f23					      poke
      1  1f23				  -	      IF	!FPULL
      2  1f23				  -	      pla
      3  1f23				  -	      sta	.l + 2
      4  1f23				  -	      pla
      5  1f23				  -	      sta	.l + 1
      6  1f23					      ELSE
      7  1f23		       8d 2b 1f 	      sta	.l + 1
      8  1f26		       8c 2c 1f 	      sty	.l + 2
      9  1f29					      ENDIF
     10  1f29		       68		      pla
     11  1f2a		       8d ff ff    .l	      sta	$ffff
   1350  1f2a				   FPULL      SET	0
      0  1f2d					      pbyte	7
      1  1f2d		       a9 07		      lda	#7
      2  1f2f					      IF	!FPUSH
      3  1f2f		       48		      pha
      4  1f30					      ENDIF
      0  1f30					      pwordvar	V_src2.pos_barrel
      1  1f30					      IF	!FPUSH
      2  1f30		       ad 54 34 	      lda	V_src2.pos_barrel
      3  1f33		       48		      pha
      4  1f34		       ad 55 34 	      lda	V_src2.pos_barrel+1
      5  1f37		       48		      pha
      6  1f38				  -	      ELSE
      7  1f38				  -	      lda	V_src2.pos_barrel
      8  1f38				  -	      ldy	V_src2.pos_barrel+1
      9  1f38					      ENDIF
      0  1f38					      F_cint_word
      0  1f38					      pint	30720
      0  1f38					      pword	30720
      1  1f38					      IF	!FPUSH
      2  1f38		       a9 00		      lda	#<30720
      3  1f3a		       48		      pha
      4  1f3b		       a9 78		      lda	#>30720
      5  1f3d		       48		      pha
      6  1f3e				  -	      ELSE
      7  1f3e				  -	      lda	#<30720
      8  1f3e				  -	      ldy	#>30720
      9  1f3e					      ENDIF
      0  1f3e					      addint
      0  1f3e					      addword
      1  1f3e		       ba		      tsx
      2  1f3f		       bd 02 01 	      lda.wx	stack + 2
      3  1f42		       18		      clc
      4  1f43		       7d 04 01 	      adc.wx	stack + 4
      5  1f46		       9d 04 01 	      sta.wx	stack + 4
      6  1f49		       68		      pla
      7  1f4a		       7d 03 01 	      adc.wx	stack + 3
      8  1f4d		       9d 03 01 	      sta.wx	stack + 3
      9  1f50		       68		      pla
      0  1f51					      F_cword_int
      0  1f51					      poke
      1  1f51					      IF	!FPULL
      2  1f51		       68		      pla
      3  1f52		       8d 5c 1f 	      sta	.l + 2
      4  1f55		       68		      pla
      5  1f56		       8d 5b 1f 	      sta	.l + 1
      6  1f59				  -	      ELSE
      7  1f59				  -	      sta	.l + 1
      8  1f59				  -	      sty	.l + 2
      9  1f59					      ENDIF
     10  1f59		       68		      pla
     11  1f5a		       8d ff ff    .l	      sta	$ffff
      0  1f5d					      pintvar	V_src2.dir_barrel
      0  1f5d					      pwordvar	V_src2.dir_barrel
      1  1f5d					      IF	!FPUSH
      2  1f5d		       ad 56 34 	      lda	V_src2.dir_barrel
      3  1f60		       48		      pha
      4  1f61		       ad 57 34 	      lda	V_src2.dir_barrel+1
      5  1f64		       48		      pha
      6  1f65				  -	      ELSE
      7  1f65				  -	      lda	V_src2.dir_barrel
      8  1f65				  -	      ldy	V_src2.dir_barrel+1
      9  1f65					      ENDIF
      0  1f65					      pbyte	22
      1  1f65		       a9 16		      lda	#22
      2  1f67					      IF	!FPUSH
      3  1f67		       48		      pha
      4  1f68					      ENDIF
      0  1f68					      F_cint_byte
      0  1f68					      F_cword_byte
      1  1f68		       a9 00		      lda	#$00
      2  1f6a		       48		      pha
      0  1f6b					      cmpinteq
      0  1f6b					      cmpwordeq
      1  1f6b					      IF	!FPULL
      2  1f6b		       68		      pla
      3  1f6c		       85 04		      sta	R2
      4  1f6e		       68		      pla
      5  1f6f		       85 03		      sta	R1
      6  1f71				  -	      ELSE
      7  1f71				  -	      sta	R1
      8  1f71				  -	      sty	R2
      9  1f71					      ENDIF
     10  1f71		       68		      pla
     11  1f72		       c5 04		      cmp	R2
     12  1f74		       d0 0a		      bne	.phf
     13  1f76		       68		      pla
     14  1f77		       c5 03		      cmp	R1
     15  1f79		       d0 06		      bne	.phf + 1
      0  1f7b					      ptrue
      1  1f7b		       a9 ff		      lda	#$FF
      2  1f7d					      IF	!FPUSH
      3  1f7d		       48		      pha
      4  1f7e					      ENDIF
     17  1f7e		       d0 04		      bne	.q
     18  1f80				   .phf
     19  1f80		       68		      pla
      0  1f81					      pfalse
      1  1f81		       a9 00		      lda	#$00
      2  1f83					      IF	!FPUSH
      3  1f83		       48		      pha
      4  1f84					      ENDIF
     21  1f84				   .q
   1362  1f84				   FPUSH      SET	1
      0  1f84					      pwordvar_pbyte_F_cword_byte_addword	V_src2.pos_barrel, 22
      0  1f84					      pintvar_pint_addint	V_src2.pos_barrel, 22
      1  1f84		       ad 54 34 	      lda	V_src2.pos_barrel
      2  1f87		       18		      clc
      3  1f88		       69 16		      adc	#<22
      4  1f8a				  -	      IF	!FPUSH
      5  1f8a				  -	      pha
      6  1f8a					      ELSE
      7  1f8a		       aa		      tax
      8  1f8b					      ENDIF
      9  1f8b		       ad 55 34 	      lda	V_src2.pos_barrel + 1
     10  1f8e		       69 00		      adc	#>22
     11  1f90				  -	      IF	!FPUSH
     12  1f90				  -	      pha
     13  1f90					      ELSE
     14  1f90		       a8		      tay
     15  1f91		       8a		      txa
     16  1f92					      ENDIF
   1364  1f92				   FPULL      SET	1
   1365  1f92				   FPUSH      SET	0
      0  1f92					      F_peek_word
      1  1f92				  -	      IF	!FPULL
      2  1f92				  -	      pla
      3  1f92				  -	      sta	.l + 2
      4  1f92				  -	      pla
      5  1f92				  -	      sta	.l + 1
      6  1f92					      ELSE
      7  1f92		       8d 99 1f 	      sta	.l + 1
      8  1f95		       8c 9a 1f 	      sty	.l + 2
      9  1f98					      ENDIF
     10  1f98		       ad ff ff    .l	      lda	$FFFF
     11  1f9b					      IF	!FPUSH
     12  1f9b		       48		      pha
     13  1f9c					      ENDIF
   1367  1f9c				   FPULL      SET	0
   1368  1f9c				   FPUSH      SET	1
      0  1f9c					      pbyte	56
      1  1f9c		       a9 38		      lda	#56
      2  1f9e				  -	      IF	!FPUSH
      3  1f9e				  -	      pha
      4  1f9e					      ENDIF
   1370  1f9e				   FPULL      SET	1
      0  1f9e					      cmpbyteeq
      1  1f9e				  -	      IF	!FPULL
      2  1f9e				  -	      pla
      3  1f9e					      ENDIF
      4  1f9e		       85 02		      sta	R0
      5  1fa0		       68		      pla
      6  1fa1		       c5 02		      cmp	R0
      7  1fa3		       f0 04		      beq	.pht
      0  1fa5					      pfalse
      1  1fa5		       a9 00		      lda	#$00
      2  1fa7				  -	      IF	!FPUSH
      3  1fa7				  -	      pha
      4  1fa7					      ENDIF
      9  1fa7		       f0 02		      beq	.q
      0  1fa9				   .pht       ptrue
      1  1fa9		       a9 ff		      lda	#$FF
      2  1fab				  -	      IF	!FPUSH
      3  1fab				  -	      pha
      4  1fab					      ENDIF
     11  1fab				   .q
      0  1fab					      andbyte
      1  1fab				  -	      IF	!FPULL
      2  1fab				  -	      pla
      3  1fab					      ENDIF
      4  1fab		       85 02		      sta	R0
      5  1fad		       68		      pla
      6  1fae		       25 02		      and	R0
      7  1fb0				  -	      IF	!FPUSH
      8  1fb0				  -	      pha
      9  1fb0					      ENDIF
   1373  1fb0				   FPUSH      SET	0
      0  1fb0					      cond_stmt	_EI_20, _EL_20
      1  1fb0				  -	      IF	!FPULL
      2  1fb0				  -	      pla
      3  1fb0					      ENDIF
      4  1fb0		       d0 03		      bne	* + 5
      5  1fb2					      IF	_EL_20 > 0 && _EL_20 < $10000
      6  1fb2		       4c c7 1f 	      jmp	_EL_20
      7  1fb5				  -	      ELSE
      8  1fb5				  -	      jmp	_EI_20
      9  1fb5					      ENDIF
      0  1fb5					      import	I_F_src2.get_random_direction
      1  1fb5				   I_F_src2.get_random_direction_IMPORTED SET	1
   1376  1fb5		       20 31 2b 	      jsr	F_src2.get_random_direction
   1377  1fb5				   FPULL      SET	0
   1378  1fb5				   FPUSH      SET	1
      0  1fb8					      pintvar	V_src2.get_random_direction_.get_random_direction
      0  1fb8					      pwordvar	V_src2.get_random_direction_.get_random_direction
      1  1fb8				  -	      IF	!FPUSH
      2  1fb8				  -	      lda	V_src2.get_random_direction_.get_random_direction
      3  1fb8				  -	      pha
      4  1fb8				  -	      lda	V_src2.get_random_direction_.get_random_direction+1
      5  1fb8				  -	      pha
      6  1fb8					      ELSE
      7  1fb8		       ad 46 34 	      lda	V_src2.get_random_direction_.get_random_direction
      8  1fbb		       ac 47 34 	      ldy	V_src2.get_random_direction_.get_random_direction+1
      9  1fbe					      ENDIF
   1380  1fbe				   FPULL      SET	1
   1381  1fbe				   FPUSH      SET	0
      0  1fbe					      plintvar	V_src2.dir_barrel
      0  1fbe					      plwordvar	V_src2.dir_barrel
      1  1fbe				  -	      IF	!FPULL
      2  1fbe				  -	      pla
      3  1fbe				  -	      sta	V_src2.dir_barrel+1
      4  1fbe				  -	      pla
      5  1fbe				  -	      sta	V_src2.dir_barrel
      6  1fbe					      ELSE
      7  1fbe		       8d 56 34 	      sta	V_src2.dir_barrel
      8  1fc1		       8c 57 34 	      sty	V_src2.dir_barrel+1
      9  1fc4					      ENDIF
   1383  1fc4		       4c e7 1f 	      jmp	_EI_20
   1384  1fc7				   _EL_20
   1385  1fc7
   1386  1fc7				   FPULL      SET	0
   1387  1fc7				   FPUSH      SET	1
      0  1fc7					      pbytevar_pbyte_cmpbyteeq	V_src2.w, 63
      1  1fc7		       ad 6f 34 	      lda	V_src2.w
      2  1fca		       c9 3f		      cmp	#63
      3  1fcc		       f0 04		      beq	.true
      0  1fce					      pfalse
      1  1fce		       a9 00		      lda	#$00
      2  1fd0				  -	      IF	!FPUSH
      3  1fd0				  -	      pha
      4  1fd0					      ENDIF
      5  1fd0		       f0 02		      beq	.end
      6  1fd2				   .true
      0  1fd2					      ptrue
      1  1fd2		       a9 ff		      lda	#$FF
      2  1fd4				  -	      IF	!FPUSH
      3  1fd4				  -	      pha
      4  1fd4					      ENDIF
      8  1fd4				   .end
   1389  1fd4				   FPULL      SET	1
   1390  1fd4				   FPUSH      SET	0
      0  1fd4					      cond_stmt	_EI_65547, 0
      1  1fd4				  -	      IF	!FPULL
      2  1fd4				  -	      pla
      3  1fd4					      ENDIF
      4  1fd4		       d0 03		      bne	* + 5
      5  1fd6				  -	      IF	0 > 0 && 0 < $10000
      6  1fd6				  -	      jmp	0
      7  1fd6					      ELSE
      8  1fd6		       4c e7 1f 	      jmp	_EI_65547
      9  1fd9					      ENDIF
   1392  1fd9				   FPULL      SET	0
      0  1fd9					      pbyte	22
      1  1fd9		       a9 16		      lda	#22
      2  1fdb					      IF	!FPUSH
      3  1fdb		       48		      pha
      4  1fdc					      ENDIF
      0  1fdc					      F_cint_byte
      0  1fdc					      F_cword_byte
      1  1fdc		       a9 00		      lda	#$00
      2  1fde		       48		      pha
      0  1fdf					      plintvar	V_src2.dir_barrel
      0  1fdf					      plwordvar	V_src2.dir_barrel
      1  1fdf					      IF	!FPULL
      2  1fdf		       68		      pla
      3  1fe0		       8d 57 34 	      sta	V_src2.dir_barrel+1
      4  1fe3		       68		      pla
      5  1fe4		       8d 56 34 	      sta	V_src2.dir_barrel
      6  1fe7				  -	      ELSE
      7  1fe7				  -	      sta	V_src2.dir_barrel
      8  1fe7				  -	      sty	V_src2.dir_barrel+1
      9  1fe7					      ENDIF
   1396  1fe7				   _EI_65547
   1397  1fe7
   1398  1fe7
   1399  1fe7
   1400  1fe7				   _EI_20
   1401  1fe7
   1402  1fe7				   FPUSH      SET	1
      0  1fe7					      pbytevar_pbyte_cmpbyteeq	V_src2.w, 58
      1  1fe7		       ad 6f 34 	      lda	V_src2.w
      2  1fea		       c9 3a		      cmp	#58
      3  1fec		       f0 04		      beq	.true
      0  1fee					      pfalse
      1  1fee		       a9 00		      lda	#$00
      2  1ff0				  -	      IF	!FPUSH
      3  1ff0				  -	      pha
      4  1ff0					      ENDIF
      5  1ff0		       f0 02		      beq	.end
      6  1ff2				   .true
      0  1ff2					      ptrue
      1  1ff2		       a9 ff		      lda	#$FF
      2  1ff4				  -	      IF	!FPUSH
      3  1ff4				  -	      pha
      4  1ff4					      ENDIF
      8  1ff4				   .end
   1404  1ff4				   FPULL      SET	1
   1405  1ff4				   FPUSH      SET	0
      0  1ff4					      cond_stmt	_EI_65548, 0
      1  1ff4				  -	      IF	!FPULL
      2  1ff4				  -	      pla
      3  1ff4					      ENDIF
      4  1ff4		       d0 03		      bne	* + 5
      5  1ff6				  -	      IF	0 > 0 && 0 < $10000
      6  1ff6				  -	      jmp	0
      7  1ff6					      ELSE
      8  1ff6		       4c ff 1f 	      jmp	_EI_65548
      9  1ff9					      ENDIF
   1407  1ff9				   FPULL      SET	0
   1408  1ff9				   FPUSH      SET	1
      0  1ff9					      pbyte	2
      1  1ff9		       a9 02		      lda	#2
      2  1ffb				  -	      IF	!FPUSH
      3  1ffb				  -	      pha
      4  1ffb					      ENDIF
   1410  1ffb				   FPULL      SET	1
   1411  1ffb				   FPUSH      SET	0
      0  1ffb					      plbytevar	V_src2.barrel_move_.barrel_move
      1  1ffb				  -	      IF	!FPULL
      2  1ffb				  -	      pla
      3  1ffb					      ENDIF
      4  1ffb		       8d 4f 34 	      sta	V_src2.barrel_move_.barrel_move
   1413  1ffe		       60		      rts
   1414  1fff				   _EI_65548
   1415  1fff				   FPULL      SET	0
      0  1fff					      pwordvar	V_src2.pos_barrel
      1  1fff					      IF	!FPUSH
      2  1fff		       ad 54 34 	      lda	V_src2.pos_barrel
      3  2002		       48		      pha
      4  2003		       ad 55 34 	      lda	V_src2.pos_barrel+1
      5  2006		       48		      pha
      6  2007				  -	      ELSE
      7  2007				  -	      lda	V_src2.pos_barrel
      8  2007				  -	      ldy	V_src2.pos_barrel+1
      9  2007					      ENDIF
      0  2007					      F_clong_word
      1  2007		       a9 00		      lda	#$00
      2  2009		       48		      pha
      0  200a					      pint	8164
      0  200a					      pword	8164
      1  200a					      IF	!FPUSH
      2  200a		       a9 e4		      lda	#<8164
      3  200c		       48		      pha
      4  200d		       a9 1f		      lda	#>8164
      5  200f		       48		      pha
      6  2010				  -	      ELSE
      7  2010				  -	      lda	#<8164
      8  2010				  -	      ldy	#>8164
      9  2010					      ENDIF
      0  2010					      F_clong_int
      1  2010		       ba		      tsx
      2  2011		       bd 01 01 	      lda	stack + 1,x
      3  2014		       10 04		      bpl	.pos
      4  2016		       a9 ff		      lda	#$ff
      5  2018		       30 02		      bmi	.end
      6  201a				   .pos
      7  201a		       a9 00		      lda	#$00
      8  201c				   .end
      9  201c		       48		      pha
   1420  201c				   FPUSH      SET	1
      0  201d					      cmplonglt
      0  201d					      _lcomparison
      1  201d		       ba		      tsx
      2  201e		       bd 06 01 	      lda.wx	stack+6
      3  2021		       dd 03 01 	      cmp.wx	stack+3
      4  2024		       bd 05 01 	      lda.wx	stack+5
      5  2027		       fd 02 01 	      sbc.wx	stack+2
      6  202a		       bd 04 01 	      lda.wx	stack+4
      7  202d		       fd 01 01 	      sbc.wx	stack+1
      8  2030		       50 02		      bvc	*+4
      9  2032		       49 80		      eor	#$80
      2  2034		       30 0a		      bmi	.true
      3  2036		       8a		      txa
      4  2037		       18		      clc
      5  2038		       69 06		      adc	#6
      6  203a		       aa		      tax
      7  203b		       9a		      txs
      0  203c					      pfalse
      1  203c		       a9 00		      lda	#$00
      2  203e				  -	      IF	!FPUSH
      3  203e				  -	      pha
      4  203e					      ENDIF
      9  203e		       f0 08		      beq	.q
     10  2040				   .true
     11  2040		       8a		      txa
     12  2041		       18		      clc
     13  2042		       69 06		      adc	#6
     14  2044		       aa		      tax
     15  2045		       9a		      txs
      0  2046					      ptrue
      1  2046		       a9 ff		      lda	#$FF
      2  2048				  -	      IF	!FPUSH
      3  2048				  -	      pha
      4  2048					      ENDIF
     17  2048				   .q
   1422  2048				   FPULL      SET	1
   1423  2048				   FPUSH      SET	0
      0  2048					      cond_stmt	_EI_65549, 0
      1  2048				  -	      IF	!FPULL
      2  2048				  -	      pla
      3  2048					      ENDIF
      4  2048		       d0 03		      bne	* + 5
      5  204a				  -	      IF	0 > 0 && 0 < $10000
      6  204a				  -	      jmp	0
      7  204a					      ELSE
      8  204a		       4c 53 20 	      jmp	_EI_65549
      9  204d					      ENDIF
   1425  204d				   FPULL      SET	0
   1426  204d				   FPUSH      SET	1
      0  204d					      pbyte	0
      1  204d		       a9 00		      lda	#0
      2  204f				  -	      IF	!FPUSH
      3  204f				  -	      pha
      4  204f					      ENDIF
   1428  204f				   FPULL      SET	1
   1429  204f				   FPUSH      SET	0
      0  204f					      plbytevar	V_src2.barrel_move_.barrel_move
      1  204f				  -	      IF	!FPULL
      2  204f				  -	      pla
      3  204f					      ENDIF
      4  204f		       8d 4f 34 	      sta	V_src2.barrel_move_.barrel_move
   1431  2052		       60		      rts
   1432  2053				   _EI_65549
   1433  2053
      0  2053					      pbytevar_pbyte_addbyte_plbytevar	V_src2.cbarrel, 1, V_src2.cbarrel
      1  2053					      IF	V_src2.cbarrel == V_src2.cbarrel && 1 == 1
      2  2053		       ee 58 34 	      inc	V_src2.cbarrel
      3  2056				  -	      ELSE
      4  2056				  -	      lda	V_src2.cbarrel
      5  2056				  -	      clc
      6  2056				  -	      adc	#1
      7  2056				  -	      sta	V_src2.cbarrel
      8  2056					      ENDIF
   1435  2056
   1436  2056				   FPULL      SET	0
   1437  2056				   FPUSH      SET	1
      0  2056					      pbytevar_pbyte_cmpbyteeq	V_src2.cbarrel, 12
      1  2056		       ad 58 34 	      lda	V_src2.cbarrel
      2  2059		       c9 0c		      cmp	#12
      3  205b		       f0 04		      beq	.true
      0  205d					      pfalse
      1  205d		       a9 00		      lda	#$00
      2  205f				  -	      IF	!FPUSH
      3  205f				  -	      pha
      4  205f					      ENDIF
      5  205f		       f0 02		      beq	.end
      6  2061				   .true
      0  2061					      ptrue
      1  2061		       a9 ff		      lda	#$FF
      2  2063				  -	      IF	!FPUSH
      3  2063				  -	      pha
      4  2063					      ENDIF
      8  2063				   .end
   1439  2063				   FPULL      SET	1
   1440  2063				   FPUSH      SET	0
      0  2063					      cond_stmt	_EI_65550, 0
      1  2063				  -	      IF	!FPULL
      2  2063				  -	      pla
      3  2063					      ENDIF
      4  2063		       d0 03		      bne	* + 5
      5  2065				  -	      IF	0 > 0 && 0 < $10000
      6  2065				  -	      jmp	0
      7  2065					      ELSE
      8  2065		       4c 6e 20 	      jmp	_EI_65550
      9  2068					      ENDIF
   1442  2068				   FPULL      SET	0
   1443  2068				   FPUSH      SET	1
      0  2068					      pbyte	2
      1  2068		       a9 02		      lda	#2
      2  206a				  -	      IF	!FPUSH
      3  206a				  -	      pha
      4  206a					      ENDIF
   1445  206a				   FPULL      SET	1
   1446  206a				   FPUSH      SET	0
      0  206a					      plbytevar	V_src2.barrel_move_.barrel_move
      1  206a				  -	      IF	!FPULL
      2  206a				  -	      pla
      3  206a					      ENDIF
      4  206a		       8d 4f 34 	      sta	V_src2.barrel_move_.barrel_move
   1448  206d		       60		      rts
   1449  206e				   _EI_65550
   1450  206e				   FPULL      SET	0
      0  206e					      pbyte	62
      1  206e		       a9 3e		      lda	#62
      2  2070					      IF	!FPUSH
      3  2070		       48		      pha
      4  2071					      ENDIF
   1452  2071				   FPUSH      SET	1
      0  2071					      pwordvar	V_src2.pos_barrel
      1  2071				  -	      IF	!FPUSH
      2  2071				  -	      lda	V_src2.pos_barrel
      3  2071				  -	      pha
      4  2071				  -	      lda	V_src2.pos_barrel+1
      5  2071				  -	      pha
      6  2071					      ELSE
      7  2071		       ad 54 34 	      lda	V_src2.pos_barrel
      8  2074		       ac 55 34 	      ldy	V_src2.pos_barrel+1
      9  2077					      ENDIF
   1454  2077				   FPULL      SET	1
   1455  2077				   FPUSH      SET	0
      0  2077					      poke
      1  2077				  -	      IF	!FPULL
      2  2077				  -	      pla
      3  2077				  -	      sta	.l + 2
      4  2077				  -	      pla
      5  2077				  -	      sta	.l + 1
      6  2077					      ELSE
      7  2077		       8d 7f 20 	      sta	.l + 1
      8  207a		       8c 80 20 	      sty	.l + 2
      9  207d					      ENDIF
     10  207d		       68		      pla
     11  207e		       8d ff ff    .l	      sta	$ffff
   1457  207e				   FPULL      SET	0
   1458  207e				   FPUSH      SET	1
      0  2081					      pbyte	3
      1  2081		       a9 03		      lda	#3
      2  2083				  -	      IF	!FPUSH
      3  2083				  -	      pha
      4  2083					      ENDIF
   1460  2083				   FPULL      SET	1
   1461  2083				   FPUSH      SET	0
      0  2083					      plbytevar	V_src2.barrel_move_.barrel_move
      1  2083				  -	      IF	!FPULL
      2  2083				  -	      pla
      3  2083					      ENDIF
      4  2083		       8d 4f 34 	      sta	V_src2.barrel_move_.barrel_move
   1463  2086		       60		      rts
   1464  2087		       60		      rts
   1465  2088					      ENDIF
   1466  2088
   1467  2088					      IFCONST	I_F_src2.draw_level_IMPORTED
   1468  2088				   F_src2.draw_level SUBROUTINE
      0  2088					      pstringvar	_S4
      1  2088		       a9 8f		      lda	#<_S4
      2  208a		       85 02		      sta	R0
      3  208c		       a9 33		      lda	#>_S4
      4  208e		       85 03		      sta	R0 + 1
      5  2090		       ad 8f 33 	      lda	_S4
      0  2093					      import	I_STRMOV
      1  2093				   I_STRMOV_IMPORTED SET	1
      7  2093		       20 93 32 	      jsr	STRMOV
      0  2096					      printstring
      1  2096		       a6 0e		      ldx	SP
      2  2098		       e8		      inx
      3  2099		       8a		      txa
      4  209a		       a0 1d		      ldy	#>STRING_WORKAREA
      0  209c					      import	I_STDLIB_PRINTSTR
      1  209c				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  209c		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  209f
      8  209f		       98		      tya
      9  20a0		       18		      clc
     10  20a1		       65 0e		      adc	SP
     11  20a3		       85 0e		      sta	SP
   1471  20a3				   FPULL      SET	0
      0  20a5					      pbyte	1
      1  20a5		       a9 01		      lda	#1
      2  20a7					      IF	!FPUSH
      3  20a7		       48		      pha
      4  20a8					      ENDIF
      0  20a8					      F_cword_byte
      1  20a8		       a9 00		      lda	#$00
      2  20aa		       48		      pha
      0  20ab					      plwordvar	V_src2.n
      1  20ab					      IF	!FPULL
      2  20ab		       68		      pla
      3  20ac		       8d 6e 34 	      sta	V_src2.n+1
      4  20af		       68		      pla
      5  20b0		       8d 6d 34 	      sta	V_src2.n
      6  20b3				  -	      ELSE
      7  20b3				  -	      sta	V_src2.n
      8  20b3				  -	      sty	V_src2.n+1
      9  20b3					      ENDIF
   1475  20b3				   _FOR_21
      0  20b3					      forword	21, V_src2.n, 21, "_void_", 1
      1  20b3
      2  20b3					      IF	1 == 1
      3  20b3		       a9 15		      lda	#<21
      4  20b5		       cd 6d 34 	      cmp	V_src2.n
      5  20b8		       a9 00		      lda	#>21
      6  20ba		       ed 6e 34 	      sbc	V_src2.n + 1
      7  20bd				  -	      ELSE
      8  20bd				  -	      lda	21
      9  20bd				  -	      cmp	V_src2.n
     10  20bd				  -	      lda	21 + 1
     11  20bd				  -	      sbc	V_src2.n + 1
     12  20bd					      ENDIF
     13  20bd		       b0 03		      bcs	.enter
     14  20bf		       4c f1 20 	      jmp	_ENDFOR_21
     15  20c2				   .enter
      0  20c2					      pstringvar	V_src2.a@
      1  20c2		       a9 75		      lda	#<V_src2.a@
      2  20c4		       85 02		      sta	R0
      3  20c6		       a9 34		      lda	#>V_src2.a@
      4  20c8		       85 03		      sta	R0 + 1
      5  20ca		       ad 75 34 	      lda	V_src2.a@
      0  20cd					      import	I_STRMOV
      1  20cd				   I_STRMOV_IMPORTED SET	1
      7  20cd		       20 93 32 	      jsr	STRMOV
      0  20d0					      printstring
      1  20d0		       a6 0e		      ldx	SP
      2  20d2		       e8		      inx
      3  20d3		       8a		      txa
      4  20d4		       a0 1d		      ldy	#>STRING_WORKAREA
      0  20d6					      import	I_STDLIB_PRINTSTR
      1  20d6				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  20d6		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  20d9
      8  20d9		       98		      tya
      9  20da		       18		      clc
     10  20db		       65 0e		      adc	SP
     11  20dd		       85 0e		      sta	SP
      0  20df					      printnl
      1  20df		       a9 0d		      lda	#13
      0  20e1					      kerncall	KERNAL_CHROUT
      1  20e1		       20 d2 ff 	      jsr	KERNAL_CHROUT
   1480  20e4
   1481  20e4
   1482  20e4
   1483  20e4				   _CO_21
      0  20e4					      nextword	21, V_src2.n, "_void_"
      1  20e4
      2  20e4				  -	      IFCONST	"_void_"
      3  20e4				  -
      4  20e4				  -	      clc
      5  20e4				  -	      lda	"_void_"
      6  20e4				  -	      adc	V_src2.n
      7  20e4				  -	      sta	V_src2.n
      8  20e4				  -	      lda	"_void_" + 1
      9  20e4				  -	      adc	V_src2.n + 1
     10  20e4				  -	      sta	V_src2.n + 1
     11  20e4				  -
     12  20e4				  -	      bcs	_ENDFOR_21
     13  20e4					      ELSE
     14  20e4
     15  20e4		       ee 6d 34 	      inc	V_src2.n
     16  20e7		       d0 05		      bne	.skip
     17  20e9		       ee 6e 34 	      inc	V_src2.n + 1
     18  20ec
     19  20ec		       f0 03		      beq	_ENDFOR_21
     20  20ee				   .skip
     21  20ee					      ENDIF
     22  20ee		       4c b3 20 	      jmp	_FOR_21
   1485  20f1
   1486  20f1
   1487  20f1
   1488  20f1				   _ENDFOR_21
      0  20f1					      pstringvar	V_src2.a@
      1  20f1		       a9 75		      lda	#<V_src2.a@
      2  20f3		       85 02		      sta	R0
      3  20f5		       a9 34		      lda	#>V_src2.a@
      4  20f7		       85 03		      sta	R0 + 1
      5  20f9		       ad 75 34 	      lda	V_src2.a@
      0  20fc					      import	I_STRMOV
      1  20fc				   I_STRMOV_IMPORTED SET	1
      7  20fc		       20 93 32 	      jsr	STRMOV
      0  20ff					      printstring
      1  20ff		       a6 0e		      ldx	SP
      2  2101		       e8		      inx
      3  2102		       8a		      txa
      4  2103		       a0 1d		      ldy	#>STRING_WORKAREA
      0  2105					      import	I_STDLIB_PRINTSTR
      1  2105				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  2105		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  2108
      8  2108		       98		      tya
      9  2109		       18		      clc
     10  210a		       65 0e		      adc	SP
     11  210c		       85 0e		      sta	SP
      0  210e					      pstringvar	_S5
      1  210e		       a9 91		      lda	#<_S5
      2  2110		       85 02		      sta	R0
      3  2112		       a9 33		      lda	#>_S5
      4  2114		       85 03		      sta	R0 + 1
      5  2116		       ad 91 33 	      lda	_S5
      0  2119					      import	I_STRMOV
      1  2119				   I_STRMOV_IMPORTED SET	1
      7  2119		       20 93 32 	      jsr	STRMOV
      0  211c					      printstring
      1  211c		       a6 0e		      ldx	SP
      2  211e		       e8		      inx
      3  211f		       8a		      txa
      4  2120		       a0 1d		      ldy	#>STRING_WORKAREA
      0  2122					      import	I_STDLIB_PRINTSTR
      1  2122				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  2122		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  2125
      8  2125		       98		      tya
      9  2126		       18		      clc
     10  2127		       65 0e		      adc	SP
     11  2129		       85 0e		      sta	SP
      0  212b					      printnl
      1  212b		       a9 0d		      lda	#13
      0  212d					      kerncall	KERNAL_CHROUT
      1  212d		       20 d2 ff 	      jsr	KERNAL_CHROUT
      0  2130					      pstringvar	_S6
      1  2130		       a9 93		      lda	#<_S6
      2  2132		       85 02		      sta	R0
      3  2134		       a9 33		      lda	#>_S6
      4  2136		       85 03		      sta	R0 + 1
      5  2138		       ad 93 33 	      lda	_S6
      0  213b					      import	I_STRMOV
      1  213b				   I_STRMOV_IMPORTED SET	1
      7  213b		       20 93 32 	      jsr	STRMOV
      0  213e					      plstringvar	V_src2.draw_level_.b@, 21
      1  213e		       a9 92		      lda	#<V_src2.draw_level_.b@
      2  2140		       85 02		      sta	R0
      3  2142		       a9 34		      lda	#>V_src2.draw_level_.b@
      4  2144		       85 03		      sta	R0 + 1
      5  2146		       a9 15		      lda	#21
      0  2148					      import	I_STRREMOV
      1  2148				   I_STRREMOV_IMPORTED SET	1
      7  2148		       20 aa 32 	      jsr	STRREMOV
      0  214b					      pbyte	1
      1  214b		       a9 01		      lda	#1
      2  214d					      IF	!FPUSH
      3  214d		       48		      pha
      4  214e					      ENDIF
      0  214e					      F_cword_byte
      1  214e		       a9 00		      lda	#$00
      2  2150		       48		      pha
      0  2151					      plwordvar	V_src2.n
      1  2151					      IF	!FPULL
      2  2151		       68		      pla
      3  2152		       8d 6e 34 	      sta	V_src2.n+1
      4  2155		       68		      pla
      5  2156		       8d 6d 34 	      sta	V_src2.n
      6  2159				  -	      ELSE
      7  2159				  -	      sta	V_src2.n
      8  2159				  -	      sty	V_src2.n+1
      9  2159					      ENDIF
   1499  2159				   _FOR_22
      0  2159					      forword	22, V_src2.n, 3, "_void_", 1
      1  2159
      2  2159					      IF	1 == 1
      3  2159		       a9 03		      lda	#<3
      4  215b		       cd 6d 34 	      cmp	V_src2.n
      5  215e		       a9 00		      lda	#>3
      6  2160		       ed 6e 34 	      sbc	V_src2.n + 1
      7  2163				  -	      ELSE
      8  2163				  -	      lda	3
      9  2163				  -	      cmp	V_src2.n
     10  2163				  -	      lda	3 + 1
     11  2163				  -	      sbc	V_src2.n + 1
     12  2163					      ENDIF
     13  2163		       b0 03		      bcs	.enter
     14  2165		       4c b4 21 	      jmp	_ENDFOR_22
     15  2168				   .enter
      0  2168					      pstringvar	V_src2.draw_level_.b@
      1  2168		       a9 92		      lda	#<V_src2.draw_level_.b@
      2  216a		       85 02		      sta	R0
      3  216c		       a9 34		      lda	#>V_src2.draw_level_.b@
      4  216e		       85 03		      sta	R0 + 1
      5  2170		       ad 92 34 	      lda	V_src2.draw_level_.b@
      0  2173					      import	I_STRMOV
      1  2173				   I_STRMOV_IMPORTED SET	1
      7  2173		       20 93 32 	      jsr	STRMOV
      0  2176					      printstring
      1  2176		       a6 0e		      ldx	SP
      2  2178		       e8		      inx
      3  2179		       8a		      txa
      4  217a		       a0 1d		      ldy	#>STRING_WORKAREA
      0  217c					      import	I_STDLIB_PRINTSTR
      1  217c				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  217c		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  217f
      8  217f		       98		      tya
      9  2180		       18		      clc
     10  2181		       65 0e		      adc	SP
     11  2183		       85 0e		      sta	SP
      0  2185					      pstringvar	_S7
      1  2185		       a9 a9		      lda	#<_S7
      2  2187		       85 02		      sta	R0
      3  2189		       a9 33		      lda	#>_S7
      4  218b		       85 03		      sta	R0 + 1
      5  218d		       ad a9 33 	      lda	_S7
      0  2190					      import	I_STRMOV
      1  2190				   I_STRMOV_IMPORTED SET	1
      7  2190		       20 93 32 	      jsr	STRMOV
      0  2193					      printstring
      1  2193		       a6 0e		      ldx	SP
      2  2195		       e8		      inx
      3  2196		       8a		      txa
      4  2197		       a0 1d		      ldy	#>STRING_WORKAREA
      0  2199					      import	I_STDLIB_PRINTSTR
      1  2199				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  2199		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  219c
      8  219c		       98		      tya
      9  219d		       18		      clc
     10  219e		       65 0e		      adc	SP
     11  21a0		       85 0e		      sta	SP
      0  21a2					      printnl
      1  21a2		       a9 0d		      lda	#13
      0  21a4					      kerncall	KERNAL_CHROUT
      1  21a4		       20 d2 ff 	      jsr	KERNAL_CHROUT
   1506  21a7
   1507  21a7
   1508  21a7
   1509  21a7				   _CO_22
      0  21a7					      nextword	22, V_src2.n, "_void_"
      1  21a7
      2  21a7				  -	      IFCONST	"_void_"
      3  21a7				  -
      4  21a7				  -	      clc
      5  21a7				  -	      lda	"_void_"
      6  21a7				  -	      adc	V_src2.n
      7  21a7				  -	      sta	V_src2.n
      8  21a7				  -	      lda	"_void_" + 1
      9  21a7				  -	      adc	V_src2.n + 1
     10  21a7				  -	      sta	V_src2.n + 1
     11  21a7				  -
     12  21a7				  -	      bcs	_ENDFOR_22
     13  21a7					      ELSE
     14  21a7
     15  21a7		       ee 6d 34 	      inc	V_src2.n
     16  21aa		       d0 05		      bne	.skip
     17  21ac		       ee 6e 34 	      inc	V_src2.n + 1
     18  21af
     19  21af		       f0 03		      beq	_ENDFOR_22
     20  21b1				   .skip
     21  21b1					      ENDIF
     22  21b1		       4c 59 21 	      jmp	_FOR_22
   1511  21b4
   1512  21b4
   1513  21b4
   1514  21b4				   _ENDFOR_22
      0  21b4					      pstringvar	V_src2.draw_level_.b@
      1  21b4		       a9 92		      lda	#<V_src2.draw_level_.b@
      2  21b6		       85 02		      sta	R0
      3  21b8		       a9 34		      lda	#>V_src2.draw_level_.b@
      4  21ba		       85 03		      sta	R0 + 1
      5  21bc		       ad 92 34 	      lda	V_src2.draw_level_.b@
      0  21bf					      import	I_STRMOV
      1  21bf				   I_STRMOV_IMPORTED SET	1
      7  21bf		       20 93 32 	      jsr	STRMOV
      0  21c2					      printstring
      1  21c2		       a6 0e		      ldx	SP
      2  21c4		       e8		      inx
      3  21c5		       8a		      txa
      4  21c6		       a0 1d		      ldy	#>STRING_WORKAREA
      0  21c8					      import	I_STDLIB_PRINTSTR
      1  21c8				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  21c8		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  21cb
      8  21cb		       98		      tya
      9  21cc		       18		      clc
     10  21cd		       65 0e		      adc	SP
     11  21cf		       85 0e		      sta	SP
      0  21d1					      pstringvar	_S8
      1  21d1		       a9 ae		      lda	#<_S8
      2  21d3		       85 02		      sta	R0
      3  21d5		       a9 33		      lda	#>_S8
      4  21d7		       85 03		      sta	R0 + 1
      5  21d9		       ad ae 33 	      lda	_S8
      0  21dc					      import	I_STRMOV
      1  21dc				   I_STRMOV_IMPORTED SET	1
      7  21dc		       20 93 32 	      jsr	STRMOV
      0  21df					      printstring
      1  21df		       a6 0e		      ldx	SP
      2  21e1		       e8		      inx
      3  21e2		       8a		      txa
      4  21e3		       a0 1d		      ldy	#>STRING_WORKAREA
      0  21e5					      import	I_STDLIB_PRINTSTR
      1  21e5				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  21e5		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  21e8
      8  21e8		       98		      tya
      9  21e9		       18		      clc
     10  21ea		       65 0e		      adc	SP
     11  21ec		       85 0e		      sta	SP
   1519  21ec				   FPUSH      SET	1
      0  21ee					      pbyte	62
      1  21ee		       a9 3e		      lda	#62
      2  21f0				  -	      IF	!FPUSH
      3  21f0				  -	      pha
      4  21f0					      ENDIF
   1521  21f0				   FPULL      SET	1
   1522  21f0				   FPUSH      SET	0
      0  21f0					      poke_constaddr	$1FF9
      1  21f0				  -	      IF	!FPULL
      2  21f0				  -	      pla
      3  21f0					      ENDIF
      4  21f0		       8d f9 1f 	      sta	$1FF9
      0  21f3					      import	I_F_src2.update_score
      1  21f3				   I_F_src2.update_score_IMPORTED SET	1
   1525  21f3		       20 61 2a 	      jsr	F_src2.update_score
   1526  21f3				   FPULL      SET	0
   1527  21f3				   FPUSH      SET	1
      0  21f6					      pbyte	163
      1  21f6		       a9 a3		      lda	#163
      2  21f8				  -	      IF	!FPUSH
      3  21f8				  -	      pha
      4  21f8					      ENDIF
   1529  21f8				   FPULL      SET	1
   1530  21f8				   FPUSH      SET	0
      0  21f8					      poke_constaddr	$1E11
      1  21f8				  -	      IF	!FPULL
      2  21f8				  -	      pla
      3  21f8					      ENDIF
      4  21f8		       8d 11 1e 	      sta	$1E11
   1532  21f8				   FPULL      SET	0
      0  21fb					      pbyte	0
      1  21fb		       a9 00		      lda	#0
      2  21fd					      IF	!FPUSH
      3  21fd		       48		      pha
      4  21fe					      ENDIF
      0  21fe					      F_cword_byte
      1  21fe		       a9 00		      lda	#$00
      2  2200		       48		      pha
      0  2201					      plwordvar	V_src2.n
      1  2201					      IF	!FPULL
      2  2201		       68		      pla
      3  2202		       8d 6e 34 	      sta	V_src2.n+1
      4  2205		       68		      pla
      5  2206		       8d 6d 34 	      sta	V_src2.n
      6  2209				  -	      ELSE
      7  2209				  -	      sta	V_src2.n
      8  2209				  -	      sty	V_src2.n+1
      9  2209					      ENDIF
   1536  2209				   _FOR_23
      0  2209					      forword	23, V_src2.n, 11, "_void_", 1
      1  2209
      2  2209					      IF	1 == 1
      3  2209		       a9 0b		      lda	#<11
      4  220b		       cd 6d 34 	      cmp	V_src2.n
      5  220e		       a9 00		      lda	#>11
      6  2210		       ed 6e 34 	      sbc	V_src2.n + 1
      7  2213				  -	      ELSE
      8  2213				  -	      lda	11
      9  2213				  -	      cmp	V_src2.n
     10  2213				  -	      lda	11 + 1
     11  2213				  -	      sbc	V_src2.n + 1
     12  2213					      ENDIF
     13  2213		       b0 03		      bcs	.enter
     14  2215		       4c b2 22 	      jmp	_ENDFOR_23
     15  2218				   .enter
      0  2218					      pbyte	60
      1  2218		       a9 3c		      lda	#60
      2  221a					      IF	!FPUSH
      3  221a		       48		      pha
      4  221b					      ENDIF
      0  221b					      pint	7712
      0  221b					      pword	7712
      1  221b					      IF	!FPUSH
      2  221b		       a9 20		      lda	#<7712
      3  221d		       48		      pha
      4  221e		       a9 1e		      lda	#>7712
      5  2220		       48		      pha
      6  2221				  -	      ELSE
      7  2221				  -	      lda	#<7712
      8  2221				  -	      ldy	#>7712
      9  2221					      ENDIF
      0  2221					      pwordvar	V_src2.n
      1  2221					      IF	!FPUSH
      2  2221		       ad 6d 34 	      lda	V_src2.n
      3  2224		       48		      pha
      4  2225		       ad 6e 34 	      lda	V_src2.n+1
      5  2228		       48		      pha
      6  2229				  -	      ELSE
      7  2229				  -	      lda	V_src2.n
      8  2229				  -	      ldy	V_src2.n+1
      9  2229					      ENDIF
      0  2229					      F_cbyte_word
      1  2229		       68		      pla
      0  222a					      pbytearrayfast	V_src2.bstack
      1  222a					      IF	!FPULL
      2  222a		       68		      pla
      3  222b					      ENDIF
      4  222b		       aa		      tax
      5  222c		       bd b2 33 	      lda	V_src2.bstack,x
      6  222f					      IF	!FPUSH
      7  222f		       48		      pha
      8  2230					      ENDIF
      0  2230					      F_cint_byte
      0  2230					      F_cword_byte
      1  2230		       a9 00		      lda	#$00
      2  2232		       48		      pha
      0  2233					      addint
      0  2233					      addword
      1  2233		       ba		      tsx
      2  2234		       bd 02 01 	      lda.wx	stack + 2
      3  2237		       18		      clc
      4  2238		       7d 04 01 	      adc.wx	stack + 4
      5  223b		       9d 04 01 	      sta.wx	stack + 4
      6  223e		       68		      pla
      7  223f		       7d 03 01 	      adc.wx	stack + 3
      8  2242		       9d 03 01 	      sta.wx	stack + 3
      9  2245		       68		      pla
      0  2246					      F_cword_int
      0  2246					      poke
      1  2246					      IF	!FPULL
      2  2246		       68		      pla
      3  2247		       8d 51 22 	      sta	.l + 2
      4  224a		       68		      pla
      5  224b		       8d 50 22 	      sta	.l + 1
      6  224e				  -	      ELSE
      7  224e				  -	      sta	.l + 1
      8  224e				  -	      sty	.l + 2
      9  224e					      ENDIF
     10  224e		       68		      pla
     11  224f		       8d ff ff    .l	      sta	$ffff
      0  2252					      pbyte	7
      1  2252		       a9 07		      lda	#7
      2  2254					      IF	!FPUSH
      3  2254		       48		      pha
      4  2255					      ENDIF
      0  2255					      pint	7712
      0  2255					      pword	7712
      1  2255					      IF	!FPUSH
      2  2255		       a9 20		      lda	#<7712
      3  2257		       48		      pha
      4  2258		       a9 1e		      lda	#>7712
      5  225a		       48		      pha
      6  225b				  -	      ELSE
      7  225b				  -	      lda	#<7712
      8  225b				  -	      ldy	#>7712
      9  225b					      ENDIF
      0  225b					      pwordvar	V_src2.n
      1  225b					      IF	!FPUSH
      2  225b		       ad 6d 34 	      lda	V_src2.n
      3  225e		       48		      pha
      4  225f		       ad 6e 34 	      lda	V_src2.n+1
      5  2262		       48		      pha
      6  2263				  -	      ELSE
      7  2263				  -	      lda	V_src2.n
      8  2263				  -	      ldy	V_src2.n+1
      9  2263					      ENDIF
      0  2263					      F_cbyte_word
      1  2263		       68		      pla
      0  2264					      pbytearrayfast	V_src2.bstack
      1  2264					      IF	!FPULL
      2  2264		       68		      pla
      3  2265					      ENDIF
      4  2265		       aa		      tax
      5  2266		       bd b2 33 	      lda	V_src2.bstack,x
      6  2269					      IF	!FPUSH
      7  2269		       48		      pha
      8  226a					      ENDIF
      0  226a					      F_cint_byte
      0  226a					      F_cword_byte
      1  226a		       a9 00		      lda	#$00
      2  226c		       48		      pha
      0  226d					      addint
      0  226d					      addword
      1  226d		       ba		      tsx
      2  226e		       bd 02 01 	      lda.wx	stack + 2
      3  2271		       18		      clc
      4  2272		       7d 04 01 	      adc.wx	stack + 4
      5  2275		       9d 04 01 	      sta.wx	stack + 4
      6  2278		       68		      pla
      7  2279		       7d 03 01 	      adc.wx	stack + 3
      8  227c		       9d 03 01 	      sta.wx	stack + 3
      9  227f		       68		      pla
      0  2280					      pint	30720
      0  2280					      pword	30720
      1  2280					      IF	!FPUSH
      2  2280		       a9 00		      lda	#<30720
      3  2282		       48		      pha
      4  2283		       a9 78		      lda	#>30720
      5  2285		       48		      pha
      6  2286				  -	      ELSE
      7  2286				  -	      lda	#<30720
      8  2286				  -	      ldy	#>30720
      9  2286					      ENDIF
      0  2286					      addint
      0  2286					      addword
      1  2286		       ba		      tsx
      2  2287		       bd 02 01 	      lda.wx	stack + 2
      3  228a		       18		      clc
      4  228b		       7d 04 01 	      adc.wx	stack + 4
      5  228e		       9d 04 01 	      sta.wx	stack + 4
      6  2291		       68		      pla
      7  2292		       7d 03 01 	      adc.wx	stack + 3
      8  2295		       9d 03 01 	      sta.wx	stack + 3
      9  2298		       68		      pla
      0  2299					      F_cword_int
      0  2299					      poke
      1  2299					      IF	!FPULL
      2  2299		       68		      pla
      3  229a		       8d a4 22 	      sta	.l + 2
      4  229d		       68		      pla
      5  229e		       8d a3 22 	      sta	.l + 1
      6  22a1				  -	      ELSE
      7  22a1				  -	      sta	.l + 1
      8  22a1				  -	      sty	.l + 2
      9  22a1					      ENDIF
     10  22a1		       68		      pla
     11  22a2		       8d ff ff    .l	      sta	$ffff
   1558  22a5				   _CO_23
      0  22a5					      nextword	23, V_src2.n, "_void_"
      1  22a5
      2  22a5				  -	      IFCONST	"_void_"
      3  22a5				  -
      4  22a5				  -	      clc
      5  22a5				  -	      lda	"_void_"
      6  22a5				  -	      adc	V_src2.n
      7  22a5				  -	      sta	V_src2.n
      8  22a5				  -	      lda	"_void_" + 1
      9  22a5				  -	      adc	V_src2.n + 1
     10  22a5				  -	      sta	V_src2.n + 1
     11  22a5				  -
     12  22a5				  -	      bcs	_ENDFOR_23
     13  22a5					      ELSE
     14  22a5
     15  22a5		       ee 6d 34 	      inc	V_src2.n
     16  22a8		       d0 05		      bne	.skip
     17  22aa		       ee 6e 34 	      inc	V_src2.n + 1
     18  22ad
     19  22ad		       f0 03		      beq	_ENDFOR_23
     20  22af				   .skip
     21  22af					      ENDIF
     22  22af		       4c 09 22 	      jmp	_FOR_23
   1560  22b2
   1561  22b2
   1562  22b2
   1563  22b2				   _ENDFOR_23
      0  22b2					      pint	7834
      0  22b2					      pword	7834
      1  22b2					      IF	!FPUSH
      2  22b2		       a9 9a		      lda	#<7834
      3  22b4		       48		      pha
      4  22b5		       a9 1e		      lda	#>7834
      5  22b7		       48		      pha
      6  22b8				  -	      ELSE
      7  22b8				  -	      lda	#<7834
      8  22b8				  -	      ldy	#>7834
      9  22b8					      ENDIF
      0  22b8					      F_cword_int
      0  22b8					      plwordvar	V_src2.n
      1  22b8					      IF	!FPULL
      2  22b8		       68		      pla
      3  22b9		       8d 6e 34 	      sta	V_src2.n+1
      4  22bc		       68		      pla
      5  22bd		       8d 6d 34 	      sta	V_src2.n
      6  22c0				  -	      ELSE
      7  22c0				  -	      sta	V_src2.n
      8  22c0				  -	      sty	V_src2.n+1
      9  22c0					      ENDIF
      0  22c0					      pbyte	110
      1  22c0		       a9 6e		      lda	#110
      2  22c2					      IF	!FPUSH
      3  22c2		       48		      pha
      4  22c3					      ENDIF
      0  22c3					      F_cword_byte
      1  22c3		       a9 00		      lda	#$00
      2  22c5		       48		      pha
      0  22c6					      plwordvar	V_src2.draw_level_.forstep24
      1  22c6					      IF	!FPULL
      2  22c6		       68		      pla
      3  22c7		       8d aa 34 	      sta	V_src2.draw_level_.forstep24+1
      4  22ca		       68		      pla
      5  22cb		       8d a9 34 	      sta	V_src2.draw_level_.forstep24
      6  22ce				  -	      ELSE
      7  22ce				  -	      sta	V_src2.draw_level_.forstep24
      8  22ce				  -	      sty	V_src2.draw_level_.forstep24+1
      9  22ce					      ENDIF
   1570  22ce				   _FOR_24
      0  22ce					      forword	24, V_src2.n, 8164, V_src2.draw_level_.forstep24, 1
      1  22ce
      2  22ce					      IF	1 == 1
      3  22ce		       a9 e4		      lda	#<8164
      4  22d0		       cd 6d 34 	      cmp	V_src2.n
      5  22d3		       a9 1f		      lda	#>8164
      6  22d5		       ed 6e 34 	      sbc	V_src2.n + 1
      7  22d8				  -	      ELSE
      8  22d8				  -	      lda	8164
      9  22d8				  -	      cmp	V_src2.n
     10  22d8				  -	      lda	8164 + 1
     11  22d8				  -	      sbc	V_src2.n + 1
     12  22d8					      ENDIF
     13  22d8		       b0 03		      bcs	.enter
     14  22da		       4c 58 28 	      jmp	_ENDFOR_24
     15  22dd				   .enter
   1572  22dd				   FPUSH      SET	1
      0  22dd					      pbyte	1
      1  22dd		       a9 01		      lda	#1
      2  22df				  -	      IF	!FPUSH
      3  22df				  -	      pha
      4  22df					      ENDIF
   1574  22df				   FPULL      SET	1
   1575  22df				   FPUSH      SET	0
      0  22df					      plbytevar	V_src2.o
      1  22df				  -	      IF	!FPULL
      2  22df				  -	      pla
      3  22df					      ENDIF
      4  22df		       8d 71 34 	      sta	V_src2.o
   1577  22e2				   _FOR_25
      0  22e2					      forbyte	25, V_src2.o, 3, "_void_", 1
      1  22e2
      2  22e2					      IF	1 == 1
      3  22e2		       a9 03		      lda	#3
      4  22e4				  -	      ELSE
      5  22e4				  -	      lda	3
      6  22e4					      ENDIF
      7  22e4		       cd 71 34 	      cmp	V_src2.o
      8  22e7		       b0 03		      bcs	.enter
      9  22e9
     10  22e9		       4c 95 25 	      jmp	_ENDFOR_25
     11  22ec				   .enter
   1579  22ec
   1580  22ec
   1581  22ec
   1582  22ec				   _DO_26
   1583  22ec
   1584  22ec				   FPULL      SET	0
      0  22ec					      pwordvar_pbyte_F_cword_byte_addword	V_src2.n, 1
      0  22ec					      pintvar_pint_addint	V_src2.n, 1
      1  22ec		       ad 6d 34 	      lda	V_src2.n
      2  22ef		       18		      clc
      3  22f0		       69 01		      adc	#<1
      4  22f2					      IF	!FPUSH
      5  22f2		       48		      pha
      6  22f3				  -	      ELSE
      7  22f3				  -	      tax
      8  22f3					      ENDIF
      9  22f3		       ad 6e 34 	      lda	V_src2.n + 1
     10  22f6		       69 00		      adc	#>1
     11  22f8					      IF	!FPUSH
     12  22f8		       48		      pha
     13  22f9				  -	      ELSE
     14  22f9				  -	      tay
     15  22f9				  -	      txa
     16  22f9					      ENDIF
      0  22f9					      pbyte	20
      1  22f9		       a9 14		      lda	#20
      2  22fb					      IF	!FPUSH
      3  22fb		       48		      pha
      4  22fc					      ENDIF
      0  22fc					      F_cword_byte
      1  22fc		       a9 00		      lda	#$00
      2  22fe		       48		      pha
      0  22ff					      plwordvar	V_src2.random_word_word.limit
      1  22ff					      IF	!FPULL
      2  22ff		       68		      pla
      3  2300		       8d 49 34 	      sta	V_src2.random_word_word.limit+1
      4  2303		       68		      pla
      5  2304		       8d 48 34 	      sta	V_src2.random_word_word.limit
      6  2307				  -	      ELSE
      7  2307				  -	      sta	V_src2.random_word_word.limit
      8  2307				  -	      sty	V_src2.random_word_word.limit+1
      9  2307					      ENDIF
      0  2307					      pbyte	31
      1  2307		       a9 1f		      lda	#31
      2  2309					      IF	!FPUSH
      3  2309		       48		      pha
      4  230a					      ENDIF
      0  230a					      F_cword_byte
      1  230a		       a9 00		      lda	#$00
      2  230c		       48		      pha
      0  230d					      plwordvar	V_src2.random_word_word.mask
      1  230d					      IF	!FPULL
      2  230d		       68		      pla
      3  230e		       8d 4b 34 	      sta	V_src2.random_word_word.mask+1
      4  2311		       68		      pla
      5  2312		       8d 4a 34 	      sta	V_src2.random_word_word.mask
      6  2315				  -	      ELSE
      7  2315				  -	      sta	V_src2.random_word_word.mask
      8  2315				  -	      sty	V_src2.random_word_word.mask+1
      9  2315					      ENDIF
      0  2315					      import	I_F_src2.random_word_word
      1  2315				   I_F_src2.random_word_word_IMPORTED SET	1
   1593  2315		       20 62 2b 	      jsr	F_src2.random_word_word
      0  2318					      pwordvar	V_src2.random_word_word.random
      1  2318					      IF	!FPUSH
      2  2318		       ad 4c 34 	      lda	V_src2.random_word_word.random
      3  231b		       48		      pha
      4  231c		       ad 4d 34 	      lda	V_src2.random_word_word.random+1
      5  231f		       48		      pha
      6  2320				  -	      ELSE
      7  2320				  -	      lda	V_src2.random_word_word.random
      8  2320				  -	      ldy	V_src2.random_word_word.random+1
      9  2320					      ENDIF
      0  2320					      addword
      1  2320		       ba		      tsx
      2  2321		       bd 02 01 	      lda.wx	stack + 2
      3  2324		       18		      clc
      4  2325		       7d 04 01 	      adc.wx	stack + 4
      5  2328		       9d 04 01 	      sta.wx	stack + 4
      6  232b		       68		      pla
      7  232c		       7d 03 01 	      adc.wx	stack + 3
      8  232f		       9d 03 01 	      sta.wx	stack + 3
      9  2332		       68		      pla
      0  2333					      plwordvar	V_src2.draw_level_.r
      1  2333					      IF	!FPULL
      2  2333		       68		      pla
      3  2334		       8d 91 34 	      sta	V_src2.draw_level_.r+1
      4  2337		       68		      pla
      5  2338		       8d 90 34 	      sta	V_src2.draw_level_.r
      6  233b				  -	      ELSE
      7  233b				  -	      sta	V_src2.draw_level_.r
      8  233b				  -	      sty	V_src2.draw_level_.r+1
      9  233b					      ENDIF
   1597  233b				   _CO_26
   1598  233b				   FPUSH      SET	1
      0  233b					      pwordvar	V_src2.draw_level_.r
      1  233b				  -	      IF	!FPUSH
      2  233b				  -	      lda	V_src2.draw_level_.r
      3  233b				  -	      pha
      4  233b				  -	      lda	V_src2.draw_level_.r+1
      5  233b				  -	      pha
      6  233b					      ELSE
      7  233b		       ad 90 34 	      lda	V_src2.draw_level_.r
      8  233e		       ac 91 34 	      ldy	V_src2.draw_level_.r+1
      9  2341					      ENDIF
   1600  2341				   FPULL      SET	1
   1601  2341				   FPUSH      SET	0
      0  2341					      F_peek_word
      1  2341				  -	      IF	!FPULL
      2  2341				  -	      pla
      3  2341				  -	      sta	.l + 2
      4  2341				  -	      pla
      5  2341				  -	      sta	.l + 1
      6  2341					      ELSE
      7  2341		       8d 48 23 	      sta	.l + 1
      8  2344		       8c 49 23 	      sty	.l + 2
      9  2347					      ENDIF
     10  2347		       ad ff ff    .l	      lda	$FFFF
     11  234a					      IF	!FPUSH
     12  234a		       48		      pha
     13  234b					      ENDIF
   1603  234b				   FPULL      SET	0
   1604  234b				   FPUSH      SET	1
      0  234b					      pbyte	56
      1  234b		       a9 38		      lda	#56
      2  234d				  -	      IF	!FPUSH
      3  234d				  -	      pha
      4  234d					      ENDIF
   1606  234d				   FPULL      SET	1
      0  234d					      cmpbyteneq
      1  234d				  -	      IF	!FPULL
      2  234d				  -	      pla
      3  234d					      ENDIF
      4  234d		       85 02		      sta	R0
      5  234f		       68		      pla
      6  2350		       c5 02		      cmp	R0
      7  2352		       d0 04		      bne	.pht
      0  2354					      pfalse
      1  2354		       a9 00		      lda	#$00
      2  2356				  -	      IF	!FPUSH
      3  2356				  -	      pha
      4  2356					      ENDIF
      9  2356		       f0 02		      beq	.q
      0  2358				   .pht       ptrue
      1  2358		       a9 ff		      lda	#$FF
      2  235a				  -	      IF	!FPUSH
      3  235a				  -	      pha
      4  235a					      ENDIF
     11  235a				   .q
   1608  235a				   FPUSH      SET	0
      0  235a					      cond_stmt	_ED_26, $10000
      1  235a				  -	      IF	!FPULL
      2  235a				  -	      pla
      3  235a					      ENDIF
      4  235a		       d0 03		      bne	* + 5
      5  235c				  -	      IF	$10000 > 0 && $10000 < $10000
      6  235c				  -	      jmp	$10000
      7  235c					      ELSE
      8  235c		       4c 62 23 	      jmp	_ED_26
      9  235f					      ENDIF
   1610  235f		       4c ec 22 	      jmp	_DO_26
   1611  2362				   _ED_26
   1612  2362				   FPULL      SET	0
      0  2362					      pwordvar	V_src2.draw_level_.r
      1  2362					      IF	!FPUSH
      2  2362		       ad 90 34 	      lda	V_src2.draw_level_.r
      3  2365		       48		      pha
      4  2366		       ad 91 34 	      lda	V_src2.draw_level_.r+1
      5  2369		       48		      pha
      6  236a				  -	      ELSE
      7  236a				  -	      lda	V_src2.draw_level_.r
      8  236a				  -	      ldy	V_src2.draw_level_.r+1
      9  236a					      ENDIF
      0  236a					      F_cbyte_word
      1  236a		       68		      pla
      0  236b					      plbytevar	V_src2.m
      1  236b					      IF	!FPULL
      2  236b		       68		      pla
      3  236c					      ENDIF
      4  236c		       8d 70 34 	      sta	V_src2.m
      0  236f					      pwordvar_pbyte_F_cword_byte_addword	V_src2.draw_level_.r, 88
      0  236f					      pintvar_pint_addint	V_src2.draw_level_.r, 88
      1  236f		       ad 90 34 	      lda	V_src2.draw_level_.r
      2  2372		       18		      clc
      3  2373		       69 58		      adc	#<88
      4  2375					      IF	!FPUSH
      5  2375		       48		      pha
      6  2376				  -	      ELSE
      7  2376				  -	      tax
      8  2376					      ENDIF
      9  2376		       ad 91 34 	      lda	V_src2.draw_level_.r + 1
     10  2379		       69 00		      adc	#>88
     11  237b					      IF	!FPUSH
     12  237b		       48		      pha
     13  237c				  -	      ELSE
     14  237c				  -	      tay
     15  237c				  -	      txa
     16  237c					      ENDIF
      0  237c					      F_cbyte_word
      1  237c		       68		      pla
      0  237d					      plbytevar	V_src2.draw_level_.forlim27
      1  237d					      IF	!FPULL
      2  237d		       68		      pla
      3  237e					      ENDIF
      4  237e		       8d ab 34 	      sta	V_src2.draw_level_.forlim27
   1619  237e				   FPUSH      SET	1
      0  2381					      pbyte	22
      1  2381		       a9 16		      lda	#22
      2  2383				  -	      IF	!FPUSH
      3  2383				  -	      pha
      4  2383					      ENDIF
   1621  2383				   FPULL      SET	1
   1622  2383				   FPUSH      SET	0
      0  2383					      plbytevar	V_src2.draw_level_.forstep27
      1  2383				  -	      IF	!FPULL
      2  2383				  -	      pla
      3  2383					      ENDIF
      4  2383		       8d ac 34 	      sta	V_src2.draw_level_.forstep27
   1624  2386				   _FOR_27
      0  2386					      forbyte	27, V_src2.m, V_src2.draw_level_.forlim27, V_src2.draw_level_.forstep27, 0
      1  2386
      2  2386				  -	      IF	0 == 1
      3  2386				  -	      lda	#V_src2.draw_level_.forlim27
      4  2386					      ELSE
      5  2386		       ad ab 34 	      lda	V_src2.draw_level_.forlim27
      6  2389					      ENDIF
      7  2389		       cd 70 34 	      cmp	V_src2.m
      8  238c		       b0 03		      bcs	.enter
      9  238e
     10  238e		       4c e5 23 	      jmp	_ENDFOR_27
     11  2391				   .enter
   1626  2391				   FPULL      SET	0
      0  2391					      pbyte	57
      1  2391		       a9 39		      lda	#57
      2  2393					      IF	!FPUSH
      3  2393		       48		      pha
      4  2394					      ENDIF
      0  2394					      pbytevar	V_src2.m
      1  2394		       ad 70 34 	      lda	V_src2.m
      2  2397					      IF	!FPUSH
      3  2397		       48		      pha
      4  2398					      ENDIF
      0  2398					      F_cword_byte
      1  2398		       a9 00		      lda	#$00
      2  239a		       48		      pha
      0  239b					      poke
      1  239b					      IF	!FPULL
      2  239b		       68		      pla
      3  239c		       8d a6 23 	      sta	.l + 2
      4  239f		       68		      pla
      5  23a0		       8d a5 23 	      sta	.l + 1
      6  23a3				  -	      ELSE
      7  23a3				  -	      sta	.l + 1
      8  23a3				  -	      sty	.l + 2
      9  23a3					      ENDIF
     10  23a3		       68		      pla
     11  23a4		       8d ff ff    .l	      sta	$ffff
      0  23a7					      pbyte	2
      1  23a7		       a9 02		      lda	#2
      2  23a9					      IF	!FPUSH
      3  23a9		       48		      pha
      4  23aa					      ENDIF
      0  23aa					      pbytevar	V_src2.m
      1  23aa		       ad 70 34 	      lda	V_src2.m
      2  23ad					      IF	!FPUSH
      3  23ad		       48		      pha
      4  23ae					      ENDIF
      0  23ae					      F_cint_byte
      0  23ae					      F_cword_byte
      1  23ae		       a9 00		      lda	#$00
      2  23b0		       48		      pha
      0  23b1					      pint	30720
      0  23b1					      pword	30720
      1  23b1					      IF	!FPUSH
      2  23b1		       a9 00		      lda	#<30720
      3  23b3		       48		      pha
      4  23b4		       a9 78		      lda	#>30720
      5  23b6		       48		      pha
      6  23b7				  -	      ELSE
      7  23b7				  -	      lda	#<30720
      8  23b7				  -	      ldy	#>30720
      9  23b7					      ENDIF
      0  23b7					      addint
      0  23b7					      addword
      1  23b7		       ba		      tsx
      2  23b8		       bd 02 01 	      lda.wx	stack + 2
      3  23bb		       18		      clc
      4  23bc		       7d 04 01 	      adc.wx	stack + 4
      5  23bf		       9d 04 01 	      sta.wx	stack + 4
      6  23c2		       68		      pla
      7  23c3		       7d 03 01 	      adc.wx	stack + 3
      8  23c6		       9d 03 01 	      sta.wx	stack + 3
      9  23c9		       68		      pla
      0  23ca					      F_cword_int
      0  23ca					      poke
      1  23ca					      IF	!FPULL
      2  23ca		       68		      pla
      3  23cb		       8d d5 23 	      sta	.l + 2
      4  23ce		       68		      pla
      5  23cf		       8d d4 23 	      sta	.l + 1
      6  23d2				  -	      ELSE
      7  23d2				  -	      sta	.l + 1
      8  23d2				  -	      sty	.l + 2
      9  23d2					      ENDIF
     10  23d2		       68		      pla
     11  23d3		       8d ff ff    .l	      sta	$ffff
   1638  23d6				   _CO_27
      0  23d6					      nextbyte	27, V_src2.m, V_src2.draw_level_.forstep27
      1  23d6
      2  23d6					      IFCONST	V_src2.draw_level_.forstep27
      3  23d6
      4  23d6		       18		      clc
      5  23d7		       ad ac 34 	      lda	V_src2.draw_level_.forstep27
      6  23da		       6d 70 34 	      adc	V_src2.m
      7  23dd		       8d 70 34 	      sta	V_src2.m
      8  23e0
      9  23e0		       b0 03		      bcs	_ENDFOR_27
     10  23e2				  -	      ELSE
     11  23e2				  -
     12  23e2				  -	      inc	V_src2.m
     13  23e2				  -
     14  23e2				  -	      beq	_ENDFOR_27
     15  23e2					      ENDIF
     16  23e2		       4c 86 23 	      jmp	_FOR_27
   1640  23e5
   1641  23e5
   1642  23e5
   1643  23e5				   _ENDFOR_27
   1644  23e5
      0  23e5					      pbytevar_pbyte_cmpbytegt	V_src2.o, 1
      1  23e5		       a9 01		      lda	#1
      2  23e7		       cd 71 34 	      cmp	V_src2.o
      3  23ea		       90 05		      bcc	.true
      0  23ec					      pfalse
      1  23ec		       a9 00		      lda	#$00
      2  23ee					      IF	!FPUSH
      3  23ee		       48		      pha
      4  23ef					      ENDIF
      5  23ef		       f0 03		      beq	.end
      6  23f1				   .true
      0  23f1					      ptrue
      1  23f1		       a9 ff		      lda	#$FF
      2  23f3					      IF	!FPUSH
      3  23f3		       48		      pha
      4  23f4					      ENDIF
      8  23f4				   .end
      0  23f4					      F_rnd
      0  23f4					      import	I_RND
      1  23f4				   I_RND_IMPORTED SET	1
      2  23f4		       20 7f 2c 	      jsr	I_RND
      0  23f7					      pfloatvar	MATH_RND_EXP
      1  23f7		       ad 4b 2c 	      lda	MATH_RND_EXP + 3
      2  23fa		       48		      pha
      3  23fb					      IF	!FPUSH
      4  23fb		       ad 4a 2c 	      lda	MATH_RND_EXP + 2
      5  23fe		       48		      pha
      6  23ff		       ad 49 2c 	      lda	MATH_RND_EXP + 1
      7  2402		       48		      pha
      8  2403		       ad 48 2c 	      lda	MATH_RND_EXP
      9  2406		       48		      pha
     10  2407				  -	      ELSE
     11  2407				  -	      lda	MATH_RND_EXP + 2
     12  2407				  -	      ldy	MATH_RND_EXP + 1
     13  2407				  -	      ldx	MATH_RND_EXP
     14  2407					      ENDIF
   1647  2407				   FPUSH      SET	1
      0  2407					      pfloatvar	V_src2.divert_chance
      1  2407		       ad 67 34 	      lda	V_src2.divert_chance + 3
      2  240a		       48		      pha
      3  240b				  -	      IF	!FPUSH
      4  240b				  -	      lda	V_src2.divert_chance + 2
      5  240b				  -	      pha
      6  240b				  -	      lda	V_src2.divert_chance + 1
      7  240b				  -	      pha
      8  240b				  -	      lda	V_src2.divert_chance
      9  240b				  -	      pha
     10  240b					      ELSE
     11  240b		       ad 66 34 	      lda	V_src2.divert_chance + 2
     12  240e		       ac 65 34 	      ldy	V_src2.divert_chance + 1
     13  2411		       ae 64 34 	      ldx	V_src2.divert_chance
     14  2414					      ENDIF
   1649  2414				   FPULL      SET	1
      0  2414					      cmpfloatlt
      0  2414					      plfloattofac
      1  2414				  -	      IF	!FPULL
      2  2414				  -	      pla
      3  2414				  -	      sta	FAC
      4  2414				  -	      pla
      5  2414				  -	      sta	FACSIGN
      6  2414				  -	      ora	#%10000000
      7  2414				  -	      sta	FAC + 1
      8  2414				  -	      pla
      9  2414				  -	      sta	FAC + 2
     10  2414					      ELSE
     11  2414		       85 2a		      sta	FAC + 2
     12  2416		       98		      tya
     13  2417		       85 2c		      sta	FACSIGN
     14  2419		       09 80		      ora	#%10000000
     15  241b		       85 29		      sta	FAC + 1
     16  241d		       86 28		      stx	FAC
     17  241f					      ENDIF
     18  241f		       68		      pla
     19  2420		       85 2b		      sta	FAC + 3
     20  2422		       a9 00		      lda	#$00
     21  2424		       85 35		      sta	FACEXTENSION
      2  2426		       ba		      tsx
      3  2427		       e8		      inx
      4  2428		       86 19		      stx	DEST
      5  242a		       a0 01		      ldy	#$01
      0  242c					      import	I_FPLIB
      1  242c				   I_FPLIB_IMPORTED SET	1
      7  242c		       20 68 30 	      jsr	FCOMP2
      8  242f		       c9 01		      cmp	#$01
      9  2431		       f0 0a		      beq	.true
      0  2433					      discardfloat
      1  2433		       ba		      tsx
      2  2434		       e8		      inx
      3  2435		       e8		      inx
      4  2436		       e8		      inx
      5  2437		       e8		      inx
      6  2438		       9a		      txs
      0  2439					      pfalse
      1  2439		       a9 00		      lda	#$00
      2  243b				  -	      IF	!FPUSH
      3  243b				  -	      pha
      4  243b					      ENDIF
     12  243b				  -	      IF	!FPUSH
     13  243b				  -	      beq	* + 11
     14  243b					      ELSE
     15  243b		       f0 08		      beq	* + 10
     16  243d					      ENDIF
     17  243d				   .true
      0  243d					      discardfloat
      1  243d		       ba		      tsx
      2  243e		       e8		      inx
      3  243f		       e8		      inx
      4  2440		       e8		      inx
      5  2441		       e8		      inx
      6  2442		       9a		      txs
      0  2443					      ptrue
      1  2443		       a9 ff		      lda	#$FF
      2  2445				  -	      IF	!FPUSH
      3  2445				  -	      pha
      4  2445					      ENDIF
      0  2445					      andbyte
      1  2445				  -	      IF	!FPULL
      2  2445				  -	      pla
      3  2445					      ENDIF
      4  2445		       85 02		      sta	R0
      5  2447		       68		      pla
      6  2448		       25 02		      and	R0
      7  244a				  -	      IF	!FPUSH
      8  244a				  -	      pha
      9  244a					      ENDIF
   1652  244a				   FPUSH      SET	0
      0  244a					      cond_stmt	_EI_28, _EL_28
      1  244a				  -	      IF	!FPULL
      2  244a				  -	      pla
      3  244a					      ENDIF
      4  244a		       d0 03		      bne	* + 5
      5  244c					      IF	_EL_28 > 0 && _EL_28 < $10000
      6  244c		       4c c0 24 	      jmp	_EL_28
      7  244f				  -	      ELSE
      8  244f				  -	      jmp	_EI_28
      9  244f					      ENDIF
   1654  244f				   FPULL      SET	0
      0  244f					      pbyte	63
      1  244f		       a9 3f		      lda	#63
      2  2451					      IF	!FPUSH
      3  2451		       48		      pha
      4  2452					      ENDIF
      0  2452					      pwordvar	V_src2.draw_level_.r
      1  2452					      IF	!FPUSH
      2  2452		       ad 90 34 	      lda	V_src2.draw_level_.r
      3  2455		       48		      pha
      4  2456		       ad 91 34 	      lda	V_src2.draw_level_.r+1
      5  2459		       48		      pha
      6  245a				  -	      ELSE
      7  245a				  -	      lda	V_src2.draw_level_.r
      8  245a				  -	      ldy	V_src2.draw_level_.r+1
      9  245a					      ENDIF
      0  245a					      pbyte	2
      1  245a		       a9 02		      lda	#2
      2  245c					      IF	!FPUSH
      3  245c		       48		      pha
      4  245d					      ENDIF
      0  245d					      F_cword_byte
      1  245d		       a9 00		      lda	#$00
      2  245f		       48		      pha
      0  2460					      plwordvar	V_src2.random_word_word.limit
      1  2460					      IF	!FPULL
      2  2460		       68		      pla
      3  2461		       8d 49 34 	      sta	V_src2.random_word_word.limit+1
      4  2464		       68		      pla
      5  2465		       8d 48 34 	      sta	V_src2.random_word_word.limit
      6  2468				  -	      ELSE
      7  2468				  -	      sta	V_src2.random_word_word.limit
      8  2468				  -	      sty	V_src2.random_word_word.limit+1
      9  2468					      ENDIF
      0  2468					      pbyte	2
      1  2468		       a9 02		      lda	#2
      2  246a					      IF	!FPUSH
      3  246a		       48		      pha
      4  246b					      ENDIF
      0  246b					      F_cword_byte
      1  246b		       a9 00		      lda	#$00
      2  246d		       48		      pha
      0  246e					      plwordvar	V_src2.random_word_word.mask
      1  246e					      IF	!FPULL
      2  246e		       68		      pla
      3  246f		       8d 4b 34 	      sta	V_src2.random_word_word.mask+1
      4  2472		       68		      pla
      5  2473		       8d 4a 34 	      sta	V_src2.random_word_word.mask
      6  2476				  -	      ELSE
      7  2476				  -	      sta	V_src2.random_word_word.mask
      8  2476				  -	      sty	V_src2.random_word_word.mask+1
      9  2476					      ENDIF
      0  2476					      import	I_F_src2.random_word_word
      1  2476				   I_F_src2.random_word_word_IMPORTED SET	1
   1664  2476		       20 62 2b 	      jsr	F_src2.random_word_word
      0  2479					      pwordvar_pbyte_F_cword_byte_addword	V_src2.random_word_word.random, 2
      0  2479					      pintvar_pint_addint	V_src2.random_word_word.random, 2
      1  2479		       ad 4c 34 	      lda	V_src2.random_word_word.random
      2  247c		       18		      clc
      3  247d		       69 02		      adc	#<2
      4  247f					      IF	!FPUSH
      5  247f		       48		      pha
      6  2480				  -	      ELSE
      7  2480				  -	      tax
      8  2480					      ENDIF
      9  2480		       ad 4d 34 	      lda	V_src2.random_word_word.random + 1
     10  2483		       69 00		      adc	#>2
     11  2485					      IF	!FPUSH
     12  2485		       48		      pha
     13  2486				  -	      ELSE
     14  2486				  -	      tay
     15  2486				  -	      txa
     16  2486					      ENDIF
      0  2486					      pbyte	22
      1  2486		       a9 16		      lda	#22
      2  2488					      IF	!FPUSH
      3  2488		       48		      pha
      4  2489					      ENDIF
      0  2489					      F_cword_byte
      1  2489		       a9 00		      lda	#$00
      2  248b		       48		      pha
      0  248c					      mulword
      1  248c					      IF	!FPULL
      2  248c		       68		      pla
      3  248d		       85 03		      sta	R1
      4  248f		       68		      pla
      5  2490		       85 02		      sta	R0
      6  2492				  -	      ELSE
      7  2492				  -	      sta	R0
      8  2492				  -	      sty	R1
      9  2492					      ENDIF
     10  2492		       68		      pla
     11  2493		       85 05		      sta	R3
     12  2495		       68		      pla
     13  2496		       85 04		      sta	R2
      0  2498					      import	I_NUCLEUS_MULU16
      1  2498				   I_NUCLEUS_MULU16_IMPORTED SET	1
     15  2498		       20 22 2c 	      jsr	NUCLEUS_MULU16
     16  249b					      IF	!FPUSH
     17  249b		       a5 02		      lda	R0
     18  249d		       48		      pha
     19  249e		       a5 03		      lda	R1
     20  24a0		       48		      pha
     21  24a1				  -	      ELSE
     22  24a1				  -	      lda	R0
     23  24a1				  -	      ldy	R1
     24  24a1					      ENDIF
      0  24a1					      addword
      1  24a1		       ba		      tsx
      2  24a2		       bd 02 01 	      lda.wx	stack + 2
      3  24a5		       18		      clc
      4  24a6		       7d 04 01 	      adc.wx	stack + 4
      5  24a9		       9d 04 01 	      sta.wx	stack + 4
      6  24ac		       68		      pla
      7  24ad		       7d 03 01 	      adc.wx	stack + 3
      8  24b0		       9d 03 01 	      sta.wx	stack + 3
      9  24b3		       68		      pla
      0  24b4					      poke
      1  24b4					      IF	!FPULL
      2  24b4		       68		      pla
      3  24b5		       8d bf 24 	      sta	.l + 2
      4  24b8		       68		      pla
      5  24b9		       8d be 24 	      sta	.l + 1
      6  24bc				  -	      ELSE
      7  24bc				  -	      sta	.l + 1
      8  24bc				  -	      sty	.l + 2
      9  24bc					      ENDIF
     10  24bc		       68		      pla
     11  24bd		       8d ff ff    .l	      sta	$ffff
   1671  24c0				   _EL_28
   1672  24c0
   1673  24c0
   1674  24c0
   1675  24c0				   _EI_28
      0  24c0					      F_rnd
      0  24c0					      import	I_RND
      1  24c0				   I_RND_IMPORTED SET	1
      2  24c0		       20 7f 2c 	      jsr	I_RND
      0  24c3					      pfloatvar	MATH_RND_EXP
      1  24c3		       ad 4b 2c 	      lda	MATH_RND_EXP + 3
      2  24c6		       48		      pha
      3  24c7					      IF	!FPUSH
      4  24c7		       ad 4a 2c 	      lda	MATH_RND_EXP + 2
      5  24ca		       48		      pha
      6  24cb		       ad 49 2c 	      lda	MATH_RND_EXP + 1
      7  24ce		       48		      pha
      8  24cf		       ad 48 2c 	      lda	MATH_RND_EXP
      9  24d2		       48		      pha
     10  24d3				  -	      ELSE
     11  24d3				  -	      lda	MATH_RND_EXP + 2
     12  24d3				  -	      ldy	MATH_RND_EXP + 1
     13  24d3				  -	      ldx	MATH_RND_EXP
     14  24d3					      ENDIF
   1677  24d3				   FPUSH      SET	1
      0  24d3					      pfloat	80,00,00,00
      1  24d3		       a9 00		      lda	#$00
      2  24d5		       48		      pha
      3  24d6				  -	      IF	!FPUSH
      4  24d6				  -	      lda	#$00
      5  24d6				  -	      pha
      6  24d6				  -	      lda	#$00
      7  24d6				  -	      pha
      8  24d6				  -	      lda	#$80
      9  24d6				  -	      pha
     10  24d6					      ELSE
     11  24d6		       a9 00		      lda	#$00
     12  24d8		       a0 00		      ldy	#$00
     13  24da		       a2 80		      ldx	#$80
     14  24dc					      ENDIF
   1679  24dc				   FPULL      SET	1
   1680  24dc				   FPUSH      SET	0
      0  24dc					      cmpfloatlt
      0  24dc					      plfloattofac
      1  24dc				  -	      IF	!FPULL
      2  24dc				  -	      pla
      3  24dc				  -	      sta	FAC
      4  24dc				  -	      pla
      5  24dc				  -	      sta	FACSIGN
      6  24dc				  -	      ora	#%10000000
      7  24dc				  -	      sta	FAC + 1
      8  24dc				  -	      pla
      9  24dc				  -	      sta	FAC + 2
     10  24dc					      ELSE
     11  24dc		       85 2a		      sta	FAC + 2
     12  24de		       98		      tya
     13  24df		       85 2c		      sta	FACSIGN
     14  24e1		       09 80		      ora	#%10000000
     15  24e3		       85 29		      sta	FAC + 1
     16  24e5		       86 28		      stx	FAC
     17  24e7					      ENDIF
     18  24e7		       68		      pla
     19  24e8		       85 2b		      sta	FAC + 3
     20  24ea		       a9 00		      lda	#$00
     21  24ec		       85 35		      sta	FACEXTENSION
      2  24ee		       ba		      tsx
      3  24ef		       e8		      inx
      4  24f0		       86 19		      stx	DEST
      5  24f2		       a0 01		      ldy	#$01
      0  24f4					      import	I_FPLIB
      1  24f4				   I_FPLIB_IMPORTED SET	1
      7  24f4		       20 68 30 	      jsr	FCOMP2
      8  24f7		       c9 01		      cmp	#$01
      9  24f9		       f0 0b		      beq	.true
      0  24fb					      discardfloat
      1  24fb		       ba		      tsx
      2  24fc		       e8		      inx
      3  24fd		       e8		      inx
      4  24fe		       e8		      inx
      5  24ff		       e8		      inx
      6  2500		       9a		      txs
      0  2501					      pfalse
      1  2501		       a9 00		      lda	#$00
      2  2503					      IF	!FPUSH
      3  2503		       48		      pha
      4  2504					      ENDIF
     12  2504					      IF	!FPUSH
     13  2504		       f0 09		      beq	* + 11
     14  2506				  -	      ELSE
     15  2506				  -	      beq	* + 10
     16  2506					      ENDIF
     17  2506				   .true
      0  2506					      discardfloat
      1  2506		       ba		      tsx
      2  2507		       e8		      inx
      3  2508		       e8		      inx
      4  2509		       e8		      inx
      5  250a		       e8		      inx
      6  250b		       9a		      txs
      0  250c					      ptrue
      1  250c		       a9 ff		      lda	#$FF
      2  250e					      IF	!FPUSH
      3  250e		       48		      pha
      4  250f					      ENDIF
   1682  250f				   FPULL      SET	0
      0  250f					      pwordvar	V_src2.draw_level_.r
      1  250f					      IF	!FPUSH
      2  250f		       ad 90 34 	      lda	V_src2.draw_level_.r
      3  2512		       48		      pha
      4  2513		       ad 91 34 	      lda	V_src2.draw_level_.r+1
      5  2516		       48		      pha
      6  2517				  -	      ELSE
      7  2517				  -	      lda	V_src2.draw_level_.r
      8  2517				  -	      ldy	V_src2.draw_level_.r+1
      9  2517					      ENDIF
      0  2517					      pbyte	22
      1  2517		       a9 16		      lda	#22
      2  2519					      IF	!FPUSH
      3  2519		       48		      pha
      4  251a					      ENDIF
      0  251a					      F_cword_byte
      1  251a		       a9 00		      lda	#$00
      2  251c		       48		      pha
      0  251d					      subword
      1  251d		       ba		      tsx
      2  251e		       bd 04 01 	      lda.wx	stack + 4
      3  2521		       38		      sec
      4  2522		       fd 02 01 	      sbc.wx	stack + 2
      5  2525		       9d 04 01 	      sta.wx	stack + 4
      6  2528		       bd 03 01 	      lda.wx	stack + 3
      7  252b		       fd 01 01 	      sbc.wx	stack + 1
      8  252e		       9d 03 01 	      sta.wx	stack + 3
      9  2531		       e8		      inx
     10  2532		       e8		      inx
     11  2533		       9a		      txs
      0  2534					      F_peek_word
      1  2534					      IF	!FPULL
      2  2534		       68		      pla
      3  2535		       8d 3e 25 	      sta	.l + 2
      4  2538		       68		      pla
      5  2539		       8d 3d 25 	      sta	.l + 1
      6  253c				  -	      ELSE
      7  253c				  -	      sta	.l + 1
      8  253c				  -	      sty	.l + 2
      9  253c					      ENDIF
     10  253c		       ad ff ff    .l	      lda	$FFFF
     11  253f					      IF	!FPUSH
     12  253f		       48		      pha
     13  2540					      ENDIF
   1688  2540				   FPUSH      SET	1
      0  2540					      pbyte	62
      1  2540		       a9 3e		      lda	#62
      2  2542				  -	      IF	!FPUSH
      3  2542				  -	      pha
      4  2542					      ENDIF
   1690  2542				   FPULL      SET	1
      0  2542					      cmpbyteeq
      1  2542				  -	      IF	!FPULL
      2  2542				  -	      pla
      3  2542					      ENDIF
      4  2542		       85 02		      sta	R0
      5  2544		       68		      pla
      6  2545		       c5 02		      cmp	R0
      7  2547		       f0 04		      beq	.pht
      0  2549					      pfalse
      1  2549		       a9 00		      lda	#$00
      2  254b				  -	      IF	!FPUSH
      3  254b				  -	      pha
      4  254b					      ENDIF
      9  254b		       f0 02		      beq	.q
      0  254d				   .pht       ptrue
      1  254d		       a9 ff		      lda	#$FF
      2  254f				  -	      IF	!FPUSH
      3  254f				  -	      pha
      4  254f					      ENDIF
     11  254f				   .q
      0  254f					      andbyte
      1  254f				  -	      IF	!FPULL
      2  254f				  -	      pla
      3  254f					      ENDIF
      4  254f		       85 02		      sta	R0
      5  2551		       68		      pla
      6  2552		       25 02		      and	R0
      7  2554				  -	      IF	!FPUSH
      8  2554				  -	      pha
      9  2554					      ENDIF
   1693  2554				   FPUSH      SET	0
      0  2554					      cond_stmt	_EI_29, _EL_29
      1  2554				  -	      IF	!FPULL
      2  2554				  -	      pla
      3  2554					      ENDIF
      4  2554		       d0 03		      bne	* + 5
      5  2556					      IF	_EL_29 > 0 && _EL_29 < $10000
      6  2556		       4c 8d 25 	      jmp	_EL_29
      7  2559				  -	      ELSE
      8  2559				  -	      jmp	_EI_29
      9  2559					      ENDIF
   1695  2559				   FPULL      SET	0
      0  2559					      pbyte	63
      1  2559		       a9 3f		      lda	#63
      2  255b					      IF	!FPUSH
      3  255b		       48		      pha
      4  255c					      ENDIF
      0  255c					      pwordvar	V_src2.draw_level_.r
      1  255c					      IF	!FPUSH
      2  255c		       ad 90 34 	      lda	V_src2.draw_level_.r
      3  255f		       48		      pha
      4  2560		       ad 91 34 	      lda	V_src2.draw_level_.r+1
      5  2563		       48		      pha
      6  2564				  -	      ELSE
      7  2564				  -	      lda	V_src2.draw_level_.r
      8  2564				  -	      ldy	V_src2.draw_level_.r+1
      9  2564					      ENDIF
      0  2564					      pbyte	22
      1  2564		       a9 16		      lda	#22
      2  2566					      IF	!FPUSH
      3  2566		       48		      pha
      4  2567					      ENDIF
      0  2567					      F_cword_byte
      1  2567		       a9 00		      lda	#$00
      2  2569		       48		      pha
      0  256a					      subword
      1  256a		       ba		      tsx
      2  256b		       bd 04 01 	      lda.wx	stack + 4
      3  256e		       38		      sec
      4  256f		       fd 02 01 	      sbc.wx	stack + 2
      5  2572		       9d 04 01 	      sta.wx	stack + 4
      6  2575		       bd 03 01 	      lda.wx	stack + 3
      7  2578		       fd 01 01 	      sbc.wx	stack + 1
      8  257b		       9d 03 01 	      sta.wx	stack + 3
      9  257e		       e8		      inx
     10  257f		       e8		      inx
     11  2580		       9a		      txs
      0  2581					      poke
      1  2581					      IF	!FPULL
      2  2581		       68		      pla
      3  2582		       8d 8c 25 	      sta	.l + 2
      4  2585		       68		      pla
      5  2586		       8d 8b 25 	      sta	.l + 1
      6  2589				  -	      ELSE
      7  2589				  -	      sta	.l + 1
      8  2589				  -	      sty	.l + 2
      9  2589					      ENDIF
     10  2589		       68		      pla
     11  258a		       8d ff ff    .l	      sta	$ffff
   1702  258d				   _EL_29
   1703  258d
   1704  258d
   1705  258d
   1706  258d				   _EI_29
   1707  258d
   1708  258d
   1709  258d
   1710  258d				   _CO_25
      0  258d					      nextbyte	25, V_src2.o, "_void_"
      1  258d
      2  258d				  -	      IFCONST	"_void_"
      3  258d				  -
      4  258d				  -	      clc
      5  258d				  -	      lda	"_void_"
      6  258d				  -	      adc	V_src2.o
      7  258d				  -	      sta	V_src2.o
      8  258d				  -
      9  258d				  -	      bcs	_ENDFOR_25
     10  258d					      ELSE
     11  258d
     12  258d		       ee 71 34 	      inc	V_src2.o
     13  2590
     14  2590		       f0 03		      beq	_ENDFOR_25
     15  2592					      ENDIF
     16  2592		       4c e2 22 	      jmp	_FOR_25
   1712  2595
   1713  2595
   1714  2595
   1715  2595				   _ENDFOR_25
   1716  2595				   FPUSH      SET	1
      0  2595					      pbyte	1
      1  2595		       a9 01		      lda	#1
      2  2597				  -	      IF	!FPUSH
      3  2597				  -	      pha
      4  2597					      ENDIF
   1718  2597				   FPULL      SET	1
   1719  2597				   FPUSH      SET	0
      0  2597					      plbytevar	V_src2.o
      1  2597				  -	      IF	!FPULL
      2  2597				  -	      pla
      3  2597					      ENDIF
      4  2597		       8d 71 34 	      sta	V_src2.o
   1721  2597				   FPULL      SET	0
   1722  2597				   FPUSH      SET	1
      0  259a					      pbytevar	V_src2.holes
      1  259a		       ad 61 34 	      lda	V_src2.holes
      2  259d				  -	      IF	!FPUSH
      3  259d				  -	      pha
      4  259d					      ENDIF
   1724  259d				   FPULL      SET	1
   1725  259d				   FPUSH      SET	0
      0  259d					      plbytevar	V_src2.draw_level_.forlim30
      1  259d				  -	      IF	!FPULL
      2  259d				  -	      pla
      3  259d					      ENDIF
      4  259d		       8d ad 34 	      sta	V_src2.draw_level_.forlim30
   1727  25a0				   _FOR_30
      0  25a0					      forbyte	30, V_src2.o, V_src2.draw_level_.forlim30, "_void_", 0
      1  25a0
      2  25a0				  -	      IF	0 == 1
      3  25a0				  -	      lda	#V_src2.draw_level_.forlim30
      4  25a0					      ELSE
      5  25a0		       ad ad 34 	      lda	V_src2.draw_level_.forlim30
      6  25a3					      ENDIF
      7  25a3		       cd 71 34 	      cmp	V_src2.o
      8  25a6		       b0 03		      bcs	.enter
      9  25a8
     10  25a8		       4c 2a 27 	      jmp	_ENDFOR_30
     11  25ab				   .enter
   1729  25ab
   1730  25ab
   1731  25ab
   1732  25ab				   _DO_31
   1733  25ab
   1734  25ab				   FPULL      SET	0
      0  25ab					      pwordvar_pbyte_F_cword_byte_addword	V_src2.n, 3
      0  25ab					      pintvar_pint_addint	V_src2.n, 3
      1  25ab		       ad 6d 34 	      lda	V_src2.n
      2  25ae		       18		      clc
      3  25af		       69 03		      adc	#<3
      4  25b1					      IF	!FPUSH
      5  25b1		       48		      pha
      6  25b2				  -	      ELSE
      7  25b2				  -	      tax
      8  25b2					      ENDIF
      9  25b2		       ad 6e 34 	      lda	V_src2.n + 1
     10  25b5		       69 00		      adc	#>3
     11  25b7					      IF	!FPUSH
     12  25b7		       48		      pha
     13  25b8				  -	      ELSE
     14  25b8				  -	      tay
     15  25b8				  -	      txa
     16  25b8					      ENDIF
      0  25b8					      pbyte	16
      1  25b8		       a9 10		      lda	#16
      2  25ba					      IF	!FPUSH
      3  25ba		       48		      pha
      4  25bb					      ENDIF
      0  25bb					      F_cword_byte
      1  25bb		       a9 00		      lda	#$00
      2  25bd		       48		      pha
      0  25be					      plwordvar	V_src2.random_word_word.limit
      1  25be					      IF	!FPULL
      2  25be		       68		      pla
      3  25bf		       8d 49 34 	      sta	V_src2.random_word_word.limit+1
      4  25c2		       68		      pla
      5  25c3		       8d 48 34 	      sta	V_src2.random_word_word.limit
      6  25c6				  -	      ELSE
      7  25c6				  -	      sta	V_src2.random_word_word.limit
      8  25c6				  -	      sty	V_src2.random_word_word.limit+1
      9  25c6					      ENDIF
      0  25c6					      pbyte	15
      1  25c6		       a9 0f		      lda	#15
      2  25c8					      IF	!FPUSH
      3  25c8		       48		      pha
      4  25c9					      ENDIF
      0  25c9					      F_cword_byte
      1  25c9		       a9 00		      lda	#$00
      2  25cb		       48		      pha
      0  25cc					      plwordvar	V_src2.random_word_word.mask
      1  25cc					      IF	!FPULL
      2  25cc		       68		      pla
      3  25cd		       8d 4b 34 	      sta	V_src2.random_word_word.mask+1
      4  25d0		       68		      pla
      5  25d1		       8d 4a 34 	      sta	V_src2.random_word_word.mask
      6  25d4				  -	      ELSE
      7  25d4				  -	      sta	V_src2.random_word_word.mask
      8  25d4				  -	      sty	V_src2.random_word_word.mask+1
      9  25d4					      ENDIF
      0  25d4					      import	I_F_src2.random_word_word
      1  25d4				   I_F_src2.random_word_word_IMPORTED SET	1
   1743  25d4		       20 62 2b 	      jsr	F_src2.random_word_word
      0  25d7					      pwordvar	V_src2.random_word_word.random
      1  25d7					      IF	!FPUSH
      2  25d7		       ad 4c 34 	      lda	V_src2.random_word_word.random
      3  25da		       48		      pha
      4  25db		       ad 4d 34 	      lda	V_src2.random_word_word.random+1
      5  25de		       48		      pha
      6  25df				  -	      ELSE
      7  25df				  -	      lda	V_src2.random_word_word.random
      8  25df				  -	      ldy	V_src2.random_word_word.random+1
      9  25df					      ENDIF
      0  25df					      addword
      1  25df		       ba		      tsx
      2  25e0		       bd 02 01 	      lda.wx	stack + 2
      3  25e3		       18		      clc
      4  25e4		       7d 04 01 	      adc.wx	stack + 4
      5  25e7		       9d 04 01 	      sta.wx	stack + 4
      6  25ea		       68		      pla
      7  25eb		       7d 03 01 	      adc.wx	stack + 3
      8  25ee		       9d 03 01 	      sta.wx	stack + 3
      9  25f1		       68		      pla
      0  25f2					      plwordvar	V_src2.draw_level_.r
      1  25f2					      IF	!FPULL
      2  25f2		       68		      pla
      3  25f3		       8d 91 34 	      sta	V_src2.draw_level_.r+1
      4  25f6		       68		      pla
      5  25f7		       8d 90 34 	      sta	V_src2.draw_level_.r
      6  25fa				  -	      ELSE
      7  25fa				  -	      sta	V_src2.draw_level_.r
      8  25fa				  -	      sty	V_src2.draw_level_.r+1
      9  25fa					      ENDIF
   1747  25fa				   _CO_31
   1748  25fa				   FPUSH      SET	1
      0  25fa					      pwordvar	V_src2.draw_level_.r
      1  25fa				  -	      IF	!FPUSH
      2  25fa				  -	      lda	V_src2.draw_level_.r
      3  25fa				  -	      pha
      4  25fa				  -	      lda	V_src2.draw_level_.r+1
      5  25fa				  -	      pha
      6  25fa					      ELSE
      7  25fa		       ad 90 34 	      lda	V_src2.draw_level_.r
      8  25fd		       ac 91 34 	      ldy	V_src2.draw_level_.r+1
      9  2600					      ENDIF
   1750  2600				   FPULL      SET	1
   1751  2600				   FPUSH      SET	0
      0  2600					      F_peek_word
      1  2600				  -	      IF	!FPULL
      2  2600				  -	      pla
      3  2600				  -	      sta	.l + 2
      4  2600				  -	      pla
      5  2600				  -	      sta	.l + 1
      6  2600					      ELSE
      7  2600		       8d 07 26 	      sta	.l + 1
      8  2603		       8c 08 26 	      sty	.l + 2
      9  2606					      ENDIF
     10  2606		       ad ff ff    .l	      lda	$FFFF
     11  2609					      IF	!FPUSH
     12  2609		       48		      pha
     13  260a					      ENDIF
   1753  260a				   FPULL      SET	0
   1754  260a				   FPUSH      SET	1
      0  260a					      pbyte	56
      1  260a		       a9 38		      lda	#56
      2  260c				  -	      IF	!FPUSH
      3  260c				  -	      pha
      4  260c					      ENDIF
   1756  260c				   FPULL      SET	1
   1757  260c				   FPUSH      SET	0
      0  260c					      cmpbyteneq
      1  260c				  -	      IF	!FPULL
      2  260c				  -	      pla
      3  260c					      ENDIF
      4  260c		       85 02		      sta	R0
      5  260e		       68		      pla
      6  260f		       c5 02		      cmp	R0
      7  2611		       d0 05		      bne	.pht
      0  2613					      pfalse
      1  2613		       a9 00		      lda	#$00
      2  2615					      IF	!FPUSH
      3  2615		       48		      pha
      4  2616					      ENDIF
      9  2616		       f0 03		      beq	.q
      0  2618				   .pht       ptrue
      1  2618		       a9 ff		      lda	#$FF
      2  261a					      IF	!FPUSH
      3  261a		       48		      pha
      4  261b					      ENDIF
     11  261b				   .q
   1759  261b				   FPULL      SET	0
      0  261b					      pwordvar	V_src2.draw_level_.r
      1  261b					      IF	!FPUSH
      2  261b		       ad 90 34 	      lda	V_src2.draw_level_.r
      3  261e		       48		      pha
      4  261f		       ad 91 34 	      lda	V_src2.draw_level_.r+1
      5  2622		       48		      pha
      6  2623				  -	      ELSE
      7  2623				  -	      lda	V_src2.draw_level_.r
      8  2623				  -	      ldy	V_src2.draw_level_.r+1
      9  2623					      ENDIF
      0  2623					      pbyte	22
      1  2623		       a9 16		      lda	#22
      2  2625					      IF	!FPUSH
      3  2625		       48		      pha
      4  2626					      ENDIF
      0  2626					      F_cword_byte
      1  2626		       a9 00		      lda	#$00
      2  2628		       48		      pha
      0  2629					      subword
      1  2629		       ba		      tsx
      2  262a		       bd 04 01 	      lda.wx	stack + 4
      3  262d		       38		      sec
      4  262e		       fd 02 01 	      sbc.wx	stack + 2
      5  2631		       9d 04 01 	      sta.wx	stack + 4
      6  2634		       bd 03 01 	      lda.wx	stack + 3
      7  2637		       fd 01 01 	      sbc.wx	stack + 1
      8  263a		       9d 03 01 	      sta.wx	stack + 3
      9  263d		       e8		      inx
     10  263e		       e8		      inx
     11  263f		       9a		      txs
      0  2640					      F_peek_word
      1  2640					      IF	!FPULL
      2  2640		       68		      pla
      3  2641		       8d 4a 26 	      sta	.l + 2
      4  2644		       68		      pla
      5  2645		       8d 49 26 	      sta	.l + 1
      6  2648				  -	      ELSE
      7  2648				  -	      sta	.l + 1
      8  2648				  -	      sty	.l + 2
      9  2648					      ENDIF
     10  2648		       ad ff ff    .l	      lda	$FFFF
     11  264b					      IF	!FPUSH
     12  264b		       48		      pha
     13  264c					      ENDIF
   1765  264c				   FPUSH      SET	1
      0  264c					      pbyte	62
      1  264c		       a9 3e		      lda	#62
      2  264e				  -	      IF	!FPUSH
      3  264e				  -	      pha
      4  264e					      ENDIF
   1767  264e				   FPULL      SET	1
      0  264e					      cmpbyteneq
      1  264e				  -	      IF	!FPULL
      2  264e				  -	      pla
      3  264e					      ENDIF
      4  264e		       85 02		      sta	R0
      5  2650		       68		      pla
      6  2651		       c5 02		      cmp	R0
      7  2653		       d0 04		      bne	.pht
      0  2655					      pfalse
      1  2655		       a9 00		      lda	#$00
      2  2657				  -	      IF	!FPUSH
      3  2657				  -	      pha
      4  2657					      ENDIF
      9  2657		       f0 02		      beq	.q
      0  2659				   .pht       ptrue
      1  2659		       a9 ff		      lda	#$FF
      2  265b				  -	      IF	!FPUSH
      3  265b				  -	      pha
      4  265b					      ENDIF
     11  265b				   .q
   1769  265b				   FPUSH      SET	0
      0  265b					      orbyte
      1  265b				  -	      IF	!FPULL
      2  265b				  -	      pla
      3  265b					      ENDIF
      4  265b		       85 02		      sta	R0
      5  265d		       68		      pla
      6  265e		       05 02		      ora	R0
      7  2660					      IF	!FPUSH
      8  2660		       48		      pha
      9  2661					      ENDIF
   1771  2661				   FPULL      SET	0
   1772  2661				   FPUSH      SET	1
      0  2661					      pwordvar_pbyte_F_cword_byte_addword	V_src2.draw_level_.r, 1
      0  2661					      pintvar_pint_addint	V_src2.draw_level_.r, 1
      1  2661		       ad 90 34 	      lda	V_src2.draw_level_.r
      2  2664		       18		      clc
      3  2665		       69 01		      adc	#<1
      4  2667				  -	      IF	!FPUSH
      5  2667				  -	      pha
      6  2667					      ELSE
      7  2667		       aa		      tax
      8  2668					      ENDIF
      9  2668		       ad 91 34 	      lda	V_src2.draw_level_.r + 1
     10  266b		       69 00		      adc	#>1
     11  266d				  -	      IF	!FPUSH
     12  266d				  -	      pha
     13  266d					      ELSE
     14  266d		       a8		      tay
     15  266e		       8a		      txa
     16  266f					      ENDIF
   1774  266f				   FPULL      SET	1
   1775  266f				   FPUSH      SET	0
      0  266f					      F_peek_word
      1  266f				  -	      IF	!FPULL
      2  266f				  -	      pla
      3  266f				  -	      sta	.l + 2
      4  266f				  -	      pla
      5  266f				  -	      sta	.l + 1
      6  266f					      ELSE
      7  266f		       8d 76 26 	      sta	.l + 1
      8  2672		       8c 77 26 	      sty	.l + 2
      9  2675					      ENDIF
     10  2675		       ad ff ff    .l	      lda	$FFFF
     11  2678					      IF	!FPUSH
     12  2678		       48		      pha
     13  2679					      ENDIF
   1777  2679				   FPULL      SET	0
   1778  2679				   FPUSH      SET	1
      0  2679					      pbyte	62
      1  2679		       a9 3e		      lda	#62
      2  267b				  -	      IF	!FPUSH
      3  267b				  -	      pha
      4  267b					      ENDIF
   1780  267b				   FPULL      SET	1
      0  267b					      cmpbyteeq
      1  267b				  -	      IF	!FPULL
      2  267b				  -	      pla
      3  267b					      ENDIF
      4  267b		       85 02		      sta	R0
      5  267d		       68		      pla
      6  267e		       c5 02		      cmp	R0
      7  2680		       f0 04		      beq	.pht
      0  2682					      pfalse
      1  2682		       a9 00		      lda	#$00
      2  2684				  -	      IF	!FPUSH
      3  2684				  -	      pha
      4  2684					      ENDIF
      9  2684		       f0 02		      beq	.q
      0  2686				   .pht       ptrue
      1  2686		       a9 ff		      lda	#$FF
      2  2688				  -	      IF	!FPUSH
      3  2688				  -	      pha
      4  2688					      ENDIF
     11  2688				   .q
   1782  2688				   FPUSH      SET	0
      0  2688					      orbyte
      1  2688				  -	      IF	!FPULL
      2  2688				  -	      pla
      3  2688					      ENDIF
      4  2688		       85 02		      sta	R0
      5  268a		       68		      pla
      6  268b		       05 02		      ora	R0
      7  268d					      IF	!FPUSH
      8  268d		       48		      pha
      9  268e					      ENDIF
   1784  268e				   FPULL      SET	0
      0  268e					      pwordvar	V_src2.draw_level_.r
      1  268e					      IF	!FPUSH
      2  268e		       ad 90 34 	      lda	V_src2.draw_level_.r
      3  2691		       48		      pha
      4  2692		       ad 91 34 	      lda	V_src2.draw_level_.r+1
      5  2695		       48		      pha
      6  2696				  -	      ELSE
      7  2696				  -	      lda	V_src2.draw_level_.r
      8  2696				  -	      ldy	V_src2.draw_level_.r+1
      9  2696					      ENDIF
      0  2696					      pbyte	1
      1  2696		       a9 01		      lda	#1
      2  2698					      IF	!FPUSH
      3  2698		       48		      pha
      4  2699					      ENDIF
      0  2699					      F_cword_byte
      1  2699		       a9 00		      lda	#$00
      2  269b		       48		      pha
      0  269c					      subword
      1  269c		       ba		      tsx
      2  269d		       bd 04 01 	      lda.wx	stack + 4
      3  26a0		       38		      sec
      4  26a1		       fd 02 01 	      sbc.wx	stack + 2
      5  26a4		       9d 04 01 	      sta.wx	stack + 4
      6  26a7		       bd 03 01 	      lda.wx	stack + 3
      7  26aa		       fd 01 01 	      sbc.wx	stack + 1
      8  26ad		       9d 03 01 	      sta.wx	stack + 3
      9  26b0		       e8		      inx
     10  26b1		       e8		      inx
     11  26b2		       9a		      txs
      0  26b3					      F_peek_word
      1  26b3					      IF	!FPULL
      2  26b3		       68		      pla
      3  26b4		       8d bd 26 	      sta	.l + 2
      4  26b7		       68		      pla
      5  26b8		       8d bc 26 	      sta	.l + 1
      6  26bb				  -	      ELSE
      7  26bb				  -	      sta	.l + 1
      8  26bb				  -	      sty	.l + 2
      9  26bb					      ENDIF
     10  26bb		       ad ff ff    .l	      lda	$FFFF
     11  26be					      IF	!FPUSH
     12  26be		       48		      pha
     13  26bf					      ENDIF
   1790  26bf				   FPUSH      SET	1
      0  26bf					      pbyte	62
      1  26bf		       a9 3e		      lda	#62
      2  26c1				  -	      IF	!FPUSH
      3  26c1				  -	      pha
      4  26c1					      ENDIF
   1792  26c1				   FPULL      SET	1
      0  26c1					      cmpbyteeq
      1  26c1				  -	      IF	!FPULL
      2  26c1				  -	      pla
      3  26c1					      ENDIF
      4  26c1		       85 02		      sta	R0
      5  26c3		       68		      pla
      6  26c4		       c5 02		      cmp	R0
      7  26c6		       f0 04		      beq	.pht
      0  26c8					      pfalse
      1  26c8		       a9 00		      lda	#$00
      2  26ca				  -	      IF	!FPUSH
      3  26ca				  -	      pha
      4  26ca					      ENDIF
      9  26ca		       f0 02		      beq	.q
      0  26cc				   .pht       ptrue
      1  26cc		       a9 ff		      lda	#$FF
      2  26ce				  -	      IF	!FPUSH
      3  26ce				  -	      pha
      4  26ce					      ENDIF
     11  26ce				   .q
      0  26ce					      orbyte
      1  26ce				  -	      IF	!FPULL
      2  26ce				  -	      pla
      3  26ce					      ENDIF
      4  26ce		       85 02		      sta	R0
      5  26d0		       68		      pla
      6  26d1		       05 02		      ora	R0
      7  26d3				  -	      IF	!FPUSH
      8  26d3				  -	      pha
      9  26d3					      ENDIF
   1795  26d3				   FPUSH      SET	0
      0  26d3					      cond_stmt	_ED_31, $10000
      1  26d3				  -	      IF	!FPULL
      2  26d3				  -	      pla
      3  26d3					      ENDIF
      4  26d3		       d0 03		      bne	* + 5
      5  26d5				  -	      IF	$10000 > 0 && $10000 < $10000
      6  26d5				  -	      jmp	$10000
      7  26d5					      ELSE
      8  26d5		       4c db 26 	      jmp	_ED_31
      9  26d8					      ENDIF
   1797  26d8		       4c ab 25 	      jmp	_DO_31
   1798  26db				   _ED_31
   1799  26db				   FPULL      SET	0
      0  26db					      pbyte	62
      1  26db		       a9 3e		      lda	#62
      2  26dd					      IF	!FPUSH
      3  26dd		       48		      pha
      4  26de					      ENDIF
   1801  26de				   FPUSH      SET	1
      0  26de					      pwordvar	V_src2.draw_level_.r
      1  26de				  -	      IF	!FPUSH
      2  26de				  -	      lda	V_src2.draw_level_.r
      3  26de				  -	      pha
      4  26de				  -	      lda	V_src2.draw_level_.r+1
      5  26de				  -	      pha
      6  26de					      ELSE
      7  26de		       ad 90 34 	      lda	V_src2.draw_level_.r
      8  26e1		       ac 91 34 	      ldy	V_src2.draw_level_.r+1
      9  26e4					      ENDIF
   1803  26e4				   FPULL      SET	1
   1804  26e4				   FPUSH      SET	0
      0  26e4					      poke
      1  26e4				  -	      IF	!FPULL
      2  26e4				  -	      pla
      3  26e4				  -	      sta	.l + 2
      4  26e4				  -	      pla
      5  26e4				  -	      sta	.l + 1
      6  26e4					      ELSE
      7  26e4		       8d ec 26 	      sta	.l + 1
      8  26e7		       8c ed 26 	      sty	.l + 2
      9  26ea					      ENDIF
     10  26ea		       68		      pla
     11  26eb		       8d ff ff    .l	      sta	$ffff
   1806  26eb				   FPULL      SET	0
      0  26ee					      pbyte	63
      1  26ee		       a9 3f		      lda	#63
      2  26f0					      IF	!FPUSH
      3  26f0		       48		      pha
      4  26f1					      ENDIF
      0  26f1					      pwordvar	V_src2.draw_level_.r
      1  26f1					      IF	!FPUSH
      2  26f1		       ad 90 34 	      lda	V_src2.draw_level_.r
      3  26f4		       48		      pha
      4  26f5		       ad 91 34 	      lda	V_src2.draw_level_.r+1
      5  26f8		       48		      pha
      6  26f9				  -	      ELSE
      7  26f9				  -	      lda	V_src2.draw_level_.r
      8  26f9				  -	      ldy	V_src2.draw_level_.r+1
      9  26f9					      ENDIF
      0  26f9					      pbyte	22
      1  26f9		       a9 16		      lda	#22
      2  26fb					      IF	!FPUSH
      3  26fb		       48		      pha
      4  26fc					      ENDIF
      0  26fc					      F_cword_byte
      1  26fc		       a9 00		      lda	#$00
      2  26fe		       48		      pha
      0  26ff					      subword
      1  26ff		       ba		      tsx
      2  2700		       bd 04 01 	      lda.wx	stack + 4
      3  2703		       38		      sec
      4  2704		       fd 02 01 	      sbc.wx	stack + 2
      5  2707		       9d 04 01 	      sta.wx	stack + 4
      6  270a		       bd 03 01 	      lda.wx	stack + 3
      7  270d		       fd 01 01 	      sbc.wx	stack + 1
      8  2710		       9d 03 01 	      sta.wx	stack + 3
      9  2713		       e8		      inx
     10  2714		       e8		      inx
     11  2715		       9a		      txs
      0  2716					      poke
      1  2716					      IF	!FPULL
      2  2716		       68		      pla
      3  2717		       8d 21 27 	      sta	.l + 2
      4  271a		       68		      pla
      5  271b		       8d 20 27 	      sta	.l + 1
      6  271e				  -	      ELSE
      7  271e				  -	      sta	.l + 1
      8  271e				  -	      sty	.l + 2
      9  271e					      ENDIF
     10  271e		       68		      pla
     11  271f		       8d ff ff    .l	      sta	$ffff
   1813  2722				   _CO_30
      0  2722					      nextbyte	30, V_src2.o, "_void_"
      1  2722
      2  2722				  -	      IFCONST	"_void_"
      3  2722				  -
      4  2722				  -	      clc
      5  2722				  -	      lda	"_void_"
      6  2722				  -	      adc	V_src2.o
      7  2722				  -	      sta	V_src2.o
      8  2722				  -
      9  2722				  -	      bcs	_ENDFOR_30
     10  2722					      ELSE
     11  2722
     12  2722		       ee 71 34 	      inc	V_src2.o
     13  2725
     14  2725		       f0 03		      beq	_ENDFOR_30
     15  2727					      ENDIF
     16  2727		       4c a0 25 	      jmp	_FOR_30
   1815  272a
   1816  272a
   1817  272a
   1818  272a				   _ENDFOR_30
   1819  272a				   FPUSH      SET	1
      0  272a					      pbyte	1
      1  272a		       a9 01		      lda	#1
      2  272c				  -	      IF	!FPUSH
      3  272c				  -	      pha
      4  272c					      ENDIF
   1821  272c				   FPULL      SET	1
   1822  272c				   FPUSH      SET	0
      0  272c					      plbytevar	V_src2.o
      1  272c				  -	      IF	!FPULL
      2  272c				  -	      pla
      3  272c					      ENDIF
      4  272c		       8d 71 34 	      sta	V_src2.o
   1824  272f				   _FOR_32
      0  272f					      forbyte	32, V_src2.o, 4, "_void_", 1
      1  272f
      2  272f					      IF	1 == 1
      3  272f		       a9 04		      lda	#4
      4  2731				  -	      ELSE
      5  2731				  -	      lda	4
      6  2731					      ENDIF
      7  2731		       cd 71 34 	      cmp	V_src2.o
      8  2734		       b0 03		      bcs	.enter
      9  2736
     10  2736		       4c 40 28 	      jmp	_ENDFOR_32
     11  2739				   .enter
   1826  2739
   1827  2739
   1828  2739
   1829  2739				   _DO_33
   1830  2739				   FPULL      SET	0
      0  2739					      pwordvar	V_src2.n
      1  2739					      IF	!FPUSH
      2  2739		       ad 6d 34 	      lda	V_src2.n
      3  273c		       48		      pha
      4  273d		       ad 6e 34 	      lda	V_src2.n+1
      5  2740		       48		      pha
      6  2741				  -	      ELSE
      7  2741				  -	      lda	V_src2.n
      8  2741				  -	      ldy	V_src2.n+1
      9  2741					      ENDIF
      0  2741					      pbyte	21
      1  2741		       a9 15		      lda	#21
      2  2743					      IF	!FPUSH
      3  2743		       48		      pha
      4  2744					      ENDIF
      0  2744					      F_cword_byte
      1  2744		       a9 00		      lda	#$00
      2  2746		       48		      pha
      0  2747					      subword
      1  2747		       ba		      tsx
      2  2748		       bd 04 01 	      lda.wx	stack + 4
      3  274b		       38		      sec
      4  274c		       fd 02 01 	      sbc.wx	stack + 2
      5  274f		       9d 04 01 	      sta.wx	stack + 4
      6  2752		       bd 03 01 	      lda.wx	stack + 3
      7  2755		       fd 01 01 	      sbc.wx	stack + 1
      8  2758		       9d 03 01 	      sta.wx	stack + 3
      9  275b		       e8		      inx
     10  275c		       e8		      inx
     11  275d		       9a		      txs
      0  275e					      pbyte	20
      1  275e		       a9 14		      lda	#20
      2  2760					      IF	!FPUSH
      3  2760		       48		      pha
      4  2761					      ENDIF
      0  2761					      F_cword_byte
      1  2761		       a9 00		      lda	#$00
      2  2763		       48		      pha
      0  2764					      plwordvar	V_src2.random_word_word.limit
      1  2764					      IF	!FPULL
      2  2764		       68		      pla
      3  2765		       8d 49 34 	      sta	V_src2.random_word_word.limit+1
      4  2768		       68		      pla
      5  2769		       8d 48 34 	      sta	V_src2.random_word_word.limit
      6  276c				  -	      ELSE
      7  276c				  -	      sta	V_src2.random_word_word.limit
      8  276c				  -	      sty	V_src2.random_word_word.limit+1
      9  276c					      ENDIF
      0  276c					      pbyte	31
      1  276c		       a9 1f		      lda	#31
      2  276e					      IF	!FPUSH
      3  276e		       48		      pha
      4  276f					      ENDIF
      0  276f					      F_cword_byte
      1  276f		       a9 00		      lda	#$00
      2  2771		       48		      pha
      0  2772					      plwordvar	V_src2.random_word_word.mask
      1  2772					      IF	!FPULL
      2  2772		       68		      pla
      3  2773		       8d 4b 34 	      sta	V_src2.random_word_word.mask+1
      4  2776		       68		      pla
      5  2777		       8d 4a 34 	      sta	V_src2.random_word_word.mask
      6  277a				  -	      ELSE
      7  277a				  -	      sta	V_src2.random_word_word.mask
      8  277a				  -	      sty	V_src2.random_word_word.mask+1
      9  277a					      ENDIF
      0  277a					      import	I_F_src2.random_word_word
      1  277a				   I_F_src2.random_word_word_IMPORTED SET	1
   1842  277a		       20 62 2b 	      jsr	F_src2.random_word_word
      0  277d					      pwordvar	V_src2.random_word_word.random
      1  277d					      IF	!FPUSH
      2  277d		       ad 4c 34 	      lda	V_src2.random_word_word.random
      3  2780		       48		      pha
      4  2781		       ad 4d 34 	      lda	V_src2.random_word_word.random+1
      5  2784		       48		      pha
      6  2785				  -	      ELSE
      7  2785				  -	      lda	V_src2.random_word_word.random
      8  2785				  -	      ldy	V_src2.random_word_word.random+1
      9  2785					      ENDIF
      0  2785					      addword
      1  2785		       ba		      tsx
      2  2786		       bd 02 01 	      lda.wx	stack + 2
      3  2789		       18		      clc
      4  278a		       7d 04 01 	      adc.wx	stack + 4
      5  278d		       9d 04 01 	      sta.wx	stack + 4
      6  2790		       68		      pla
      7  2791		       7d 03 01 	      adc.wx	stack + 3
      8  2794		       9d 03 01 	      sta.wx	stack + 3
      9  2797		       68		      pla
      0  2798					      plwordvar	V_src2.draw_level_.r
      1  2798					      IF	!FPULL
      2  2798		       68		      pla
      3  2799		       8d 91 34 	      sta	V_src2.draw_level_.r+1
      4  279c		       68		      pla
      5  279d		       8d 90 34 	      sta	V_src2.draw_level_.r
      6  27a0				  -	      ELSE
      7  27a0				  -	      sta	V_src2.draw_level_.r
      8  27a0				  -	      sty	V_src2.draw_level_.r+1
      9  27a0					      ENDIF
   1846  27a0				   _CO_33
   1847  27a0				   FPUSH      SET	1
      0  27a0					      pwordvar	V_src2.draw_level_.r
      1  27a0				  -	      IF	!FPUSH
      2  27a0				  -	      lda	V_src2.draw_level_.r
      3  27a0				  -	      pha
      4  27a0				  -	      lda	V_src2.draw_level_.r+1
      5  27a0				  -	      pha
      6  27a0					      ELSE
      7  27a0		       ad 90 34 	      lda	V_src2.draw_level_.r
      8  27a3		       ac 91 34 	      ldy	V_src2.draw_level_.r+1
      9  27a6					      ENDIF
   1849  27a6				   FPULL      SET	1
   1850  27a6				   FPUSH      SET	0
      0  27a6					      F_peek_word
      1  27a6				  -	      IF	!FPULL
      2  27a6				  -	      pla
      3  27a6				  -	      sta	.l + 2
      4  27a6				  -	      pla
      5  27a6				  -	      sta	.l + 1
      6  27a6					      ELSE
      7  27a6		       8d ad 27 	      sta	.l + 1
      8  27a9		       8c ae 27 	      sty	.l + 2
      9  27ac					      ENDIF
     10  27ac		       ad ff ff    .l	      lda	$FFFF
     11  27af					      IF	!FPUSH
     12  27af		       48		      pha
     13  27b0					      ENDIF
   1852  27b0				   FPULL      SET	0
   1853  27b0				   FPUSH      SET	1
      0  27b0					      pbyte	62
      1  27b0		       a9 3e		      lda	#62
      2  27b2				  -	      IF	!FPUSH
      3  27b2				  -	      pha
      4  27b2					      ENDIF
   1855  27b2				   FPULL      SET	1
   1856  27b2				   FPUSH      SET	0
      0  27b2					      cmpbyteneq
      1  27b2				  -	      IF	!FPULL
      2  27b2				  -	      pla
      3  27b2					      ENDIF
      4  27b2		       85 02		      sta	R0
      5  27b4		       68		      pla
      6  27b5		       c5 02		      cmp	R0
      7  27b7		       d0 05		      bne	.pht
      0  27b9					      pfalse
      1  27b9		       a9 00		      lda	#$00
      2  27bb					      IF	!FPUSH
      3  27bb		       48		      pha
      4  27bc					      ENDIF
      9  27bc		       f0 03		      beq	.q
      0  27be				   .pht       ptrue
      1  27be		       a9 ff		      lda	#$FF
      2  27c0					      IF	!FPUSH
      3  27c0		       48		      pha
      4  27c1					      ENDIF
     11  27c1				   .q
   1858  27c1				   FPULL      SET	0
   1859  27c1				   FPUSH      SET	1
      0  27c1					      pwordvar_pbyte_F_cword_byte_addword	V_src2.draw_level_.r, 22
      0  27c1					      pintvar_pint_addint	V_src2.draw_level_.r, 22
      1  27c1		       ad 90 34 	      lda	V_src2.draw_level_.r
      2  27c4		       18		      clc
      3  27c5		       69 16		      adc	#<22
      4  27c7				  -	      IF	!FPUSH
      5  27c7				  -	      pha
      6  27c7					      ELSE
      7  27c7		       aa		      tax
      8  27c8					      ENDIF
      9  27c8		       ad 91 34 	      lda	V_src2.draw_level_.r + 1
     10  27cb		       69 00		      adc	#>22
     11  27cd				  -	      IF	!FPUSH
     12  27cd				  -	      pha
     13  27cd					      ELSE
     14  27cd		       a8		      tay
     15  27ce		       8a		      txa
     16  27cf					      ENDIF
   1861  27cf				   FPULL      SET	1
   1862  27cf				   FPUSH      SET	0
      0  27cf					      F_peek_word
      1  27cf				  -	      IF	!FPULL
      2  27cf				  -	      pla
      3  27cf				  -	      sta	.l + 2
      4  27cf				  -	      pla
      5  27cf				  -	      sta	.l + 1
      6  27cf					      ELSE
      7  27cf		       8d d6 27 	      sta	.l + 1
      8  27d2		       8c d7 27 	      sty	.l + 2
      9  27d5					      ENDIF
     10  27d5		       ad ff ff    .l	      lda	$FFFF
     11  27d8					      IF	!FPUSH
     12  27d8		       48		      pha
     13  27d9					      ENDIF
   1864  27d9				   FPULL      SET	0
   1865  27d9				   FPUSH      SET	1
      0  27d9					      pbyte	62
      1  27d9		       a9 3e		      lda	#62
      2  27db				  -	      IF	!FPUSH
      3  27db				  -	      pha
      4  27db					      ENDIF
   1867  27db				   FPULL      SET	1
      0  27db					      cmpbyteeq
      1  27db				  -	      IF	!FPULL
      2  27db				  -	      pla
      3  27db					      ENDIF
      4  27db		       85 02		      sta	R0
      5  27dd		       68		      pla
      6  27de		       c5 02		      cmp	R0
      7  27e0		       f0 04		      beq	.pht
      0  27e2					      pfalse
      1  27e2		       a9 00		      lda	#$00
      2  27e4				  -	      IF	!FPUSH
      3  27e4				  -	      pha
      4  27e4					      ENDIF
      9  27e4		       f0 02		      beq	.q
      0  27e6				   .pht       ptrue
      1  27e6		       a9 ff		      lda	#$FF
      2  27e8				  -	      IF	!FPUSH
      3  27e8				  -	      pha
      4  27e8					      ENDIF
     11  27e8				   .q
      0  27e8					      orbyte
      1  27e8				  -	      IF	!FPULL
      2  27e8				  -	      pla
      3  27e8					      ENDIF
      4  27e8		       85 02		      sta	R0
      5  27ea		       68		      pla
      6  27eb		       05 02		      ora	R0
      7  27ed				  -	      IF	!FPUSH
      8  27ed				  -	      pha
      9  27ed					      ENDIF
   1870  27ed				   FPUSH      SET	0
      0  27ed					      cond_stmt	_ED_33, $10000
      1  27ed				  -	      IF	!FPULL
      2  27ed				  -	      pla
      3  27ed					      ENDIF
      4  27ed		       d0 03		      bne	* + 5
      5  27ef				  -	      IF	$10000 > 0 && $10000 < $10000
      6  27ef				  -	      jmp	$10000
      7  27ef					      ELSE
      8  27ef		       4c f5 27 	      jmp	_ED_33
      9  27f2					      ENDIF
   1872  27f2		       4c 39 27 	      jmp	_DO_33
   1873  27f5				   _ED_33
   1874  27f5				   FPULL      SET	0
      0  27f5					      pbyte	61
      1  27f5		       a9 3d		      lda	#61
      2  27f7					      IF	!FPUSH
      3  27f7		       48		      pha
      4  27f8					      ENDIF
   1876  27f8				   FPUSH      SET	1
      0  27f8					      pwordvar	V_src2.draw_level_.r
      1  27f8				  -	      IF	!FPUSH
      2  27f8				  -	      lda	V_src2.draw_level_.r
      3  27f8				  -	      pha
      4  27f8				  -	      lda	V_src2.draw_level_.r+1
      5  27f8				  -	      pha
      6  27f8					      ELSE
      7  27f8		       ad 90 34 	      lda	V_src2.draw_level_.r
      8  27fb		       ac 91 34 	      ldy	V_src2.draw_level_.r+1
      9  27fe					      ENDIF
   1878  27fe				   FPULL      SET	1
   1879  27fe				   FPUSH      SET	0
      0  27fe					      poke
      1  27fe				  -	      IF	!FPULL
      2  27fe				  -	      pla
      3  27fe				  -	      sta	.l + 2
      4  27fe				  -	      pla
      5  27fe				  -	      sta	.l + 1
      6  27fe					      ELSE
      7  27fe		       8d 06 28 	      sta	.l + 1
      8  2801		       8c 07 28 	      sty	.l + 2
      9  2804					      ENDIF
     10  2804		       68		      pla
     11  2805		       8d ff ff    .l	      sta	$ffff
   1881  2805				   FPULL      SET	0
      0  2808					      pbyte	0
      1  2808		       a9 00		      lda	#0
      2  280a					      IF	!FPUSH
      3  280a		       48		      pha
      4  280b					      ENDIF
      0  280b					      pwordvar	V_src2.draw_level_.r
      1  280b					      IF	!FPUSH
      2  280b		       ad 90 34 	      lda	V_src2.draw_level_.r
      3  280e		       48		      pha
      4  280f		       ad 91 34 	      lda	V_src2.draw_level_.r+1
      5  2812		       48		      pha
      6  2813				  -	      ELSE
      7  2813				  -	      lda	V_src2.draw_level_.r
      8  2813				  -	      ldy	V_src2.draw_level_.r+1
      9  2813					      ENDIF
      0  2813					      F_cint_word
      0  2813					      pint	30720
      0  2813					      pword	30720
      1  2813					      IF	!FPUSH
      2  2813		       a9 00		      lda	#<30720
      3  2815		       48		      pha
      4  2816		       a9 78		      lda	#>30720
      5  2818		       48		      pha
      6  2819				  -	      ELSE
      7  2819				  -	      lda	#<30720
      8  2819				  -	      ldy	#>30720
      9  2819					      ENDIF
      0  2819					      addint
      0  2819					      addword
      1  2819		       ba		      tsx
      2  281a		       bd 02 01 	      lda.wx	stack + 2
      3  281d		       18		      clc
      4  281e		       7d 04 01 	      adc.wx	stack + 4
      5  2821		       9d 04 01 	      sta.wx	stack + 4
      6  2824		       68		      pla
      7  2825		       7d 03 01 	      adc.wx	stack + 3
      8  2828		       9d 03 01 	      sta.wx	stack + 3
      9  282b		       68		      pla
      0  282c					      F_cword_int
      0  282c					      poke
      1  282c					      IF	!FPULL
      2  282c		       68		      pla
      3  282d		       8d 37 28 	      sta	.l + 2
      4  2830		       68		      pla
      5  2831		       8d 36 28 	      sta	.l + 1
      6  2834				  -	      ELSE
      7  2834				  -	      sta	.l + 1
      8  2834				  -	      sty	.l + 2
      9  2834					      ENDIF
     10  2834		       68		      pla
     11  2835		       8d ff ff    .l	      sta	$ffff
   1889  2838				   _CO_32
      0  2838					      nextbyte	32, V_src2.o, "_void_"
      1  2838
      2  2838				  -	      IFCONST	"_void_"
      3  2838				  -
      4  2838				  -	      clc
      5  2838				  -	      lda	"_void_"
      6  2838				  -	      adc	V_src2.o
      7  2838				  -	      sta	V_src2.o
      8  2838				  -
      9  2838				  -	      bcs	_ENDFOR_32
     10  2838					      ELSE
     11  2838
     12  2838		       ee 71 34 	      inc	V_src2.o
     13  283b
     14  283b		       f0 03		      beq	_ENDFOR_32
     15  283d					      ENDIF
     16  283d		       4c 2f 27 	      jmp	_FOR_32
   1891  2840
   1892  2840
   1893  2840
   1894  2840				   _ENDFOR_32
   1895  2840
   1896  2840
   1897  2840
   1898  2840				   _CO_24
      0  2840					      nextword	24, V_src2.n, V_src2.draw_level_.forstep24
      1  2840
      2  2840					      IFCONST	V_src2.draw_level_.forstep24
      3  2840
      4  2840		       18		      clc
      5  2841		       ad a9 34 	      lda	V_src2.draw_level_.forstep24
      6  2844		       6d 6d 34 	      adc	V_src2.n
      7  2847		       8d 6d 34 	      sta	V_src2.n
      8  284a		       ad aa 34 	      lda	V_src2.draw_level_.forstep24 + 1
      9  284d		       6d 6e 34 	      adc	V_src2.n + 1
     10  2850		       8d 6e 34 	      sta	V_src2.n + 1
     11  2853
     12  2853		       b0 03		      bcs	_ENDFOR_24
     13  2855				  -	      ELSE
     14  2855				  -
     15  2855				  -	      inc	V_src2.n
     16  2855				  -	      bne	.skip
     17  2855				  -	      inc	V_src2.n + 1
     18  2855				  -
     19  2855				  -	      beq	_ENDFOR_24
     20  2855				  -.skip
     21  2855					      ENDIF
     22  2855		       4c ce 22 	      jmp	_FOR_24
   1900  2858
   1901  2858
   1902  2858
   1903  2858				   _ENDFOR_24
   1904  2858				   FPUSH      SET	1
      0  2858					      pbyte	63
      1  2858		       a9 3f		      lda	#63
      2  285a				  -	      IF	!FPUSH
      3  285a				  -	      pha
      4  285a					      ENDIF
   1906  285a				   FPULL      SET	1
   1907  285a				   FPUSH      SET	0
      0  285a					      poke_constaddr	$1E1E
      1  285a				  -	      IF	!FPULL
      2  285a				  -	      pla
      3  285a					      ENDIF
      4  285a		       8d 1e 1e 	      sta	$1E1E
   1909  285a				   FPULL      SET	0
   1910  285a				   FPUSH      SET	1
      0  285d					      pbyte	63
      1  285d		       a9 3f		      lda	#63
      2  285f				  -	      IF	!FPUSH
      3  285f				  -	      pha
      4  285f					      ENDIF
   1912  285f				   FPULL      SET	1
   1913  285f				   FPUSH      SET	0
      0  285f					      poke_constaddr	$1E23
      1  285f				  -	      IF	!FPULL
      2  285f				  -	      pla
      3  285f					      ENDIF
      4  285f		       8d 23 1e 	      sta	$1E23
   1915  285f				   FPULL      SET	0
   1916  285f				   FPUSH      SET	1
      0  2862					      pbyte	63
      1  2862		       a9 3f		      lda	#63
      2  2864				  -	      IF	!FPUSH
      3  2864				  -	      pha
      4  2864					      ENDIF
   1918  2864				   FPULL      SET	1
   1919  2864				   FPUSH      SET	0
      0  2864					      poke_constaddr	$1E33
      1  2864				  -	      IF	!FPULL
      2  2864				  -	      pla
      3  2864					      ENDIF
      4  2864		       8d 33 1e 	      sta	$1E33
   1921  2864				   FPULL      SET	0
   1922  2864				   FPUSH      SET	1
      0  2867					      pbyte	63
      1  2867		       a9 3f		      lda	#63
      2  2869				  -	      IF	!FPUSH
      3  2869				  -	      pha
      4  2869					      ENDIF
   1924  2869				   FPULL      SET	1
   1925  2869				   FPUSH      SET	0
      0  2869					      poke_constaddr	$1E3A
      1  2869				  -	      IF	!FPULL
      2  2869				  -	      pla
      3  2869					      ENDIF
      4  2869		       8d 3a 1e 	      sta	$1E3A
   1927  2869				   FPULL      SET	0
      0  286c					      pint	7812
      0  286c					      pword	7812
      1  286c					      IF	!FPUSH
      2  286c		       a9 84		      lda	#<7812
      3  286e		       48		      pha
      4  286f		       a9 1e		      lda	#>7812
      5  2871		       48		      pha
      6  2872				  -	      ELSE
      7  2872				  -	      lda	#<7812
      8  2872				  -	      ldy	#>7812
      9  2872					      ENDIF
      0  2872					      F_cword_int
      0  2872					      plwordvar	V_src2.n
      1  2872					      IF	!FPULL
      2  2872		       68		      pla
      3  2873		       8d 6e 34 	      sta	V_src2.n+1
      4  2876		       68		      pla
      5  2877		       8d 6d 34 	      sta	V_src2.n
      6  287a				  -	      ELSE
      7  287a				  -	      sta	V_src2.n
      8  287a				  -	      sty	V_src2.n+1
      9  287a					      ENDIF
      0  287a					      pbyte	110
      1  287a		       a9 6e		      lda	#110
      2  287c					      IF	!FPUSH
      3  287c		       48		      pha
      4  287d					      ENDIF
      0  287d					      F_cword_byte
      1  287d		       a9 00		      lda	#$00
      2  287f		       48		      pha
      0  2880					      plwordvar	V_src2.draw_level_.forstep34
      1  2880					      IF	!FPULL
      2  2880		       68		      pla
      3  2881		       8d af 34 	      sta	V_src2.draw_level_.forstep34+1
      4  2884		       68		      pla
      5  2885		       8d ae 34 	      sta	V_src2.draw_level_.forstep34
      6  2888				  -	      ELSE
      7  2888				  -	      sta	V_src2.draw_level_.forstep34
      8  2888				  -	      sty	V_src2.draw_level_.forstep34+1
      9  2888					      ENDIF
   1934  2888				   _FOR_34
      0  2888					      forword	34, V_src2.n, 8142, V_src2.draw_level_.forstep34, 1
      1  2888
      2  2888					      IF	1 == 1
      3  2888		       a9 ce		      lda	#<8142
      4  288a		       cd 6d 34 	      cmp	V_src2.n
      5  288d		       a9 1f		      lda	#>8142
      6  288f		       ed 6e 34 	      sbc	V_src2.n + 1
      7  2892				  -	      ELSE
      8  2892				  -	      lda	8142
      9  2892				  -	      cmp	V_src2.n
     10  2892				  -	      lda	8142 + 1
     11  2892				  -	      sbc	V_src2.n + 1
     12  2892					      ENDIF
     13  2892		       b0 03		      bcs	.enter
     14  2894		       4c c2 28 	      jmp	_ENDFOR_34
     15  2897				   .enter
      0  2897					      pbyte	63
      1  2897		       a9 3f		      lda	#63
      2  2899					      IF	!FPUSH
      3  2899		       48		      pha
      4  289a					      ENDIF
   1937  289a				   FPUSH      SET	1
      0  289a					      pwordvar	V_src2.n
      1  289a				  -	      IF	!FPUSH
      2  289a				  -	      lda	V_src2.n
      3  289a				  -	      pha
      4  289a				  -	      lda	V_src2.n+1
      5  289a				  -	      pha
      6  289a					      ELSE
      7  289a		       ad 6d 34 	      lda	V_src2.n
      8  289d		       ac 6e 34 	      ldy	V_src2.n+1
      9  28a0					      ENDIF
   1939  28a0				   FPULL      SET	1
   1940  28a0				   FPUSH      SET	0
      0  28a0					      poke
      1  28a0				  -	      IF	!FPULL
      2  28a0				  -	      pla
      3  28a0				  -	      sta	.l + 2
      4  28a0				  -	      pla
      5  28a0				  -	      sta	.l + 1
      6  28a0					      ELSE
      7  28a0		       8d a8 28 	      sta	.l + 1
      8  28a3		       8c a9 28 	      sty	.l + 2
      9  28a6					      ENDIF
     10  28a6		       68		      pla
     11  28a7		       8d ff ff    .l	      sta	$ffff
   1942  28aa				   _CO_34
      0  28aa					      nextword	34, V_src2.n, V_src2.draw_level_.forstep34
      1  28aa
      2  28aa					      IFCONST	V_src2.draw_level_.forstep34
      3  28aa
      4  28aa		       18		      clc
      5  28ab		       ad ae 34 	      lda	V_src2.draw_level_.forstep34
      6  28ae		       6d 6d 34 	      adc	V_src2.n
      7  28b1		       8d 6d 34 	      sta	V_src2.n
      8  28b4		       ad af 34 	      lda	V_src2.draw_level_.forstep34 + 1
      9  28b7		       6d 6e 34 	      adc	V_src2.n + 1
     10  28ba		       8d 6e 34 	      sta	V_src2.n + 1
     11  28bd
     12  28bd		       b0 03		      bcs	_ENDFOR_34
     13  28bf				  -	      ELSE
     14  28bf				  -
     15  28bf				  -	      inc	V_src2.n
     16  28bf				  -	      bne	.skip
     17  28bf				  -	      inc	V_src2.n + 1
     18  28bf				  -
     19  28bf				  -	      beq	_ENDFOR_34
     20  28bf				  -.skip
     21  28bf					      ENDIF
     22  28bf		       4c 88 28 	      jmp	_FOR_34
   1944  28c2
   1945  28c2
   1946  28c2
   1947  28c2				   _ENDFOR_34
   1948  28c2				   FPULL      SET	0
      0  28c2					      pint	7833
      0  28c2					      pword	7833
      1  28c2					      IF	!FPUSH
      2  28c2		       a9 99		      lda	#<7833
      3  28c4		       48		      pha
      4  28c5		       a9 1e		      lda	#>7833
      5  28c7		       48		      pha
      6  28c8				  -	      ELSE
      7  28c8				  -	      lda	#<7833
      8  28c8				  -	      ldy	#>7833
      9  28c8					      ENDIF
      0  28c8					      F_cword_int
      0  28c8					      plwordvar	V_src2.n
      1  28c8					      IF	!FPULL
      2  28c8		       68		      pla
      3  28c9		       8d 6e 34 	      sta	V_src2.n+1
      4  28cc		       68		      pla
      5  28cd		       8d 6d 34 	      sta	V_src2.n
      6  28d0				  -	      ELSE
      7  28d0				  -	      sta	V_src2.n
      8  28d0				  -	      sty	V_src2.n+1
      9  28d0					      ENDIF
      0  28d0					      pbyte	110
      1  28d0		       a9 6e		      lda	#110
      2  28d2					      IF	!FPUSH
      3  28d2		       48		      pha
      4  28d3					      ENDIF
      0  28d3					      F_cword_byte
      1  28d3		       a9 00		      lda	#$00
      2  28d5		       48		      pha
      0  28d6					      plwordvar	V_src2.draw_level_.forstep35
      1  28d6					      IF	!FPULL
      2  28d6		       68		      pla
      3  28d7		       8d b1 34 	      sta	V_src2.draw_level_.forstep35+1
      4  28da		       68		      pla
      5  28db		       8d b0 34 	      sta	V_src2.draw_level_.forstep35
      6  28de				  -	      ELSE
      7  28de				  -	      sta	V_src2.draw_level_.forstep35
      8  28de				  -	      sty	V_src2.draw_level_.forstep35+1
      9  28de					      ENDIF
   1955  28de				   _FOR_35
      0  28de					      forword	35, V_src2.n, 8163, V_src2.draw_level_.forstep35, 1
      1  28de
      2  28de					      IF	1 == 1
      3  28de		       a9 e3		      lda	#<8163
      4  28e0		       cd 6d 34 	      cmp	V_src2.n
      5  28e3		       a9 1f		      lda	#>8163
      6  28e5		       ed 6e 34 	      sbc	V_src2.n + 1
      7  28e8				  -	      ELSE
      8  28e8				  -	      lda	8163
      9  28e8				  -	      cmp	V_src2.n
     10  28e8				  -	      lda	8163 + 1
     11  28e8				  -	      sbc	V_src2.n + 1
     12  28e8					      ENDIF
     13  28e8		       b0 03		      bcs	.enter
     14  28ea		       4c 18 29 	      jmp	_ENDFOR_35
     15  28ed				   .enter
      0  28ed					      pbyte	63
      1  28ed		       a9 3f		      lda	#63
      2  28ef					      IF	!FPUSH
      3  28ef		       48		      pha
      4  28f0					      ENDIF
   1958  28f0				   FPUSH      SET	1
      0  28f0					      pwordvar	V_src2.n
      1  28f0				  -	      IF	!FPUSH
      2  28f0				  -	      lda	V_src2.n
      3  28f0				  -	      pha
      4  28f0				  -	      lda	V_src2.n+1
      5  28f0				  -	      pha
      6  28f0					      ELSE
      7  28f0		       ad 6d 34 	      lda	V_src2.n
      8  28f3		       ac 6e 34 	      ldy	V_src2.n+1
      9  28f6					      ENDIF
   1960  28f6				   FPULL      SET	1
   1961  28f6				   FPUSH      SET	0
      0  28f6					      poke
      1  28f6				  -	      IF	!FPULL
      2  28f6				  -	      pla
      3  28f6				  -	      sta	.l + 2
      4  28f6				  -	      pla
      5  28f6				  -	      sta	.l + 1
      6  28f6					      ELSE
      7  28f6		       8d fe 28 	      sta	.l + 1
      8  28f9		       8c ff 28 	      sty	.l + 2
      9  28fc					      ENDIF
     10  28fc		       68		      pla
     11  28fd		       8d ff ff    .l	      sta	$ffff
   1963  2900				   _CO_35
      0  2900					      nextword	35, V_src2.n, V_src2.draw_level_.forstep35
      1  2900
      2  2900					      IFCONST	V_src2.draw_level_.forstep35
      3  2900
      4  2900		       18		      clc
      5  2901		       ad b0 34 	      lda	V_src2.draw_level_.forstep35
      6  2904		       6d 6d 34 	      adc	V_src2.n
      7  2907		       8d 6d 34 	      sta	V_src2.n
      8  290a		       ad b1 34 	      lda	V_src2.draw_level_.forstep35 + 1
      9  290d		       6d 6e 34 	      adc	V_src2.n + 1
     10  2910		       8d 6e 34 	      sta	V_src2.n + 1
     11  2913
     12  2913		       b0 03		      bcs	_ENDFOR_35
     13  2915				  -	      ELSE
     14  2915				  -
     15  2915				  -	      inc	V_src2.n
     16  2915				  -	      bne	.skip
     17  2915				  -	      inc	V_src2.n + 1
     18  2915				  -
     19  2915				  -	      beq	_ENDFOR_35
     20  2915				  -.skip
     21  2915					      ENDIF
     22  2915		       4c de 28 	      jmp	_FOR_35
   1965  2918
   1966  2918
   1967  2918
   1968  2918				   _ENDFOR_35
   1969  2918		       60		      rts
   1970  2919					      ENDIF
   1971  2919
   1972  2919
   1973  2919
   1974  2919
   1975  2919					      IFCONST	I_F_src2.check_bonus_vita_IMPORTED
   1976  2919				   F_src2.check_bonus_vita SUBROUTINE
   1977  2919				   FPULL      SET	0
      0  2919					      pwordvar	V_src2.score
      1  2919					      IF	!FPUSH
      2  2919		       ad 59 34 	      lda	V_src2.score
      3  291c		       48		      pha
      4  291d		       ad 5a 34 	      lda	V_src2.score+1
      5  2920		       48		      pha
      6  2921				  -	      ELSE
      7  2921				  -	      lda	V_src2.score
      8  2921				  -	      ldy	V_src2.score+1
      9  2921					      ENDIF
      0  2921					      F_clong_word
      1  2921		       a9 00		      lda	#$00
      2  2923		       48		      pha
      0  2924					      pwordvar	V_src2.bonus_multiplier
      1  2924					      IF	!FPUSH
      2  2924		       ad 62 34 	      lda	V_src2.bonus_multiplier
      3  2927		       48		      pha
      4  2928		       ad 63 34 	      lda	V_src2.bonus_multiplier+1
      5  292b		       48		      pha
      6  292c				  -	      ELSE
      7  292c				  -	      lda	V_src2.bonus_multiplier
      8  292c				  -	      ldy	V_src2.bonus_multiplier+1
      9  292c					      ENDIF
      0  292c					      F_cint_word
   1982  292c				   FPUSH      SET	1
      0  292c					      pintvar	V_src2.n_bonus
      0  292c					      pwordvar	V_src2.n_bonus
      1  292c				  -	      IF	!FPUSH
      2  292c				  -	      lda	V_src2.n_bonus
      3  292c				  -	      pha
      4  292c				  -	      lda	V_src2.n_bonus+1
      5  292c				  -	      pha
      6  292c					      ELSE
      7  292c		       ad 5f 34 	      lda	V_src2.n_bonus
      8  292f		       ac 60 34 	      ldy	V_src2.n_bonus+1
      9  2932					      ENDIF
   1984  2932				   FPULL      SET	1
   1985  2932				   FPUSH      SET	0
      0  2932					      mulint
      1  2932				  -	      IF	!FPULL
      2  2932				  -	      pla
      3  2932				  -	      sta	R1
      4  2932				  -	      pla
      5  2932				  -	      sta	R0
      6  2932					      ELSE
      7  2932		       85 02		      sta	R0
      8  2934		       84 03		      sty	R1
      9  2936					      ENDIF
     10  2936		       68		      pla
     11  2937		       85 05		      sta	R3
     12  2939		       68		      pla
     13  293a		       85 04		      sta	R2
      0  293c					      import	I_NUCLEUS_MUL16
      1  293c				   I_NUCLEUS_MUL16_IMPORTED SET	1
     15  293c		       20 d4 2b 	      jsr	NUCLEUS_MUL16
     16  293f					      IF	!FPUSH
     17  293f		       a5 02		      lda	R0
     18  2941		       48		      pha
     19  2942		       a5 03		      lda	R1
     20  2944		       48		      pha
     21  2945				  -	      ELSE
     22  2945				  -	      lda	R0
     23  2945				  -	      ldy	R1
     24  2945					      ENDIF
      0  2945					      F_clong_int
      1  2945		       ba		      tsx
      2  2946		       bd 01 01 	      lda	stack + 1,x
      3  2949		       10 04		      bpl	.pos
      4  294b		       a9 ff		      lda	#$ff
      5  294d		       30 02		      bmi	.end
      6  294f				   .pos
      7  294f		       a9 00		      lda	#$00
      8  2951				   .end
      9  2951		       48		      pha
   1988  2951				   FPULL      SET	0
   1989  2951				   FPUSH      SET	1
      0  2952					      cmplongeq
      1  2952		       ba		      tsx
      2  2953		       bd 06 01 	      lda.wx	stack+6
      3  2956		       dd 03 01 	      cmp.wx	stack+3
      4  2959		       d0 1a		      bne	.false
      5  295b		       bd 05 01 	      lda.wx	stack+5
      6  295e		       dd 02 01 	      cmp.wx	stack+2
      7  2961		       d0 12		      bne	.false
      8  2963		       bd 04 01 	      lda.wx	stack+4
      9  2966		       dd 01 01 	      cmp.wx	stack+1
     10  2969		       d0 0a		      bne	.false
     11  296b		       8a		      txa
     12  296c		       18		      clc
     13  296d		       69 06		      adc	#6
     14  296f		       aa		      tax
     15  2970		       9a		      txs
      0  2971					      ptrue
      1  2971		       a9 ff		      lda	#$FF
      2  2973				  -	      IF	!FPUSH
      3  2973				  -	      pha
      4  2973					      ENDIF
     17  2973		       d0 08		      bne	.q
     18  2975				   .false
     19  2975		       8a		      txa
     20  2976		       18		      clc
     21  2977		       69 06		      adc	#6
     22  2979		       aa		      tax
     23  297a		       9a		      txs
      0  297b					      pfalse
      1  297b		       a9 00		      lda	#$00
      2  297d				  -	      IF	!FPUSH
      3  297d				  -	      pha
      4  297d					      ENDIF
     25  297d				   .q
   1991  297d				   FPULL      SET	1
   1992  297d				   FPUSH      SET	0
      0  297d					      cond_stmt	_EI_36, _EL_36
      1  297d				  -	      IF	!FPULL
      2  297d				  -	      pla
      3  297d					      ENDIF
      4  297d		       d0 03		      bne	* + 5
      5  297f					      IF	_EL_36 > 0 && _EL_36 < $10000
      6  297f		       4c ad 29 	      jmp	_EL_36
      7  2982				  -	      ELSE
      8  2982				  -	      jmp	_EI_36
      9  2982					      ENDIF
   1994  2982				   FPULL      SET	0
   1995  2982				   FPUSH      SET	1
      0  2982					      pintvar_pbyte_F_cint_byte_addint	V_src2.lives, 1
      0  2982					      pintvar_pint_addint	V_src2.lives, 1
      1  2982		       ad 5d 34 	      lda	V_src2.lives
      2  2985		       18		      clc
      3  2986		       69 01		      adc	#<1
      4  2988				  -	      IF	!FPUSH
      5  2988				  -	      pha
      6  2988					      ELSE
      7  2988		       aa		      tax
      8  2989					      ENDIF
      9  2989		       ad 5e 34 	      lda	V_src2.lives + 1
     10  298c		       69 00		      adc	#>1
     11  298e				  -	      IF	!FPUSH
     12  298e				  -	      pha
     13  298e					      ELSE
     14  298e		       a8		      tay
     15  298f		       8a		      txa
     16  2990					      ENDIF
   1997  2990				   FPULL      SET	1
   1998  2990				   FPUSH      SET	0
      0  2990					      plintvar	V_src2.lives
      0  2990					      plwordvar	V_src2.lives
      1  2990				  -	      IF	!FPULL
      2  2990				  -	      pla
      3  2990				  -	      sta	V_src2.lives+1
      4  2990				  -	      pla
      5  2990				  -	      sta	V_src2.lives
      6  2990					      ELSE
      7  2990		       8d 5d 34 	      sta	V_src2.lives
      8  2993		       8c 5e 34 	      sty	V_src2.lives+1
      9  2996					      ENDIF
   2000  2996
   2001  2996				   FPULL      SET	0
   2002  2996				   FPUSH      SET	1
      0  2996					      pintvar_pbyte_F_cint_byte_addint	V_src2.n_bonus, 1
      0  2996					      pintvar_pint_addint	V_src2.n_bonus, 1
      1  2996		       ad 5f 34 	      lda	V_src2.n_bonus
      2  2999		       18		      clc
      3  299a		       69 01		      adc	#<1
      4  299c				  -	      IF	!FPUSH
      5  299c				  -	      pha
      6  299c					      ELSE
      7  299c		       aa		      tax
      8  299d					      ENDIF
      9  299d		       ad 60 34 	      lda	V_src2.n_bonus + 1
     10  29a0		       69 00		      adc	#>1
     11  29a2				  -	      IF	!FPUSH
     12  29a2				  -	      pha
     13  29a2					      ELSE
     14  29a2		       a8		      tay
     15  29a3		       8a		      txa
     16  29a4					      ENDIF
   2004  29a4				   FPULL      SET	1
   2005  29a4				   FPUSH      SET	0
      0  29a4					      plintvar	V_src2.n_bonus
      0  29a4					      plwordvar	V_src2.n_bonus
      1  29a4				  -	      IF	!FPULL
      2  29a4				  -	      pla
      3  29a4				  -	      sta	V_src2.n_bonus+1
      4  29a4				  -	      pla
      5  29a4				  -	      sta	V_src2.n_bonus
      6  29a4					      ELSE
      7  29a4		       8d 5f 34 	      sta	V_src2.n_bonus
      8  29a7		       8c 60 34 	      sty	V_src2.n_bonus+1
      9  29aa					      ENDIF
      0  29aa					      import	I_F_src2.update_score
      1  29aa				   I_F_src2.update_score_IMPORTED SET	1
   2008  29aa		       20 61 2a 	      jsr	F_src2.update_score
   2009  29ad
   2010  29ad
   2011  29ad
   2012  29ad				   _EL_36
   2013  29ad
   2014  29ad
   2015  29ad
   2016  29ad				   _EI_36
   2017  29ad		       60		      rts
   2018  29ae					      ENDIF
   2019  29ae
   2020  29ae
   2021  29ae
   2022  29ae
   2023  29ae					      IFCONST	I_F_src2.init_mem_IMPORTED
   2024  29ae				   F_src2.init_mem SUBROUTINE
   2025  29ae				   FPULL      SET	0
      0  29ae					      pint	7679
      0  29ae					      pword	7679
      1  29ae					      IF	!FPUSH
      2  29ae		       a9 ff		      lda	#<7679
      3  29b0		       48		      pha
      4  29b1		       a9 1d		      lda	#>7679
      5  29b3		       48		      pha
      6  29b4				  -	      ELSE
      7  29b4				  -	      lda	#<7679
      8  29b4				  -	      ldy	#>7679
      9  29b4					      ENDIF
      0  29b4					      pint	7616
      0  29b4					      pword	7616
      1  29b4					      IF	!FPUSH
      2  29b4		       a9 c0		      lda	#<7616
      3  29b6		       48		      pha
      4  29b7		       a9 1d		      lda	#>7616
      5  29b9		       48		      pha
      6  29ba				  -	      ELSE
      7  29ba				  -	      lda	#<7616
      8  29ba				  -	      ldy	#>7616
      9  29ba					      ENDIF
      0  29ba					      subint
      0  29ba					      subword
      1  29ba		       ba		      tsx
      2  29bb		       bd 04 01 	      lda.wx	stack + 4
      3  29be		       38		      sec
      4  29bf		       fd 02 01 	      sbc.wx	stack + 2
      5  29c2		       9d 04 01 	      sta.wx	stack + 4
      6  29c5		       bd 03 01 	      lda.wx	stack + 3
      7  29c8		       fd 01 01 	      sbc.wx	stack + 1
      8  29cb		       9d 03 01 	      sta.wx	stack + 3
      9  29ce		       e8		      inx
     10  29cf		       e8		      inx
     11  29d0		       9a		      txs
      0  29d1					      pbyte	1
      1  29d1		       a9 01		      lda	#1
      2  29d3					      IF	!FPUSH
      3  29d3		       48		      pha
      4  29d4					      ENDIF
      0  29d4					      F_cint_byte
      0  29d4					      F_cword_byte
      1  29d4		       a9 00		      lda	#$00
      2  29d6		       48		      pha
      0  29d7					      addint
      0  29d7					      addword
      1  29d7		       ba		      tsx
      2  29d8		       bd 02 01 	      lda.wx	stack + 2
      3  29db		       18		      clc
      4  29dc		       7d 04 01 	      adc.wx	stack + 4
      5  29df		       9d 04 01 	      sta.wx	stack + 4
      6  29e2		       68		      pla
      7  29e3		       7d 03 01 	      adc.wx	stack + 3
      8  29e6		       9d 03 01 	      sta.wx	stack + 3
      9  29e9		       68		      pla
      0  29ea					      F_cword_int
      0  29ea					      pint	7616
      0  29ea					      pword	7616
      1  29ea					      IF	!FPUSH
      2  29ea		       a9 c0		      lda	#<7616
      3  29ec		       48		      pha
      4  29ed		       a9 1d		      lda	#>7616
      5  29ef		       48		      pha
      6  29f0				  -	      ELSE
      7  29f0				  -	      lda	#<7616
      8  29f0				  -	      ldy	#>7616
      9  29f0					      ENDIF
      0  29f0					      F_cword_int
   2035  29f0				   FPUSH      SET	1
      0  29f0					      paddr	L_src2.chardata
      0  29f0					      pword	L_src2.chardata
      1  29f0				  -	      IF	!FPUSH
      2  29f0				  -	      lda	#<L_src2.chardata
      3  29f0				  -	      pha
      4  29f0				  -	      lda	#>L_src2.chardata
      5  29f0				  -	      pha
      6  29f0					      ELSE
      7  29f0		       a9 be		      lda	#<L_src2.chardata
      8  29f2		       a0 33		      ldy	#>L_src2.chardata
      9  29f4					      ENDIF
   2037  29f4				   FPULL      SET	1
   2038  29f4				   FPUSH      SET	0
      0  29f4					      memcpy
      1  29f4				  -	      IF	!FPULL
      2  29f4				  -	      pla
      3  29f4				  -	      sta	R1
      4  29f4				  -	      pla
      5  29f4				  -	      sta	R0
      6  29f4					      ELSE
      7  29f4		       85 02		      sta	R0
      8  29f6		       84 03		      sty	R1
      9  29f8					      ENDIF
     10  29f8		       68		      pla
     11  29f9		       85 05		      sta	R3
     12  29fb		       68		      pla
     13  29fc		       85 04		      sta	R2
     14  29fe		       68		      pla
     15  29ff		       85 07		      sta	R5
     16  2a01		       68		      pla
     17  2a02		       85 06		      sta	R4
      0  2a04					      import	I_MEMCPY
      1  2a04				   I_MEMCPY_IMPORTED SET	1
     19  2a04		       20 52 33 	      jsr	MEMCPY
   2040  2a04				   FPULL      SET	0
      0  2a07					      pint	899
      0  2a07					      pword	899
      1  2a07					      IF	!FPUSH
      2  2a07		       a9 83		      lda	#<899
      3  2a09		       48		      pha
      4  2a0a		       a9 03		      lda	#>899
      5  2a0c		       48		      pha
      6  2a0d				  -	      ELSE
      7  2a0d				  -	      lda	#<899
      8  2a0d				  -	      ldy	#>899
      9  2a0d					      ENDIF
      0  2a0d					      pint	828
      0  2a0d					      pword	828
      1  2a0d					      IF	!FPUSH
      2  2a0d		       a9 3c		      lda	#<828
      3  2a0f		       48		      pha
      4  2a10		       a9 03		      lda	#>828
      5  2a12		       48		      pha
      6  2a13				  -	      ELSE
      7  2a13				  -	      lda	#<828
      8  2a13				  -	      ldy	#>828
      9  2a13					      ENDIF
      0  2a13					      subint
      0  2a13					      subword
      1  2a13		       ba		      tsx
      2  2a14		       bd 04 01 	      lda.wx	stack + 4
      3  2a17		       38		      sec
      4  2a18		       fd 02 01 	      sbc.wx	stack + 2
      5  2a1b		       9d 04 01 	      sta.wx	stack + 4
      6  2a1e		       bd 03 01 	      lda.wx	stack + 3
      7  2a21		       fd 01 01 	      sbc.wx	stack + 1
      8  2a24		       9d 03 01 	      sta.wx	stack + 3
      9  2a27		       e8		      inx
     10  2a28		       e8		      inx
     11  2a29		       9a		      txs
      0  2a2a					      pbyte	1
      1  2a2a		       a9 01		      lda	#1
      2  2a2c					      IF	!FPUSH
      3  2a2c		       48		      pha
      4  2a2d					      ENDIF
      0  2a2d					      F_cint_byte
      0  2a2d					      F_cword_byte
      1  2a2d		       a9 00		      lda	#$00
      2  2a2f		       48		      pha
      0  2a30					      addint
      0  2a30					      addword
      1  2a30		       ba		      tsx
      2  2a31		       bd 02 01 	      lda.wx	stack + 2
      3  2a34		       18		      clc
      4  2a35		       7d 04 01 	      adc.wx	stack + 4
      5  2a38		       9d 04 01 	      sta.wx	stack + 4
      6  2a3b		       68		      pla
      7  2a3c		       7d 03 01 	      adc.wx	stack + 3
      8  2a3f		       9d 03 01 	      sta.wx	stack + 3
      9  2a42		       68		      pla
      0  2a43					      F_cword_int
      0  2a43					      pint	828
      0  2a43					      pword	828
      1  2a43					      IF	!FPUSH
      2  2a43		       a9 3c		      lda	#<828
      3  2a45		       48		      pha
      4  2a46		       a9 03		      lda	#>828
      5  2a48		       48		      pha
      6  2a49				  -	      ELSE
      7  2a49				  -	      lda	#<828
      8  2a49				  -	      ldy	#>828
      9  2a49					      ENDIF
      0  2a49					      F_cword_int
   2050  2a49				   FPUSH      SET	1
      0  2a49					      paddr	L_src2.lmdata
      0  2a49					      pword	L_src2.lmdata
      1  2a49				  -	      IF	!FPUSH
      2  2a49				  -	      lda	#<L_src2.lmdata
      3  2a49				  -	      pha
      4  2a49				  -	      lda	#>L_src2.lmdata
      5  2a49				  -	      pha
      6  2a49					      ELSE
      7  2a49		       a9 fe		      lda	#<L_src2.lmdata
      8  2a4b		       a0 33		      ldy	#>L_src2.lmdata
      9  2a4d					      ENDIF
   2052  2a4d				   FPULL      SET	1
   2053  2a4d				   FPUSH      SET	0
      0  2a4d					      memcpy
      1  2a4d				  -	      IF	!FPULL
      2  2a4d				  -	      pla
      3  2a4d				  -	      sta	R1
      4  2a4d				  -	      pla
      5  2a4d				  -	      sta	R0
      6  2a4d					      ELSE
      7  2a4d		       85 02		      sta	R0
      8  2a4f		       84 03		      sty	R1
      9  2a51					      ENDIF
     10  2a51		       68		      pla
     11  2a52		       85 05		      sta	R3
     12  2a54		       68		      pla
     13  2a55		       85 04		      sta	R2
     14  2a57		       68		      pla
     15  2a58		       85 07		      sta	R5
     16  2a5a		       68		      pla
     17  2a5b		       85 06		      sta	R4
      0  2a5d					      import	I_MEMCPY
      1  2a5d				   I_MEMCPY_IMPORTED SET	1
     19  2a5d		       20 52 33 	      jsr	MEMCPY
   2055  2a60		       60		      rts
   2056  2a61					      ENDIF
   2057  2a61
   2058  2a61					      IFCONST	I_F_src2.update_score_IMPORTED
   2059  2a61				   F_src2.update_score SUBROUTINE
      0  2a61					      pstringvar	_S9
      1  2a61		       a9 b0		      lda	#<_S9
      2  2a63		       85 02		      sta	R0
      3  2a65		       a9 33		      lda	#>_S9
      4  2a67		       85 03		      sta	R0 + 1
      5  2a69		       ad b0 33 	      lda	_S9
      0  2a6c					      import	I_STRMOV
      1  2a6c				   I_STRMOV_IMPORTED SET	1
      7  2a6c		       20 93 32 	      jsr	STRMOV
      0  2a6f					      printstring
      1  2a6f		       a6 0e		      ldx	SP
      2  2a71		       e8		      inx
      3  2a72		       8a		      txa
      4  2a73		       a0 1d		      ldy	#>STRING_WORKAREA
      0  2a75					      import	I_STDLIB_PRINTSTR
      1  2a75				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  2a75		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  2a78
      8  2a78		       98		      tya
      9  2a79		       18		      clc
     10  2a7a		       65 0e		      adc	SP
     11  2a7c		       85 0e		      sta	SP
   2062  2a7c				   FPULL      SET	0
      0  2a7e					      pbyte	8
      1  2a7e		       a9 08		      lda	#8
      2  2a80					      IF	!FPUSH
      3  2a80		       48		      pha
      4  2a81					      ENDIF
   2064  2a81				   FPUSH      SET	1
      0  2a81					      pwordvar	V_src2.score
      1  2a81				  -	      IF	!FPUSH
      2  2a81				  -	      lda	V_src2.score
      3  2a81				  -	      pha
      4  2a81				  -	      lda	V_src2.score+1
      5  2a81				  -	      pha
      6  2a81					      ELSE
      7  2a81		       ad 59 34 	      lda	V_src2.score
      8  2a84		       ac 5a 34 	      ldy	V_src2.score+1
      9  2a87					      ENDIF
   2066  2a87				   FPULL      SET	1
   2067  2a87				   FPUSH      SET	0
      0  2a87					      F_str@_word
      1  2a87				  -	      IF	!FPULL
      2  2a87				  -	      pla
      3  2a87				  -	      sta	R2 + 1
      4  2a87				  -	      pla
      5  2a87				  -	      sta	R2
      6  2a87					      ELSE
      7  2a87		       85 04		      sta	R2
      8  2a89		       84 05		      sty	R2 + 1
      9  2a8b					      ENDIF
      0  2a8b					      import	I_STR_WTOS
      1  2a8b				   I_STR_WTOS_IMPORTED SET	1
     11  2a8b		       a2 00		      ldx	#0
     12  2a8d		       20 19 32 	      jsr	STR_WTOS
      0  2a90					      F_len_string
      1  2a90		       a6 0e		      ldx	SP
      2  2a92		       e8		      inx
      3  2a93		       bd 00 1d 	      lda	STRING_WORKAREA,x
      4  2a96		       48		      pha
      5  2a97		       18		      clc
      6  2a98		       65 0e		      adc	SP
      7  2a9a		       69 01		      adc	#1
      8  2a9c		       85 0e		      sta	SP
   2070  2a9c				   FPULL      SET	0
      0  2a9e					      subbyte
      1  2a9e					      IF	!FPULL
      2  2a9e		       68		      pla
      3  2a9f					      ENDIF
      4  2a9f		       85 02		      sta	R0
      5  2aa1		       68		      pla
      6  2aa2		       38		      sec
      7  2aa3		       e5 02		      sbc	R0
      8  2aa5					      IF	!FPUSH
      9  2aa5		       48		      pha
     10  2aa6					      ENDIF
   2072  2aa6				   FPUSH      SET	1
      0  2aa6					      pbyte	0
      1  2aa6		       a9 00		      lda	#0
      2  2aa8				  -	      IF	!FPUSH
      3  2aa8				  -	      pha
      4  2aa8					      ENDIF
   2074  2aa8				   FPULL      SET	1
   2075  2aa8				   FPUSH      SET	0
      0  2aa8					      locate
      1  2aa8				  -	      IF	!FPULL
      2  2aa8				  -	      pla
      3  2aa8					      ENDIF
      4  2aa8		       aa		      tax
      5  2aa9		       68		      pla
      6  2aaa		       a8		      tay
      7  2aab		       18		      clc
      0  2aac					      kerncall	KERNAL_PLOT
      1  2aac		       20 f0 ff 	      jsr	KERNAL_PLOT
   2077  2aac				   FPULL      SET	0
   2078  2aac				   FPUSH      SET	1
      0  2aaf					      pwordvar	V_src2.score
      1  2aaf				  -	      IF	!FPUSH
      2  2aaf				  -	      lda	V_src2.score
      3  2aaf				  -	      pha
      4  2aaf				  -	      lda	V_src2.score+1
      5  2aaf				  -	      pha
      6  2aaf					      ELSE
      7  2aaf		       ad 59 34 	      lda	V_src2.score
      8  2ab2		       ac 5a 34 	      ldy	V_src2.score+1
      9  2ab5					      ENDIF
   2080  2ab5				   FPULL      SET	1
   2081  2ab5				   FPUSH      SET	0
      0  2ab5					      printword
      0  2ab5					      F_str@_word
      1  2ab5				  -	      IF	!FPULL
      2  2ab5				  -	      pla
      3  2ab5				  -	      sta	R2 + 1
      4  2ab5				  -	      pla
      5  2ab5				  -	      sta	R2
      6  2ab5					      ELSE
      7  2ab5		       85 04		      sta	R2
      8  2ab7		       84 05		      sty	R2 + 1
      9  2ab9					      ENDIF
      0  2ab9					      import	I_STR_WTOS
      1  2ab9				   I_STR_WTOS_IMPORTED SET	1
     11  2ab9		       a2 00		      ldx	#0
     12  2abb		       20 19 32 	      jsr	STR_WTOS
      0  2abe					      printstring
      1  2abe		       a6 0e		      ldx	SP
      2  2ac0		       e8		      inx
      3  2ac1		       8a		      txa
      4  2ac2		       a0 1d		      ldy	#>STRING_WORKAREA
      0  2ac4					      import	I_STDLIB_PRINTSTR
      1  2ac4				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  2ac4		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  2ac7
      8  2ac7		       98		      tya
      9  2ac8		       18		      clc
     10  2ac9		       65 0e		      adc	SP
     11  2acb		       85 0e		      sta	SP
      0  2acd					      printnl
      1  2acd		       a9 0d		      lda	#13
      0  2acf					      kerncall	KERNAL_CHROUT
      1  2acf		       20 d2 ff 	      jsr	KERNAL_CHROUT
   2084  2acf				   FPULL      SET	0
      0  2ad2					      pbyte	14
      1  2ad2		       a9 0e		      lda	#14
      2  2ad4					      IF	!FPUSH
      3  2ad4		       48		      pha
      4  2ad5					      ENDIF
   2086  2ad5				   FPUSH      SET	1
      0  2ad5					      pbyte	0
      1  2ad5		       a9 00		      lda	#0
      2  2ad7				  -	      IF	!FPUSH
      3  2ad7				  -	      pha
      4  2ad7					      ENDIF
   2088  2ad7				   FPULL      SET	1
   2089  2ad7				   FPUSH      SET	0
      0  2ad7					      locate
      1  2ad7				  -	      IF	!FPULL
      2  2ad7				  -	      pla
      3  2ad7					      ENDIF
      4  2ad7		       aa		      tax
      5  2ad8		       68		      pla
      6  2ad9		       a8		      tay
      7  2ada		       18		      clc
      0  2adb					      kerncall	KERNAL_PLOT
      1  2adb		       20 f0 ff 	      jsr	KERNAL_PLOT
   2091  2adb				   FPULL      SET	0
   2092  2adb				   FPUSH      SET	1
      0  2ade					      pintvar	V_src2.lives
      0  2ade					      pwordvar	V_src2.lives
      1  2ade				  -	      IF	!FPUSH
      2  2ade				  -	      lda	V_src2.lives
      3  2ade				  -	      pha
      4  2ade				  -	      lda	V_src2.lives+1
      5  2ade				  -	      pha
      6  2ade					      ELSE
      7  2ade		       ad 5d 34 	      lda	V_src2.lives
      8  2ae1		       ac 5e 34 	      ldy	V_src2.lives+1
      9  2ae4					      ENDIF
   2094  2ae4				   FPULL      SET	1
   2095  2ae4				   FPUSH      SET	0
      0  2ae4					      printint
      0  2ae4					      F_str@_int
      1  2ae4				  -	      IF	!FPULL
      2  2ae4				  -	      pla
      3  2ae4				  -	      sta	R2 + 1
      4  2ae4				  -	      pla
      5  2ae4				  -	      sta	R2
      6  2ae4					      ELSE
      7  2ae4		       85 04		      sta	R2
      8  2ae6		       84 05		      sty	R2 + 1
      9  2ae8					      ENDIF
      0  2ae8					      import	I_STR_WTOS
      1  2ae8				   I_STR_WTOS_IMPORTED SET	1
     11  2ae8		       a2 00		      ldx	#0
     12  2aea		       a5 05		      lda	R2 + 1
     13  2aec		       10 14		      bpl	.pos
      0  2aee					      twoscplint	R2
      1  2aee		       a5 05		      lda	R2+1
      2  2af0		       49 ff		      eor	#$ff
      3  2af2		       85 05		      sta	R2+1
      4  2af4		       a5 04		      lda	R2
      5  2af6		       49 ff		      eor	#$ff
      6  2af8		       18		      clc
      7  2af9		       69 01		      adc	#$01
      8  2afb		       85 04		      sta	R2
      9  2afd		       d0 02		      bne	.skip
     10  2aff		       e6 05		      inc	R2+1
     11  2b01				   .skip
     15  2b01		       e8		      inx
     16  2b02				   .pos
     17  2b02		       20 19 32 	      jsr	STR_WTOS
      0  2b05					      printstring
      1  2b05		       a6 0e		      ldx	SP
      2  2b07		       e8		      inx
      3  2b08		       8a		      txa
      4  2b09		       a0 1d		      ldy	#>STRING_WORKAREA
      0  2b0b					      import	I_STDLIB_PRINTSTR
      1  2b0b				   I_STDLIB_PRINTSTR_IMPORTED SET	1
      6  2b0b		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      7  2b0e
      8  2b0e		       98		      tya
      9  2b0f		       18		      clc
     10  2b10		       65 0e		      adc	SP
     11  2b12		       85 0e		      sta	SP
      0  2b14					      printnl
      1  2b14		       a9 0d		      lda	#13
      0  2b16					      kerncall	KERNAL_CHROUT
      1  2b16		       20 d2 ff 	      jsr	KERNAL_CHROUT
   2098  2b16				   FPULL      SET	0
      0  2b19					      pbyte	17
      1  2b19		       a9 11		      lda	#17
      2  2b1b					      IF	!FPUSH
      3  2b1b		       48		      pha
      4  2b1c					      ENDIF
   2100  2b1c				   FPUSH      SET	1
      0  2b1c					      pbyte	0
      1  2b1c		       a9 00		      lda	#0
      2  2b1e				  -	      IF	!FPUSH
      3  2b1e				  -	      pha
      4  2b1e					      ENDIF
   2102  2b1e				   FPULL      SET	1
   2103  2b1e				   FPUSH      SET	0
      0  2b1e					      locate
      1  2b1e				  -	      IF	!FPULL
      2  2b1e				  -	      pla
      3  2b1e					      ENDIF
      4  2b1e		       aa		      tax
      5  2b1f		       68		      pla
      6  2b20		       a8		      tay
      7  2b21		       18		      clc
      0  2b22					      kerncall	KERNAL_PLOT
      1  2b22		       20 f0 ff 	      jsr	KERNAL_PLOT
   2105  2b22				   FPULL      SET	0
   2106  2b22				   FPUSH      SET	1
      0  2b25					      pbytevar	V_src2.level
      1  2b25		       ad 5c 34 	      lda	V_src2.level
      2  2b28				  -	      IF	!FPUSH
      3  2b28				  -	      pha
      4  2b28					      ENDIF
   2108  2b28				   FPULL      SET	1
   2109  2b28				   FPUSH      SET	0
      0  2b28					      printbyte
      0  2b28					      import	I_STDLIB_PRINT_BYTE
      1  2b28				   I_STDLIB_PRINT_BYTE_IMPORTED SET	1
      2  2b28				  -	      IF	!FPULL
      3  2b28				  -	      pla
      4  2b28					      ENDIF
      5  2b28		       20 06 33 	      jsr	STDLIB_PRINT_BYTE
      0  2b2b					      printnl
      1  2b2b		       a9 0d		      lda	#13
      0  2b2d					      kerncall	KERNAL_CHROUT
      1  2b2d		       20 d2 ff 	      jsr	KERNAL_CHROUT
   2112  2b30		       60		      rts
   2113  2b31					      ENDIF
   2114  2b31
   2115  2b31					      IFCONST	I_F_src2.get_random_direction_IMPORTED
   2116  2b31				   F_src2.get_random_direction SUBROUTINE
      0  2b31					      F_rndb
      0  2b31					      import	I_RNDL
      1  2b31				   I_RNDL_IMPORTED SET	1
      2  2b31		       20 4c 2c 	      jsr	I_RNDL
      3  2b34		       ad 49 2c 	      lda	MATH_RND
      4  2b37					      IF	!FPUSH
      5  2b37		       48		      pha
      6  2b38					      ENDIF
   2118  2b38				   FPULL      SET	0
   2119  2b38				   FPUSH      SET	1
      0  2b38					      pbyte	1
      1  2b38		       a9 01		      lda	#1
      2  2b3a				  -	      IF	!FPUSH
      3  2b3a				  -	      pha
      4  2b3a					      ENDIF
   2121  2b3a				   FPULL      SET	1
      0  2b3a					      andbyte
      1  2b3a				  -	      IF	!FPULL
      2  2b3a				  -	      pla
      3  2b3a					      ENDIF
      4  2b3a		       85 02		      sta	R0
      5  2b3c		       68		      pla
      6  2b3d		       25 02		      and	R0
      7  2b3f				  -	      IF	!FPUSH
      8  2b3f				  -	      pha
      9  2b3f					      ENDIF
   2123  2b3f				   FPUSH      SET	0
      0  2b3f					      cond_stmt	_EI_65551, _EL_65551
      1  2b3f				  -	      IF	!FPULL
      2  2b3f				  -	      pla
      3  2b3f					      ENDIF
      4  2b3f		       d0 03		      bne	* + 5
      5  2b41					      IF	_EL_65551 > 0 && _EL_65551 < $10000
      6  2b41		       4c 56 2b 	      jmp	_EL_65551
      7  2b44				  -	      ELSE
      8  2b44				  -	      jmp	_EI_65551
      9  2b44					      ENDIF
   2125  2b44				   FPULL      SET	0
      0  2b44					      pbyte	1
      1  2b44		       a9 01		      lda	#1
      2  2b46					      IF	!FPUSH
      3  2b46		       48		      pha
      4  2b47					      ENDIF
      0  2b47					      F_cint_byte
      0  2b47					      F_cword_byte
      1  2b47		       a9 00		      lda	#$00
      2  2b49		       48		      pha
      0  2b4a					      plintvar	V_src2.get_random_direction_.get_random_direction
      0  2b4a					      plwordvar	V_src2.get_random_direction_.get_random_direction
      1  2b4a					      IF	!FPULL
      2  2b4a		       68		      pla
      3  2b4b		       8d 47 34 	      sta	V_src2.get_random_direction_.get_random_direction+1
      4  2b4e		       68		      pla
      5  2b4f		       8d 46 34 	      sta	V_src2.get_random_direction_.get_random_direction
      6  2b52				  -	      ELSE
      7  2b52				  -	      sta	V_src2.get_random_direction_.get_random_direction
      8  2b52				  -	      sty	V_src2.get_random_direction_.get_random_direction+1
      9  2b52					      ENDIF
   2129  2b52		       60		      rts
   2130  2b53		       4c 61 2b 	      jmp	_EI_65551
   2131  2b56				   _EL_65551
   2132  2b56				   FPUSH      SET	1
      0  2b56					      pint	-1
      0  2b56					      pword	-1
      1  2b56				  -	      IF	!FPUSH
      2  2b56				  -	      lda	#<-1
      3  2b56				  -	      pha
      4  2b56				  -	      lda	#>-1
      5  2b56				  -	      pha
      6  2b56					      ELSE
      7  2b56		       a9 ff		      lda	#<-1
      8  2b58		       a0 ff		      ldy	#>-1
      9  2b5a					      ENDIF
   2134  2b5a				   FPULL      SET	1
   2135  2b5a				   FPUSH      SET	0
      0  2b5a					      plintvar	V_src2.get_random_direction_.get_random_direction
      0  2b5a					      plwordvar	V_src2.get_random_direction_.get_random_direction
      1  2b5a				  -	      IF	!FPULL
      2  2b5a				  -	      pla
      3  2b5a				  -	      sta	V_src2.get_random_direction_.get_random_direction+1
      4  2b5a				  -	      pla
      5  2b5a				  -	      sta	V_src2.get_random_direction_.get_random_direction
      6  2b5a					      ELSE
      7  2b5a		       8d 46 34 	      sta	V_src2.get_random_direction_.get_random_direction
      8  2b5d		       8c 47 34 	      sty	V_src2.get_random_direction_.get_random_direction+1
      9  2b60					      ENDIF
   2137  2b60		       60		      rts
   2138  2b61				   _EI_65551
   2139  2b61		       60		      rts
   2140  2b62					      ENDIF
   2141  2b62
   2142  2b62
   2143  2b62
   2144  2b62
   2145  2b62					      IFCONST	I_F_src2.random_word_word_IMPORTED
   2146  2b62				   F_src2.random_word_word SUBROUTINE
   2147  2b62
   2148  2b62
   2149  2b62
   2150  2b62				   _DO_37
      0  2b62					      F_rndw
      0  2b62					      F_rndi
      0  2b62					      import	I_RNDL
      1  2b62				   I_RNDL_IMPORTED SET	1
      2  2b62					      REPEAT	2
      3  2b62		       20 4c 2c 	      jsr	I_RNDL
      4  2b65		       ad 49 2c 	      lda	MATH_RND
      5  2b68		       48		      pha
      2  2b68					      REPEND
      3  2b69		       20 4c 2c 	      jsr	I_RNDL
      4  2b6c		       ad 49 2c 	      lda	MATH_RND
      5  2b6f		       48		      pha
      6  2b70					      REPEND
   2152  2b70				   FPULL      SET	0
      0  2b70					      pwordvar	V_src2.random_word_word.mask
      1  2b70					      IF	!FPUSH
      2  2b70		       ad 4a 34 	      lda	V_src2.random_word_word.mask
      3  2b73		       48		      pha
      4  2b74		       ad 4b 34 	      lda	V_src2.random_word_word.mask+1
      5  2b77		       48		      pha
      6  2b78				  -	      ELSE
      7  2b78				  -	      lda	V_src2.random_word_word.mask
      8  2b78				  -	      ldy	V_src2.random_word_word.mask+1
      9  2b78					      ENDIF
      0  2b78					      andword
      1  2b78		       68		      pla
      2  2b79		       a8		      tay
      3  2b7a		       68		      pla
      4  2b7b		       ba		      tsx
      5  2b7c		       3d 02 01 	      and.wx	stack + 2
      6  2b7f		       9d 02 01 	      sta.wx	stack + 2
      7  2b82		       98		      tya
      8  2b83		       3d 01 01 	      and.wx	stack + 1
      9  2b86		       9d 01 01 	      sta.wx	stack + 1
      0  2b89					      plwordvar	V_src2.random_word_word.r
      1  2b89					      IF	!FPULL
      2  2b89		       68		      pla
      3  2b8a		       8d b3 34 	      sta	V_src2.random_word_word.r+1
      4  2b8d		       68		      pla
      5  2b8e		       8d b2 34 	      sta	V_src2.random_word_word.r
      6  2b91				  -	      ELSE
      7  2b91				  -	      sta	V_src2.random_word_word.r
      8  2b91				  -	      sty	V_src2.random_word_word.r+1
      9  2b91					      ENDIF
   2156  2b91				   _CO_37
      0  2b91					      pwordvar	V_src2.random_word_word.r
      1  2b91					      IF	!FPUSH
      2  2b91		       ad b2 34 	      lda	V_src2.random_word_word.r
      3  2b94		       48		      pha
      4  2b95		       ad b3 34 	      lda	V_src2.random_word_word.r+1
      5  2b98		       48		      pha
      6  2b99				  -	      ELSE
      7  2b99				  -	      lda	V_src2.random_word_word.r
      8  2b99				  -	      ldy	V_src2.random_word_word.r+1
      9  2b99					      ENDIF
      0  2b99					      pwordvar	V_src2.random_word_word.limit
      1  2b99					      IF	!FPUSH
      2  2b99		       ad 48 34 	      lda	V_src2.random_word_word.limit
      3  2b9c		       48		      pha
      4  2b9d		       ad 49 34 	      lda	V_src2.random_word_word.limit+1
      5  2ba0		       48		      pha
      6  2ba1				  -	      ELSE
      7  2ba1				  -	      lda	V_src2.random_word_word.limit
      8  2ba1				  -	      ldy	V_src2.random_word_word.limit+1
      9  2ba1					      ENDIF
      0  2ba1					      cmpwordlt
      1  2ba1		       ba		      tsx
      2  2ba2		       bd 04 01 	      lda.wx	stack + 4
      3  2ba5		       dd 02 01 	      cmp.wx	stack + 2
      4  2ba8		       bd 03 01 	      lda.wx	stack + 3
      5  2bab		       fd 01 01 	      sbc.wx	stack + 1
      6  2bae		       90 04		      bcc	.true
      7  2bb0		       a9 00		      lda	#0
      8  2bb2		       f0 02		      beq	.1
      9  2bb4				   .true
     10  2bb4		       a9 ff		      lda	#255
     11  2bb6				   .1
     12  2bb6		       9d 04 01 	      sta.wx	stack + 4
     13  2bb9		       e8		      inx
     14  2bba		       e8		      inx
     15  2bbb		       e8		      inx
     16  2bbc		       9a		      txs
      0  2bbd					      neg_cond_stmt	_ED_37, $10000
      1  2bbd					      IF	!FPULL
      2  2bbd		       68		      pla
      3  2bbe					      ENDIF
      4  2bbe		       f0 03		      beq	* + 5
      5  2bc0				  -	      IF	$10000 > 0 && $10000 < $10000
      6  2bc0				  -	      jmp	$10000
      7  2bc0					      ELSE
      8  2bc0		       4c c6 2b 	      jmp	_ED_37
      9  2bc3					      ENDIF
   2161  2bc3		       4c 62 2b 	      jmp	_DO_37
   2162  2bc6				   _ED_37
   2163  2bc6				   FPUSH      SET	1
      0  2bc6					      pwordvar	V_src2.random_word_word.r
      1  2bc6				  -	      IF	!FPUSH
      2  2bc6				  -	      lda	V_src2.random_word_word.r
      3  2bc6				  -	      pha
      4  2bc6				  -	      lda	V_src2.random_word_word.r+1
      5  2bc6				  -	      pha
      6  2bc6					      ELSE
      7  2bc6		       ad b2 34 	      lda	V_src2.random_word_word.r
      8  2bc9		       ac b3 34 	      ldy	V_src2.random_word_word.r+1
      9  2bcc					      ENDIF
   2165  2bcc				   FPULL      SET	1
   2166  2bcc				   FPUSH      SET	0
      0  2bcc					      plwordvar	V_src2.random_word_word.random
      1  2bcc				  -	      IF	!FPULL
      2  2bcc				  -	      pla
      3  2bcc				  -	      sta	V_src2.random_word_word.random+1
      4  2bcc				  -	      pla
      5  2bcc				  -	      sta	V_src2.random_word_word.random
      6  2bcc					      ELSE
      7  2bcc		       8d 4c 34 	      sta	V_src2.random_word_word.random
      8  2bcf		       8c 4d 34 	      sty	V_src2.random_word_word.random+1
      9  2bd2					      ENDIF
   2168  2bd2		       60		      rts
   2169  2bd3		       60		      rts
   2170  2bd4					      ENDIF
   2171  2bd4
   2172  2bd4
   2173  2bd4
   2174  2bd4
   2175  2bd4
   2176  2bd4
   2177  2bd4
   2178  2bd4
   2179  2bd4				   FPUSH      SET	0
   2180  2bd4				   FPULL      SET	0
   2181  2bd4				   FPUSH      SET	0
   2182  2bd4				   FPULL      SET	0
   2183  2bd4
   2184  2bd4				   FPUSH      SET	0
   2185  2bd4				   FPULL      SET	0
   2186  2bd4				   FPUSH      SET	0
   2187  2bd4				   FPULL      SET	0
   2188  2bd4				   library_start
   2189  3446 ????				      SEG	"LIBRARY"
   2190  2bd4					      ORG	library_start
   2191  2bd4
   2192  2bd4					      INCDIR	"C:\Users\Nino1\Desktop\USB\compilers\xc-basic3-main\lib"
------- FILE xcb3lib.asm LEVEL 2 PASS 4
      0  2bd4					      INCLUDE	"xcb3lib.asm"
      1  2bd4							; ===============================
      2  2bd4							; == XC-BASIC3 Runtime Library ==
      3  2bd4							; ===============================
      4  2bd4
      5  2bd4							; Import a subrutine using this macro otherwise
      6  2bd4							; it won't get compiled into the final source
      7  2bd4					      MAC	import
      8  2bd4				   {1}_IMPORTED SET	1
      9  2bd4					      ENDM
     10  2bd4
     11  2bd4							; Pseudo-registers on zeropage
------- FILE core/zp/psregs.asm LEVEL 3 PASS 4
      0  2bd4					      INCLUDE	"core/zp/psregs.asm"
      1  2bd4							; ------------------------------------------
      2  2bd4							; XC=BASIC
      3  2bd4							; Pseudo-registers
      4  2bd4							;
      5  2bd4							; ZP locations reserved
      6  2bd4							; ------------------------------------------
      7  2bd4							; Arithmetic registers
      8  2bd4		       00 02	   R0	      EQU	$02
      9  2bd4		       00 03	   R1	      EQU	$03
     10  2bd4		       00 04	   R2	      EQU	$04
     11  2bd4		       00 05	   R3	      EQU	$05
     12  2bd4		       00 06	   R4	      EQU	$06
     13  2bd4		       00 07	   R5	      EQU	$07
     14  2bd4		       00 08	   R6	      EQU	$08
     15  2bd4		       00 09	   R7	      EQU	$09
     16  2bd4		       00 0a	   R8	      EQU	$0A
     17  2bd4		       00 0b	   R9	      EQU	$0B
     18  2bd4		       00 0c	   RA	      EQU	$0C
     19  2bd4		       00 0d	   RB	      EQU	$0D
     20  2bd4							; Pointer to current string in work area
     21  2bd4		       00 0e	   SP	      EQU	$0E
     22  2bd4							; Pointer to current stack frame
     23  2bd4		       00 0f	   RC	      EQU	$0F
     24  2bd4		       00 10	   RD	      EQU	$10
     25  2bd4							; Tmp Pointer to next stack frame
     26  2bd4		       00 11	   RE	      EQU	$11
     27  2bd4		       00 12	   RF	      EQU	$12
     28  2bd4							; Pointer to "this"
     29  2bd4		       00 13	   TH	      EQU	$13
     30  2bd4							; Current sprite number
     31  2bd4		       00 15	   SN	      EQU	$15
     32  2bd4
     33  2bd4							; Push pseudo-registers onto stack
     34  2bd4					      MAC	phsr
     35  2bd4					      IF	!FASTIRQ
     36  2bd4					      ldx	#SP
     37  2bd4				   .l
     38  2bd4					      lda	$00,x
     39  2bd4					      pha
     40  2bd4					      dex
     41  2bd4					      cpx	#[R0 - 1]
     42  2bd4					      bne	.l
     43  2bd4					      ENDIF
     44  2bd4					      ENDM
     45  2bd4
     46  2bd4							; Pull pseudo-registers off of stack
     47  2bd4					      MAC	plsr
     48  2bd4					      IF	!FASTIRQ
     49  2bd4					      ldx	#R0
     50  2bd4				   .l
     51  2bd4					      pla
     52  2bd4					      sta	$00,x
     53  2bd4					      inx
     54  2bd4					      cpx	#[SP + 1]
     55  2bd4					      bne	.l
     56  2bd4					      ENDIF
     57  2bd4					      ENDM
     58  2bd4
------- FILE xcb3lib.asm
     13  2bd4							; Basic stack operations
------- FILE core/stack/stack.asm LEVEL 3 PASS 4
      0  2bd4					      INCLUDE	"core/stack/stack.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4		       01 00	   stack      EQU	$0100
      4  2bd4
      5  2bd4				  -	      IF	TARGET == c64
      6  2bd4				  -STACKFRAME_TOP EQU	$CF00
      7  2bd4					      ENDIF
      8  2bd4				  -	      IF	TARGET == c128
      9  2bd4				  -STACKFRAME_TOP EQU	$BF00
     10  2bd4					      ENDIf
     11  2bd4					      IF	TARGET == vic20 || TARGET == vic20_3k
     12  2bd4		       1d 00	   STACKFRAME_TOP EQU	$1D00
     13  2bd4					      ENDIF
     14  2bd4				  -	      IF	TARGET == vic20_8k || TARGET == c16
     15  2bd4				  -STACKFRAME_TOP EQU	$3F00
     16  2bd4					      ENDIF
     17  2bd4				  -	      IF	TARGET == cplus4
     18  2bd4				  -STACKFRAME_TOP EQU	$7F00
     19  2bd4					      ENDIF
     20  2bd4							; PETS
     21  2bd4				  -	      IF	TARGET & pet
     22  2bd4				  -	      IF	TARGET & 1	; PET 8k RAM
     23  2bd4				  -STACKFRAME_TOP EQU	$1F00
     24  2bd4				  -	      ENDIF
     25  2bd4				  -	      IF	TARGET & 2	; PET 16k RAM
     26  2bd4				  -STACKFRAME_TOP EQU	$3F00
     27  2bd4				  -	      ENDIF
     28  2bd4				  -	      IF	TARGET & 4	; PET 32k RAM
     29  2bd4				  -STACKFRAME_TOP EQU	$7F00
     30  2bd4				  -	      ENDIF
     31  2bd4					      ENDIF
     32  2bd4
     33  2bd4							; (private)
     34  2bd4							; Calculate variable address from address + index
     35  2bd4							; Index on stack
     36  2bd4							; Var address is {1}
     37  2bd4							; Result in (R0)
     38  2bd4					      MAC	getaddr
     39  2bd4							; Get index
     40  2bd4					      IF	!FPULL
     41  2bd4					      pla
     42  2bd4					      sta	R0+1
     43  2bd4					      pla
     44  2bd4					      sta	R0
     45  2bd4					      ELSE
     46  2bd4					      sta	R0
     47  2bd4					      sty	R0+1
     48  2bd4					      ENDIF
     49  2bd4							; Add address
     50  2bd4					      lda	#<[{1}]
     51  2bd4					      clc
     52  2bd4					      adc	R0
     53  2bd4					      sta	R0
     54  2bd4					      lda	#>[{1}]
     55  2bd4					      adc	R0+1
     56  2bd4					      sta	R0+1
     57  2bd4					      ENDM		; @pull
     58  2bd4
     59  2bd4							; (private)
     60  2bd4							; Calculate dynamic variable address from frame pointer + index
     61  2bd4							; Index on stack (one byte)
     62  2bd4							; Result in (R0)
     63  2bd4					      MAC	getdynaddr
     64  2bd4					      IF	!FPULL
     65  2bd4					      pla
     66  2bd4					      ENDIF
     67  2bd4					      clc
     68  2bd4					      adc	RC
     69  2bd4					      sta	R0
     70  2bd4					      lda	RC + 1
     71  2bd4					      sta	R0 + 1
     72  2bd4					      ENDM		; @pull
     73  2bd4
     74  2bd4							; Push current THIS pointer on stack
     75  2bd4					      MAC	pthis
     76  2bd4					      IF	!FPUSH
     77  2bd4					      lda	TH
     78  2bd4					      pha
     79  2bd4					      lda	TH + 1
     80  2bd4					      pha
     81  2bd4					      ELSE
     82  2bd4					      lda	TH
     83  2bd4					      ldy	TH + 1
     84  2bd4					      ENDIF
     85  2bd4					      ENDM		; @push
     86  2bd4
     87  2bd4							; Set THIS pointer to {1}
     88  2bd4					      MAC	setthis
     89  2bd4					      lda	#<{1}
     90  2bd4					      sta	TH
     91  2bd4					      lda	#>{1}
     92  2bd4					      sta	TH + 1
     93  2bd4					      ENDM
     94  2bd4
     95  2bd4							; Add {1} to THIS pointer
     96  2bd4					      MAC	offsetthis
     97  2bd4					      lda	TH
     98  2bd4					      clc
     99  2bd4					      adc	#{1}
    100  2bd4					      sta	TH
    101  2bd4					      bcc	.skip
    102  2bd4					      inc	TH + 1
    103  2bd4				   .skip
    104  2bd4					      ENDM
    105  2bd4
    106  2bd4							; Pull THIS pointer off of stack
    107  2bd4					      MAC	plthis
    108  2bd4					      IF	!FPULL
    109  2bd4					      pla
    110  2bd4					      sta	TH + 1
    111  2bd4					      pla
    112  2bd4					      sta	TH
    113  2bd4					      ELSE
    114  2bd4					      sta	TH
    115  2bd4					      sty	TH + 1
    116  2bd4					      ENDIF
    117  2bd4					      ENDM		; @pull
    118  2bd4
    119  2bd4					      MAC	framereset
    120  2bd4					      lda	#<STACKFRAME_TOP
    121  2bd4					      sta	RC
    122  2bd4					      lda	#>STACKFRAME_TOP
    123  2bd4					      sta	RC + 1
    124  2bd4					      ENDM
    125  2bd4
    126  2bd4							; Allocate a stack frame for a
    127  2bd4							; new function call
    128  2bd4							; Number of bytes in {1}
    129  2bd4					      MAC	framealloc
    130  2bd4					      IF	{1} > 0
    131  2bd4					      sec
    132  2bd4					      lda	RC
    133  2bd4					      sbc	#{1}
    134  2bd4					      sta	RC
    135  2bd4					      bcs	* + 4
    136  2bd4					      dec	RC + 1
    137  2bd4					      ENDIF
    138  2bd4					      ENDM
    139  2bd4
    140  2bd4							; Deallocate a stack frame
    141  2bd4							; Number of bytes in {1}
    142  2bd4					      MAC	framefree
    143  2bd4					      IF	{1} > 0
    144  2bd4					      clc
    145  2bd4					      lda	RC
    146  2bd4					      adc	#{1}
    147  2bd4					      sta	RC
    148  2bd4					      bcc	* + 4
    149  2bd4					      inc	RC + 1
    150  2bd4					      ENDIF
    151  2bd4					      ENDM
    152  2bd4
------- FILE core/stack/_byte.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/stack/_byte.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Push true onto stack
      4  2bd4					      MAC	ptrue
      5  2bd4					      lda	#$FF
      6  2bd4					      IF	!FPUSH
      7  2bd4					      pha
      8  2bd4					      ENDIF
      9  2bd4					      ENDM		; @push
     10  2bd4
     11  2bd4							; Push false onto stack
     12  2bd4					      MAC	pfalse
     13  2bd4					      lda	#$00
     14  2bd4					      IF	!FPUSH
     15  2bd4					      pha
     16  2bd4					      ENDIF
     17  2bd4					      ENDM		; @push
     18  2bd4
     19  2bd4							; Push immediate byte onto stack
     20  2bd4					      MAC	pbyte
     21  2bd4					      lda	#{1}
     22  2bd4					      IF	!FPUSH
     23  2bd4					      pha
     24  2bd4					      ENDIF
     25  2bd4					      ENDM		; @push
     26  2bd4
     27  2bd4							; Push byte variable onto stack
     28  2bd4					      MAC	pbytevar
     29  2bd4					      lda	{1}
     30  2bd4					      IF	!FPUSH
     31  2bd4					      pha
     32  2bd4					      ENDIF
     33  2bd4					      ENDM		; @push
     34  2bd4
     35  2bd4							; Push dynamic byte variable onto stack
     36  2bd4					      MAC	pdynbytevar
     37  2bd4					      ldy	#{1}
     38  2bd4					      lda	(RC),y
     39  2bd4					      IF	!FPUSH
     40  2bd4					      pha
     41  2bd4					      ENDIF
     42  2bd4					      ENDM		; @push
     43  2bd4
     44  2bd4							; Pull byte on stack to variable
     45  2bd4					      MAC	plbytevar
     46  2bd4					      IF	!FPULL
     47  2bd4					      pla
     48  2bd4					      ENDIF
     49  2bd4					      sta	{1}
     50  2bd4					      ENDM		; @pull
     51  2bd4
     52  2bd4							; Pull dynamic byte on stack to variable
     53  2bd4					      MAC	pldynbytevar
     54  2bd4					      IF	!FPULL
     55  2bd4					      pla
     56  2bd4					      ENDIF
     57  2bd4					      ldy	#{1}
     58  2bd4					      sta	(RC),y
     59  2bd4					      ENDM		; @pull
     60  2bd4
     61  2bd4							; Push byte of an array onto stack
     62  2bd4							; (indexed by a word)
     63  2bd4					      MAC	pbytearray
     64  2bd4					      getaddr	{1}
     65  2bd4							; Load and push
     66  2bd4					      ldy	#0
     67  2bd4					      lda	(R0),y
     68  2bd4					      IF	!FPUSH
     69  2bd4					      pha
     70  2bd4					      ENDIF
     71  2bd4					      ENDM		; @pull @push
     72  2bd4
     73  2bd4							; Push byte of an array onto stack
     74  2bd4							; (indexed by a byte)
     75  2bd4					      MAC	pbytearrayfast
     76  2bd4					      IF	!FPULL
     77  2bd4					      pla
     78  2bd4					      ENDIF
     79  2bd4					      tax
     80  2bd4					      lda	{1},x
     81  2bd4					      IF	!FPUSH
     82  2bd4					      pha
     83  2bd4					      ENDIF
     84  2bd4					      ENDM		; @pull @push
     85  2bd4
     86  2bd4							; Push byte of a dynamic array onto stack
     87  2bd4							; (indexed by a byte)
     88  2bd4							; Variable name (offset) in {1}
     89  2bd4					      MAC	pdynbytearrayfast
     90  2bd4					      getdynaddr
     91  2bd4					      ldy	#{1}
     92  2bd4					      lda	(R0),y
     93  2bd4					      IF	!FPUSH
     94  2bd4					      pha
     95  2bd4					      ENDIF
     96  2bd4					      ENDM		; @pull @push
     97  2bd4
     98  2bd4							; Pull byte off of stack and store in array
     99  2bd4							; (indexed by a word)
    100  2bd4					      MAC	plbytearray
    101  2bd4					      getaddr	{1}
    102  2bd4					      pla
    103  2bd4					      ldy	#0
    104  2bd4					      sta	(R0),y
    105  2bd4					      ENDM		; @pull
    106  2bd4
    107  2bd4							; Pull byte off of stack and store in array
    108  2bd4							; (indexed by a byte)
    109  2bd4					      MAC	plbytearrayfast
    110  2bd4					      IF	!FPULL
    111  2bd4					      pla
    112  2bd4					      ENDIF
    113  2bd4					      tax
    114  2bd4					      pla
    115  2bd4					      sta	{1},x
    116  2bd4					      ENDM		; @pull
    117  2bd4
    118  2bd4							; Pull byte off of stack and store in dynamic array
    119  2bd4							; (indexed by a byte)
    120  2bd4					      MAC	pldynbytearrayfast
    121  2bd4					      getdynaddr
    122  2bd4					      ldy	#{1}
    123  2bd4					      pla
    124  2bd4					      sta	(R0),y
    125  2bd4					      ENDM		; @pull
    126  2bd4
    127  2bd4							; Push relative byte variable (e.g this.something)
    128  2bd4					      MAC	prelativebytevar
    129  2bd4					      ldy	#{1}
    130  2bd4					      lda	(TH),y
    131  2bd4					      IF	!FPUSH
    132  2bd4					      pha
    133  2bd4					      ENDIF
    134  2bd4					      ENDM		; @push
    135  2bd4
    136  2bd4							; Pull byte value and store in relative byte variable
    137  2bd4							; (e.g this.something)
    138  2bd4					      MAC	plrelativebytevar
    139  2bd4					      IF	!FPULL
    140  2bd4					      pla
    141  2bd4					      ENDIF
    142  2bd4					      ldy	#{1}
    143  2bd4					      sta	(TH),y
    144  2bd4					      ENDM		; @pull
------- FILE core/stack/stack.asm
------- FILE core/stack/_word.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/stack/_word.asm"
      1  2bd4							; Push immediate word onto stack
      2  2bd4					      MAC	pword
      3  2bd4					      IF	!FPUSH
      4  2bd4					      lda	#<{1}
      5  2bd4					      pha
      6  2bd4					      lda	#>{1}
      7  2bd4					      pha
      8  2bd4					      ELSE
      9  2bd4					      lda	#<{1}
     10  2bd4					      ldy	#>{1}
     11  2bd4					      ENDIF
     12  2bd4					      ENDM		; @push
     13  2bd4
     14  2bd4							; Push address to stack
     15  2bd4					      MAC	paddr
     16  2bd4					      pword	{1}
     17  2bd4					      ENDM		; @push
     18  2bd4
     19  2bd4							; Push one word variable onto stack
     20  2bd4					      MAC	pwordvar
     21  2bd4					      IF	!FPUSH
     22  2bd4					      lda	{1}
     23  2bd4					      pha
     24  2bd4					      lda	{1}+1
     25  2bd4					      pha
     26  2bd4					      ELSE
     27  2bd4					      lda	{1}
     28  2bd4					      ldy	{1}+1
     29  2bd4					      ENDIF
     30  2bd4					      ENDM		; @push
     31  2bd4
     32  2bd4							; Push one dynamic word variable onto stack
     33  2bd4					      MAC	pdynwordvar
     34  2bd4					      ldy	#{1}
     35  2bd4					      IF	!FPUSH
     36  2bd4					      lda	(RC),y
     37  2bd4					      pha
     38  2bd4					      iny
     39  2bd4					      lda	(RC),y
     40  2bd4					      pha
     41  2bd4					      ELSE
     42  2bd4					      lda	(RC),y
     43  2bd4					      tax
     44  2bd4					      iny
     45  2bd4					      lda	(RC),y
     46  2bd4					      tay
     47  2bd4					      txa
     48  2bd4					      ENDIF
     49  2bd4					      ENDM		; @push
     50  2bd4
     51  2bd4							; Pull word on stack to variable
     52  2bd4					      MAC	plwordvar
     53  2bd4					      IF	!FPULL
     54  2bd4					      pla
     55  2bd4					      sta	{1}+1
     56  2bd4					      pla
     57  2bd4					      sta	{1}
     58  2bd4					      ELSE
     59  2bd4					      sta	{1}
     60  2bd4					      sty	{1}+1
     61  2bd4					      ENDIF
     62  2bd4					      ENDM		; @pull
     63  2bd4
     64  2bd4							; Pull dynamic word on stack to variable
     65  2bd4					      MAC	pldynwordvar
     66  2bd4					      ldy	#[{1} + 1]
     67  2bd4					      pla
     68  2bd4					      sta	(RC),y
     69  2bd4					      pla
     70  2bd4					      dey
     71  2bd4					      sta	(RC),y
     72  2bd4					      ENDM
     73  2bd4
     74  2bd4							; Push word of an array onto stack
     75  2bd4							; (indexed by a word)
     76  2bd4					      MAC	pwordarray
     77  2bd4					      getaddr	{1}
     78  2bd4							; Load and push
     79  2bd4					      ldy	#0
     80  2bd4					      lda	(R0),y
     81  2bd4					      pha
     82  2bd4					      iny
     83  2bd4					      lda	(R0),y
     84  2bd4					      pha
     85  2bd4					      ENDM		; @pull
     86  2bd4
     87  2bd4							; Push word of an array onto stack
     88  2bd4							; (indexed by a byte)
     89  2bd4					      MAC	pwordarrayfast
     90  2bd4					      IF	!FPULL
     91  2bd4					      pla
     92  2bd4					      ENDIF
     93  2bd4					      tax
     94  2bd4					      IF	!FPUSH
     95  2bd4					      lda	{1},x
     96  2bd4					      pha
     97  2bd4					      lda	[{1} + 1],x
     98  2bd4					      pha
     99  2bd4					      ELSE
    100  2bd4					      lda	{1},x
    101  2bd4					      ldy	[{1} + 1],x
    102  2bd4					      ENDIF
    103  2bd4					      ENDM		; @pull @push
    104  2bd4
    105  2bd4							; Pull word off of stack and store in array
    106  2bd4							; (indexed by a word)
    107  2bd4					      MAC	plwordarray
    108  2bd4					      getaddr	{1}
    109  2bd4					      pla
    110  2bd4					      ldy	#1
    111  2bd4					      sta	(R0),y
    112  2bd4					      dey
    113  2bd4					      pla
    114  2bd4					      sta	(R0),y
    115  2bd4					      ENDM		; @pull
    116  2bd4
    117  2bd4							; Pull word off of stack and store in array
    118  2bd4							; (indexed by a byte)
    119  2bd4					      MAC	plwordarrayfast
    120  2bd4					      IF	!FPULL
    121  2bd4					      pla
    122  2bd4					      ENDIF
    123  2bd4					      tax
    124  2bd4					      pla
    125  2bd4					      sta	[{1} + 1],x
    126  2bd4					      pla
    127  2bd4					      sta	{1},x
    128  2bd4					      ENDM		; @pull
    129  2bd4
    130  2bd4							; Push relative word variable (e.g this.something)
    131  2bd4					      MAC	prelativewordvar
    132  2bd4					      ldy	#{1}
    133  2bd4					      lda	(TH),y
    134  2bd4					      pha
    135  2bd4					      iny
    136  2bd4					      lda	(TH),y
    137  2bd4					      pha
    138  2bd4					      ENDM
    139  2bd4
    140  2bd4							; Pull int value and store in relative word variable
    141  2bd4							; (e.g this.something)
    142  2bd4					      MAC	plrelativewordvar
    143  2bd4					      pla
    144  2bd4					      ldy	#[{1} + 1]
    145  2bd4					      sta	(TH),y
    146  2bd4					      pla
    147  2bd4					      dey
    148  2bd4					      sta	(TH),y
    149  2bd4					      ENDM
------- FILE core/stack/stack.asm
------- FILE core/stack/_int.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/stack/_int.asm"
      1  2bd4							; Push immediate int onto stack
      2  2bd4					      MAC	pint
      3  2bd4					      pword	{1}
      4  2bd4					      ENDM		; @push
      5  2bd4
      6  2bd4							; Push one int variable onto stack
      7  2bd4					      MAC	pintvar
      8  2bd4					      pwordvar	{1}
      9  2bd4					      ENDM		; @push
     10  2bd4
     11  2bd4							; Pull int on stack to variable
     12  2bd4					      MAC	plintvar
     13  2bd4					      plwordvar	{1}
     14  2bd4					      ENDM		; @pull
     15  2bd4
     16  2bd4							; Push int of an array onto stack
     17  2bd4							; (indexed by a word)
     18  2bd4					      MAC	pintarray
     19  2bd4					      pwordarray	{1}
     20  2bd4					      ENDM		; @pull
     21  2bd4
     22  2bd4							; Push int of an array onto stack
     23  2bd4							; (indexed by a byte)
     24  2bd4					      MAC	pintarrayfast
     25  2bd4					      pwordarrayfast	{1}
     26  2bd4					      ENDM		; @pull @push
     27  2bd4
     28  2bd4							; Pull int off of stack and store in array
     29  2bd4							; (indexed by a word)
     30  2bd4					      MAC	plintarray
     31  2bd4					      plwordarray	{1}
     32  2bd4					      ENDM		; @pull
     33  2bd4
     34  2bd4							; Pull int off of stack and store in array
     35  2bd4							; (indexed by a byte)
     36  2bd4					      MAC	plintarrayfast
     37  2bd4					      plwordarrayfast	{1}
     38  2bd4					      ENDM		; @pull
     39  2bd4
     40  2bd4							; Pull dynamic int on stack to variable
     41  2bd4					      MAC	pldynintvar
     42  2bd4					      pldynwordvar	{1}
     43  2bd4					      ENDM		; @pull
     44  2bd4
     45  2bd4							; Push one dynamic word variable onto stack
     46  2bd4					      MAC	pdynintvar
     47  2bd4					      pdynwordvar	{1}
     48  2bd4					      ENDM		; @push
     49  2bd4
     50  2bd4							; Push relative int variable (e.g this.something)
     51  2bd4					      MAC	prelativeintvar
     52  2bd4					      prelativewordvar	{1}
     53  2bd4					      ENDM
     54  2bd4
     55  2bd4							; Pull int value and store in relative int variable
     56  2bd4							; (e.g this.something)
     57  2bd4					      MAC	plrelativeintvar
     58  2bd4					      plrelativewordvar	{1}
     59  2bd4					      ENDM
------- FILE core/stack/stack.asm
------- FILE core/stack/_long.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/stack/_long.asm"
      1  2bd4							; Push a long int onto the stack
      2  2bd4					      MAC	plong
      3  2bd4					      IF	!FPUSH
      4  2bd4					      lda	#<{1}
      5  2bd4					      pha
      6  2bd4					      lda	#>{1}
      7  2bd4					      pha
      8  2bd4					      lda	#[{1} >> 16]
      9  2bd4					      pha
     10  2bd4					      ELSE
     11  2bd4					      lda	#<{1}
     12  2bd4					      ldy	#>{1}
     13  2bd4					      ldx	#[{1} >> 16]
     14  2bd4					      ENDIF
     15  2bd4					      ENDM		; @push
     16  2bd4
     17  2bd4							; Push a long int variable on the stack
     18  2bd4					      MAC	plongvar
     19  2bd4					      IF	!FPUSH
     20  2bd4					      lda	{1}
     21  2bd4					      pha
     22  2bd4					      lda	{1} + 1
     23  2bd4					      pha
     24  2bd4					      lda	{1} + 2
     25  2bd4					      pha
     26  2bd4					      ELSE
     27  2bd4					      lda	{1}
     28  2bd4					      ldy	{1} + 1
     29  2bd4					      ldx	{1} + 2
     30  2bd4					      ENDIF
     31  2bd4					      ENDM		; @push
     32  2bd4
     33  2bd4							; Push one dynamic long variable onto stack
     34  2bd4					      MAC	pdynlongvar
     35  2bd4					      ldy	#[{1} + 2]
     36  2bd4					      lda	(RC),y
     37  2bd4					      pha
     38  2bd4					      dey
     39  2bd4					      lda	(RC),y
     40  2bd4					      pha
     41  2bd4					      dey
     42  2bd4					      lda	(RC),y
     43  2bd4					      pha
     44  2bd4					      ENDM
     45  2bd4
     46  2bd4							; Pull dynamic long on stack to variable
     47  2bd4					      MAC	pldynlongvar
     48  2bd4					      ldy	#{1}
     49  2bd4					      pla
     50  2bd4					      sta	(RC),y
     51  2bd4					      pla
     52  2bd4					      iny
     53  2bd4					      sta	(RC),y
     54  2bd4					      pla
     55  2bd4					      iny
     56  2bd4					      sta	(RC),y
     57  2bd4					      ENDM
     58  2bd4
     59  2bd4							; Pull long int to variable
     60  2bd4					      MAC	pllongvar
     61  2bd4					      IF	!FPULL
     62  2bd4					      pla
     63  2bd4					      sta	{1}+2
     64  2bd4					      pla
     65  2bd4					      sta	{1}+1
     66  2bd4					      pla
     67  2bd4					      sta	{1}
     68  2bd4					      ELSE
     69  2bd4					      sta	{1}
     70  2bd4					      sty	{1}+1
     71  2bd4					      stx	{1}+2
     72  2bd4					      ENDIF
     73  2bd4					      ENDM		; @pull
     74  2bd4
     75  2bd4							; Push longint of an array onto stack
     76  2bd4							; (indexed by a word)
     77  2bd4					      MAC	plongarray
     78  2bd4					      getaddr	{1}
     79  2bd4							; Load and push
     80  2bd4					      ldy	#0
     81  2bd4					      lda	(R0),y
     82  2bd4					      pha
     83  2bd4					      iny
     84  2bd4					      lda	(R0),y
     85  2bd4					      pha
     86  2bd4					      iny
     87  2bd4					      lda	(R0),y
     88  2bd4					      pha
     89  2bd4					      ENDM		; @pull
     90  2bd4
     91  2bd4							; Push long int of an array onto stack
     92  2bd4							; (indexed by a byte)
     93  2bd4					      MAC	plongarrayfast
     94  2bd4					      IF	!FPULL
     95  2bd4					      pla
     96  2bd4					      ENDIF
     97  2bd4					      tax
     98  2bd4					      lda	{1},x
     99  2bd4					      pha
    100  2bd4					      lda	[{1} + 1],x
    101  2bd4					      pha
    102  2bd4					      lda	[{1} + 2],x
    103  2bd4					      pha
    104  2bd4					      ENDM		; @pull
    105  2bd4
    106  2bd4							; Pull long int off of stack and store in array
    107  2bd4							; (indexed by a word)
    108  2bd4					      MAC	pllongarray
    109  2bd4					      getaddr	{1}
    110  2bd4					      ldy	#2
    111  2bd4					      pla
    112  2bd4					      sta	(R0),y
    113  2bd4					      dey
    114  2bd4					      pla
    115  2bd4					      sta	(R0),y
    116  2bd4					      dey
    117  2bd4					      pla
    118  2bd4					      sta	(R0),y
    119  2bd4					      ENDM		; @pull
    120  2bd4
    121  2bd4							; Pull long int off of stack and store in array
    122  2bd4							; (indexed by a byte)
    123  2bd4					      MAC	pllongarrayfast
    124  2bd4					      IF	!FPULL
    125  2bd4					      pla
    126  2bd4					      ENDIF
    127  2bd4					      tax
    128  2bd4					      pla
    129  2bd4					      sta	[{1} + 2],x
    130  2bd4					      pla
    131  2bd4					      sta	[{1} + 1],x
    132  2bd4					      pla
    133  2bd4					      sta	{1},x
    134  2bd4					      ENDM		; @pull
    135  2bd4
    136  2bd4							; Push relative long variable (e.g this.something)
    137  2bd4					      MAC	prelativelongvar
    138  2bd4					      ldy	#{1}
    139  2bd4					      lda	(TH),y
    140  2bd4					      pha
    141  2bd4					      iny
    142  2bd4					      lda	(TH),y
    143  2bd4					      pha
    144  2bd4					      iny
    145  2bd4					      lda	(TH),y
    146  2bd4					      pha
    147  2bd4					      ENDM
    148  2bd4
    149  2bd4							; Pull long value and store in relative long variable
    150  2bd4							; (e.g this.something)
    151  2bd4					      MAC	plrelativelongvar
    152  2bd4					      pla
    153  2bd4					      ldy	#[{1} + 2]
    154  2bd4					      sta	(TH),y
    155  2bd4					      pla
    156  2bd4					      dey
    157  2bd4					      sta	(TH),y
    158  2bd4					      pla
    159  2bd4					      dey
    160  2bd4					      sta	(TH),y
    161  2bd4					      ENDM
------- FILE core/stack/stack.asm
------- FILE core/stack/_float.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/stack/_float.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Push immediate float on stack
      4  2bd4							; Expects 4 bytes, e. g pfloat 01,02,FE,FF
      5  2bd4							; TO ALLOW DIRECT COMPARISON OF NUMBERS
      6  2bd4							; IN FAC AND ON STACK, FLOATS ARE
      7  2bd4							; PUSHED IN REVERSE ORDER, M3-M2-M1-E
      8  2bd4					      MAC	pfloat
      9  2bd4					      lda	#${4}
     10  2bd4					      pha
     11  2bd4					      IF	!FPUSH
     12  2bd4					      lda	#${3}
     13  2bd4					      pha
     14  2bd4					      lda	#${2}
     15  2bd4					      pha
     16  2bd4					      lda	#${1}
     17  2bd4					      pha
     18  2bd4					      ELSE
     19  2bd4					      lda	#${3}
     20  2bd4					      ldy	#${2}
     21  2bd4					      ldx	#${1}
     22  2bd4					      ENDIF
     23  2bd4					      ENDM		; @push
     24  2bd4
     25  2bd4							; Push float variable on stack
     26  2bd4					      MAC	pfloatvar
     27  2bd4					      lda	{1} + 3
     28  2bd4					      pha
     29  2bd4					      IF	!FPUSH
     30  2bd4					      lda	{1} + 2
     31  2bd4					      pha
     32  2bd4					      lda	{1} + 1
     33  2bd4					      pha
     34  2bd4					      lda	{1}
     35  2bd4					      pha
     36  2bd4					      ELSE
     37  2bd4					      lda	{1} + 2
     38  2bd4					      ldy	{1} + 1
     39  2bd4					      ldx	{1}
     40  2bd4					      ENDIF
     41  2bd4					      ENDM		; @push
     42  2bd4
     43  2bd4							; Pull float on stack to variable
     44  2bd4					      MAC	plfloatvar
     45  2bd4					      IF	!FPULL
     46  2bd4					      pla
     47  2bd4					      sta	{1}
     48  2bd4					      pla
     49  2bd4					      sta	{1} + 1
     50  2bd4					      pla
     51  2bd4					      sta	{1} + 2
     52  2bd4					      ELSE
     53  2bd4					      stx	{1}
     54  2bd4					      sty	{1} + 1
     55  2bd4					      sta	{1} + 2
     56  2bd4					      ENDIF
     57  2bd4					      pla
     58  2bd4					      sta	{1} + 3
     59  2bd4					      ENDM		; @pull
     60  2bd4
     61  2bd4							; Push float of an array onto stack
     62  2bd4							; (indexed by a word)
     63  2bd4					      MAC	pfloatarray
     64  2bd4					      getaddr	{1}
     65  2bd4							; Load and push
     66  2bd4					      ldy	#3
     67  2bd4					      lda	(R0),y
     68  2bd4					      pha
     69  2bd4					      dey
     70  2bd4					      lda	(R0),y
     71  2bd4					      pha
     72  2bd4					      dey
     73  2bd4					      lda	(R0),y
     74  2bd4					      pha
     75  2bd4					      dey
     76  2bd4					      lda	(R0),y
     77  2bd4					      pha
     78  2bd4					      ENDM		; @pull
     79  2bd4
     80  2bd4							; Push float of an array onto stack
     81  2bd4							; (indexed by a byte)
     82  2bd4					      MAC	pfloatarrayfast
     83  2bd4					      IF	!FPULL
     84  2bd4					      pla
     85  2bd4					      ENDIF
     86  2bd4					      tax
     87  2bd4					      lda.wx	{1} + 3
     88  2bd4					      pha
     89  2bd4					      lda.wx	{1} + 2
     90  2bd4					      pha
     91  2bd4					      lda.wx	{1} + 1
     92  2bd4					      pha
     93  2bd4					      lda	{1},x
     94  2bd4					      pha
     95  2bd4					      ENDM		; @pull
     96  2bd4
     97  2bd4							; Pull long int off of stack and store in array
     98  2bd4							; (indexed by a word)
     99  2bd4					      MAC	plfloatarray
    100  2bd4					      getaddr	{1}
    101  2bd4					      ldy	#0
    102  2bd4					      pla
    103  2bd4					      sta	(R0),y
    104  2bd4					      iny
    105  2bd4					      pla
    106  2bd4					      sta	(R0),y
    107  2bd4					      iny
    108  2bd4					      pla
    109  2bd4					      sta	(R0),y
    110  2bd4					      iny
    111  2bd4					      pla
    112  2bd4					      sta	(R0),y
    113  2bd4					      ENDM		; @pull
    114  2bd4
    115  2bd4							; Pull float off of stack and store in array
    116  2bd4							; (indexed by a byte)
    117  2bd4					      MAC	plfloatarrayfast
    118  2bd4					      IF	!FPULL
    119  2bd4					      pla
    120  2bd4					      ENDIF
    121  2bd4					      tax
    122  2bd4					      pla
    123  2bd4					      sta	{1},x
    124  2bd4					      pla
    125  2bd4					      sta.wx	{1} + 1
    126  2bd4					      pla
    127  2bd4					      sta.wx	{1} + 2
    128  2bd4					      pla
    129  2bd4					      sta.wx	{1} + 3
    130  2bd4					      ENDM		; @pull
    131  2bd4
    132  2bd4							; Pull float off of stack into FAC
    133  2bd4					      MAC	plfloattofac
    134  2bd4					      IF	!FPULL
    135  2bd4					      pla
    136  2bd4					      sta	FAC
    137  2bd4					      pla
    138  2bd4					      sta	FACSIGN
    139  2bd4					      ora	#%10000000
    140  2bd4					      sta	FAC + 1
    141  2bd4					      pla
    142  2bd4					      sta	FAC + 2
    143  2bd4					      ELSE
    144  2bd4					      sta	FAC + 2
    145  2bd4					      tya
    146  2bd4					      sta	FACSIGN
    147  2bd4					      ora	#%10000000
    148  2bd4					      sta	FAC + 1
    149  2bd4					      stx	FAC
    150  2bd4					      ENDIF
    151  2bd4					      pla
    152  2bd4					      sta	FAC + 3
    153  2bd4					      lda	#$00
    154  2bd4					      sta	FACEXTENSION
    155  2bd4					      ENDM		; @pull
    156  2bd4
    157  2bd4							; Pull float off of stack into ARG
    158  2bd4					      MAC	plfloattoarg
    159  2bd4					      IF	!FPULL
    160  2bd4					      pla
    161  2bd4					      sta	ARG
    162  2bd4					      pla
    163  2bd4					      sta	ARGSIGN
    164  2bd4					      eor	FACSIGN
    165  2bd4					      sta	SGNCPR
    166  2bd4					      lda	ARGSIGN
    167  2bd4					      ora	#%10000000
    168  2bd4					      sta	ARG + 1
    169  2bd4					      pla
    170  2bd4					      sta	ARG + 2
    171  2bd4					      ELSE
    172  2bd4					      sta	ARG
    173  2bd4					      tya
    174  2bd4					      sta	ARGSIGN
    175  2bd4					      eor	FACSIGN
    176  2bd4					      sta	SGNCPR
    177  2bd4					      lda	ARGSIGN
    178  2bd4					      ora	#%10000000
    179  2bd4					      sta	ARG + 1
    180  2bd4					      stx	ARG + 2
    181  2bd4					      ENDIF
    182  2bd4					      pla
    183  2bd4					      sta	ARG + 3
    184  2bd4					      lda	FAC
    185  2bd4					      ENDM		; @pull
    186  2bd4
    187  2bd4							; Round and push float in FAC onto stack
    188  2bd4					      MAC	pfac
    189  2bd4					      import	I_FPLIB
    190  2bd4					      jsr	ROUND_FAC
    191  2bd4					      lda	#$00
    192  2bd4					      sta	FACEXTENSION
    193  2bd4					      lda	FAC + 3
    194  2bd4					      pha
    195  2bd4					      IF	!FPUSH
    196  2bd4					      lda	FAC + 2
    197  2bd4					      pha
    198  2bd4					      lda	FACSIGN
    199  2bd4					      ora	#$7F
    200  2bd4					      and	FAC + 1
    201  2bd4					      pha
    202  2bd4					      lda	FAC
    203  2bd4					      pha
    204  2bd4					      ELSE
    205  2bd4					      lda	FACSIGN
    206  2bd4					      ora	#$7F
    207  2bd4					      and	FAC + 1
    208  2bd4					      tay
    209  2bd4					      ldx	FAC
    210  2bd4					      lda	FAC + 2
    211  2bd4					      ENDIF
    212  2bd4					      ENDM		; @push
    213  2bd4
    214  2bd4							; Push one dynamic float variable onto stack
    215  2bd4					      MAC	pdynfloatvar
    216  2bd4					      ldy	#[{1} + 3]
    217  2bd4					      lda	(RC),y
    218  2bd4					      pha
    219  2bd4					      REPEAT	3
    220  2bd4					      dey
    221  2bd4					      lda	(RC),y
    222  2bd4					      pha
    223  2bd4					      REPEND
    224  2bd4					      ENDM
    225  2bd4
    226  2bd4							; Pull dynamic float on stack to variable
    227  2bd4					      MAC	pldynfloatvar
    228  2bd4					      ldy	#{1}
    229  2bd4					      pla
    230  2bd4					      sta	(RC),y
    231  2bd4					      REPEAT	3
    232  2bd4					      pla
    233  2bd4					      iny
    234  2bd4					      sta	(RC),y
    235  2bd4					      REPEND
    236  2bd4					      ENDM
    237  2bd4
    238  2bd4							; Push relative word variable (e.g this.something)
    239  2bd4					      MAC	prelativefloatvar
    240  2bd4					      ldy	#[{1} + 3]
    241  2bd4					      lda	(TH),y
    242  2bd4					      pha
    243  2bd4					      REPEAT	3
    244  2bd4					      dey
    245  2bd4					      lda	(TH),y
    246  2bd4					      pha
    247  2bd4					      REPEND
    248  2bd4					      ENDM
    249  2bd4
    250  2bd4							; Pull int value and store in relative word variable
    251  2bd4							; (e.g this.something)
    252  2bd4					      MAC	plrelativefloatvar
    253  2bd4					      ldy	#{1}
    254  2bd4					      pla
    255  2bd4					      sta	(TH),y
    256  2bd4					      REPEAT	3
    257  2bd4					      pla
    258  2bd4					      iny
    259  2bd4					      sta	(TH),y
    260  2bd4					      REPEND
    261  2bd4					      ENDM
------- FILE core/stack/stack.asm
------- FILE core/stack/_decimal.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/stack/_decimal.asm"
      1  2bd4							; Push immediate decimal onto stack
      2  2bd4					      MAC	pdecimal
      3  2bd4					      IF	!FPUSH
      4  2bd4					      lda	#${1}
      5  2bd4					      pha
      6  2bd4					      lda	#${2}
      7  2bd4					      pha
      8  2bd4					      ELSE
      9  2bd4					      lda	#${1}
     10  2bd4					      ldy	#${2}
     11  2bd4					      ENDIF
     12  2bd4					      ENDM		; @push
     13  2bd4
     14  2bd4							; Push one decimal variable onto stack
     15  2bd4					      MAC	pdecimalvar
     16  2bd4					      pwordvar	{1}
     17  2bd4					      ENDM		; @push
     18  2bd4
     19  2bd4							; Pull decimal on stack to variable
     20  2bd4					      MAC	pldecimalvar
     21  2bd4					      plwordvar	{1}
     22  2bd4					      ENDM		; @pull
     23  2bd4
     24  2bd4							; Push decimal of an array onto stack
     25  2bd4							; (indexed by a word)
     26  2bd4					      MAC	pdecimalarray
     27  2bd4					      pwordarray	{1}
     28  2bd4					      ENDM		; @pull
     29  2bd4
     30  2bd4							; Push decimal of an array onto stack
     31  2bd4							; (indexed by a byte)
     32  2bd4					      MAC	pdecimalarrayfast
     33  2bd4					      pwordarrayfast	{1}
     34  2bd4					      ENDM		; @pull @push
     35  2bd4
     36  2bd4							; Pull decimal off of stack and store in array
     37  2bd4							; (indexed by a word)
     38  2bd4					      MAC	pldecimalarray
     39  2bd4					      plwordarray	{1}
     40  2bd4					      ENDM		; @pull
     41  2bd4
     42  2bd4							; Pull decimal off of stack and store in array
     43  2bd4							; (indexed by a byte)
     44  2bd4					      MAC	pldecimalarrayfast
     45  2bd4					      plwordarrayfast	{1}
     46  2bd4					      ENDM		; @pull
     47  2bd4
     48  2bd4							; Pull dynamic decimal on stack to variable
     49  2bd4					      MAC	pldyndecimalvar
     50  2bd4					      pldynwordvar	{1}
     51  2bd4					      ENDM		; @pull
     52  2bd4
     53  2bd4							; Push one dynamic decimal variable onto stack
     54  2bd4					      MAC	pdyndecimalvar
     55  2bd4					      pdynwordvar	{1}
     56  2bd4					      ENDM		; @push
     57  2bd4
     58  2bd4							; Push relative decimal variable (e.g this.something)
     59  2bd4					      MAC	prelativedecimalvar
     60  2bd4					      prelativewordvar	{1}
     61  2bd4					      ENDM
     62  2bd4
     63  2bd4							; Pull decimal value and store in relative decimal variable
     64  2bd4							; (e.g this.something)
     65  2bd4					      MAC	plrelativedecimalvar
     66  2bd4					      plrelativewordvar	{1}
     67  2bd4					      ENDM
------- FILE core/stack/stack.asm
------- FILE core/stack/_udt.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/stack/_udt.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Push variable of user defined type onto stack
      4  2bd4							; Variable label in {1}
      5  2bd4							; Number of bytes in {2}
      6  2bd4					      MAC	pudtvar
      7  2bd4					      ldx	#0
      8  2bd4				   .do
      9  2bd4					      lda.wx	{1}
     10  2bd4					      pha
     11  2bd4					      inx
     12  2bd4					      cpx	#{2}
     13  2bd4					      bcc	.do
     14  2bd4					      ENDM
     15  2bd4
     16  2bd4							; Pull value of user defined type off of stack into variable
     17  2bd4							; Variable label in {1}
     18  2bd4							; Number of bytes in {2}
     19  2bd4					      MAC	pludtvar
     20  2bd4					      ldx	#{2}
     21  2bd4				   .do
     22  2bd4					      pla
     23  2bd4					      sta.wx	{1} - 1
     24  2bd4					      dex
     25  2bd4					      bne	.do
     26  2bd4					      ENDM
     27  2bd4
     28  2bd4							; Push user defined type of an array onto stack
     29  2bd4							; (indexed by a word)
     30  2bd4							; Variable label in {1}
     31  2bd4							; Number of bytes in {2}
     32  2bd4					      MAC	pudtarray
     33  2bd4					      getaddr	{1}
     34  2bd4							; Load and push
     35  2bd4					      ldy	#0
     36  2bd4				   .do
     37  2bd4					      lda	(R0),y
     38  2bd4					      pha
     39  2bd4					      iny
     40  2bd4					      cpy	#{2}
     41  2bd4					      bcc	.do
     42  2bd4					      ENDM		; @pull
     43  2bd4
     44  2bd4							; Push byte of an array onto stack
     45  2bd4							; (indexed by a byte)
     46  2bd4							; Variable label in {1}
     47  2bd4							; Number of bytes in {2}
     48  2bd4					      MAC	pudtarrayfast
     49  2bd4					      IF	!FPULL
     50  2bd4					      pla
     51  2bd4					      ENDIF
     52  2bd4					      tay
     53  2bd4					      sta	R0
     54  2bd4					      clc
     55  2bd4					      adc	#{2}
     56  2bd4					      sta	R0
     57  2bd4				   .do
     58  2bd4					      lda	{1},y
     59  2bd4					      pha
     60  2bd4					      iny
     61  2bd4					      cpy	R0
     62  2bd4					      bcc	.do
     63  2bd4					      ENDM		; @pull
     64  2bd4
     65  2bd4							; Pull value of user defined type off of stack
     66  2bd4							; and store in array (indexed by a word)
     67  2bd4					      MAC	pludtarray
     68  2bd4					      getaddr	[{1} - 1]
     69  2bd4					      ldy	#{2}
     70  2bd4				   .do
     71  2bd4					      pla
     72  2bd4					      sta	(R0),y
     73  2bd4					      dey
     74  2bd4					      bne	.do
     75  2bd4					      ENDM		; @pull
     76  2bd4
     77  2bd4							; Pull value of user defined type off of stack
     78  2bd4							; and store in array (indexed by a byte)
     79  2bd4					      MAC	pludtarrayfast
     80  2bd4					      IF	!FPULL
     81  2bd4					      pla
     82  2bd4					      ENDIF
     83  2bd4					      sta	R0
     84  2bd4					      inc	R0
     85  2bd4					      clc
     86  2bd4					      adc	#{2}
     87  2bd4					      tay
     88  2bd4				   .do
     89  2bd4					      pla
     90  2bd4					      sta.wy	{1} - 1
     91  2bd4					      dey
     92  2bd4					      cpy	R0
     93  2bd4					      bcs	.do
     94  2bd4					      ENDM		; @pull
     95  2bd4
     96  2bd4							; Push one dynamic udt variable onto stack
     97  2bd4							; Relative address of var in {1}
     98  2bd4							; Type length in {2}
     99  2bd4					      MAC	pdynudtvar
    100  2bd4					      ldy	#{1}
    101  2bd4				   .loop
    102  2bd4					      lda	(RC),y
    103  2bd4					      pha
    104  2bd4					      iny
    105  2bd4					      cpy	#[{1} + {2}]
    106  2bd4					      bcc	.loop
    107  2bd4					      ENDM
    108  2bd4
    109  2bd4							; Pull dynamic udt on stack to variable
    110  2bd4							; Relative address of var in {1}
    111  2bd4							; Type length in {2}
    112  2bd4					      MAC	pldynudtvar
    113  2bd4					      ldy	#[{1} + {2} - 1]
    114  2bd4				   .loop
    115  2bd4					      pla
    116  2bd4					      sta	(RC),y
    117  2bd4					      dey
    118  2bd4					      cpy	#{1}
    119  2bd4					      bpl	.loop
    120  2bd4					      ENDM
    121  2bd4
    122  2bd4							; Push relative udt variable (e.g this.something)
    123  2bd4							; Relative address of var in {1}
    124  2bd4							; Type length in {2}
    125  2bd4					      MAC	prelativeudtvar
    126  2bd4					      ldy	#{1}
    127  2bd4				   .loop
    128  2bd4					      lda	(TH),y
    129  2bd4					      pha
    130  2bd4					      iny
    131  2bd4					      cpy	#[{1} + {2}]
    132  2bd4					      bcc	.loop
    133  2bd4					      ENDM
    134  2bd4
    135  2bd4							; Pull udt value and store in relative udt variable
    136  2bd4							; (e.g this.something)
    137  2bd4							; Relative address of var in {1}
    138  2bd4							; Type length in {2}
    139  2bd4					      MAC	plrelativeudtvar
    140  2bd4					      ldy	#[{1} + {2} - 1]
    141  2bd4				   .loop
    142  2bd4					      pla
    143  2bd4					      sta	(TH),y
    144  2bd4					      dey
    145  2bd4					      cpy	#{1}
    146  2bd4					      bpl	.loop
    147  2bd4					      ENDM
------- FILE core/stack/stack.asm
    160  2bd4
------- FILE xcb3lib.asm
     15  2bd4							; Conversion between data types
------- FILE core/conv/conv.asm LEVEL 3 PASS 4
      0  2bd4					      INCLUDE	"core/conv/conv.asm"
------- FILE core/conv/_byte.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/conv/_byte.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Convert byte on stack to word on stack
      4  2bd4					      MAC	f_cword_byte
      5  2bd4					      lda	#$00
      6  2bd4					      pha
      7  2bd4					      ENDM
      8  2bd4
      9  2bd4							; Convert byte on stack to int on stack
     10  2bd4					      MAC	f_cint_byte
     11  2bd4					      F_cword_byte
     12  2bd4					      ENDM
     13  2bd4
     14  2bd4							; Convert byte on stack to long on stack
     15  2bd4					      MAC	f_clong_byte
     16  2bd4					      lda	#$00
     17  2bd4					      pha
     18  2bd4					      pha
     19  2bd4					      ENDM
     20  2bd4
     21  2bd4							; Convert byte on stack to float on stack
     22  2bd4					      MAC	f_cfloat_byte
     23  2bd4					      IF	!FPULL
     24  2bd4					      pla
     25  2bd4					      ENDIF
     26  2bd4					      sta	FAC + 1
     27  2bd4					      lda	#$00
     28  2bd4					      sta	FAC + 2
     29  2bd4					      ldx	#$88
     30  2bd4					      sec
     31  2bd4					      import	I_FPLIB
     32  2bd4					      jsr	FLOAT2
     33  2bd4					      pfac
     34  2bd4					      ENDM		; @pull @push
------- FILE core/conv/conv.asm
------- FILE core/conv/_word.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/conv/_word.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Convert word on stack to byte
      4  2bd4					      MAC	f_cbyte_word
      5  2bd4					      pla
      6  2bd4					      ENDM
      7  2bd4
      8  2bd4							; Convert word on stack to integer
      9  2bd4					      MAC	f_cint_word
     10  2bd4					      ENDM
     11  2bd4
     12  2bd4							; Convert word on stack to long
     13  2bd4					      MAC	f_clong_word
     14  2bd4					      lda	#$00
     15  2bd4					      pha
     16  2bd4					      ENDM
     17  2bd4
     18  2bd4							; Convert word on stack to float
     19  2bd4					      MAC	f_cfloat_word
     20  2bd4					      IF	!FPULL
     21  2bd4					      pla
     22  2bd4					      sta	FAC + 1
     23  2bd4					      pla
     24  2bd4					      sta	FAC + 2
     25  2bd4					      ELSE
     26  2bd4					      sta	FAC + 2
     27  2bd4					      sty	FAC + 1
     28  2bd4					      ENDIF
     29  2bd4					      ldx	#$90
     30  2bd4					      import	I_FPLIB
     31  2bd4					      sec
     32  2bd4					      jsr	FLOAT2
     33  2bd4					      pfac
     34  2bd4					      ENDM		; @pull @push
------- FILE core/conv/conv.asm
------- FILE core/conv/_int.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/conv/_int.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Convert int on stack to byte
      4  2bd4					      MAC	f_cbyte_int
      5  2bd4					      pla
      6  2bd4					      ENDM
      7  2bd4
      8  2bd4							; Convert int on stack to word
      9  2bd4					      MAC	f_cword_int
     10  2bd4					      ENDM
     11  2bd4
     12  2bd4							; Convert int on stack to long
     13  2bd4					      MAC	f_clong_int
     14  2bd4					      tsx
     15  2bd4					      lda	stack + 1,x
     16  2bd4					      bpl	.pos
     17  2bd4					      lda	#$ff
     18  2bd4					      bmi	.end
     19  2bd4				   .pos
     20  2bd4					      lda	#$00
     21  2bd4				   .end
     22  2bd4					      pha
     23  2bd4					      ENDM
     24  2bd4
     25  2bd4							; Convert int on stack to float
     26  2bd4					      MAC	f_cfloat_int
     27  2bd4					      IF	!FPULL
     28  2bd4					      pla
     29  2bd4					      sta	FAC + 1
     30  2bd4					      pla
     31  2bd4					      sta	FAC + 2
     32  2bd4					      ELSE
     33  2bd4					      sta	FAC + 2
     34  2bd4					      sty	FAC + 1
     35  2bd4					      ENDIF
     36  2bd4					      ldx	#$90
     37  2bd4					      import	I_FPLIB
     38  2bd4					      jsr	FLOAT1
     39  2bd4					      pfac
     40  2bd4					      ENDM		; @pull @push
------- FILE core/conv/conv.asm
------- FILE core/conv/_long.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/conv/_long.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Convert long int on stack to byte
      4  2bd4					      MAC	f_cbyte_long
      5  2bd4					      pla
      6  2bd4					      pla
      7  2bd4					      ENDM
      8  2bd4
      9  2bd4							; Convert long int on stack to word
     10  2bd4					      MAC	f_cword_long
     11  2bd4					      pla
     12  2bd4					      ENDM
     13  2bd4
     14  2bd4							; Convert long int on stack to int
     15  2bd4					      MAC	f_cint_long
     16  2bd4					      pla
     17  2bd4					      ENDM
     18  2bd4
     19  2bd4							; Convert long int on stack to float
     20  2bd4					      MAC	f_cfloat_long
     21  2bd4					      IF	!FPULL
     22  2bd4					      pla
     23  2bd4					      sta	FAC + 1
     24  2bd4					      eor	#$FF
     25  2bd4					      rol
     26  2bd4					      pla
     27  2bd4					      sta	FAC + 2
     28  2bd4					      pla
     29  2bd4					      sta	FAC + 3
     30  2bd4					      ELSE
     31  2bd4					      sta	FAC + 3
     32  2bd4					      sty	FAC + 2
     33  2bd4					      stx	FAC + 1
     34  2bd4					      txa
     35  2bd4					      eor	#$FF
     36  2bd4					      rol
     37  2bd4					      ENDIF
     38  2bd4					      import	I_LTOF
     39  2bd4					      jsr	LTOF
     40  2bd4					      pfac
     41  2bd4					      ENDM		; @pull @push
     42  2bd4
     43  2bd4				  -	      IFCONST	I_LTOF_IMPORTED
     44  2bd4				  -LTOF       SUBROUTINE
     45  2bd4				  -	      ldx	#$98
     46  2bd4				  -	      stx	FAC
     47  2bd4				  -	      lda	#$00
     48  2bd4				  -	      sta	FACEXTENSION
     49  2bd4				  -	      sta	FACSIGN
     50  2bd4				  -	      import	I_FPLIB
     51  2bd4				  -	      jmp	NORMALIZE_FAC1
     52  2bd4					      ENDIF
------- FILE core/conv/conv.asm
------- FILE core/conv/_float.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/conv/_float.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Convert float on stack to byte
      4  2bd4					      MAC	f_cbyte_float
      5  2bd4					      plfloattofac
      6  2bd4					      import	I_FPLIB
      7  2bd4					      jsr	QINT
      8  2bd4					      lda	FAC + 3
      9  2bd4					      IF	!FPUSH
     10  2bd4					      pha
     11  2bd4					      ENDIF
     12  2bd4					      ENDM		; @pull @push
     13  2bd4
     14  2bd4							; Convert float on stack to int
     15  2bd4					      MAC	f_cint_float
     16  2bd4					      plfloattofac
     17  2bd4					      import	I_FPLIB
     18  2bd4					      jsr	QINT
     19  2bd4					      IF	!FPUSH
     20  2bd4					      lda	FAC + 3
     21  2bd4					      pha
     22  2bd4					      lda	FAC + 2
     23  2bd4					      pha
     24  2bd4					      ELSE
     25  2bd4					      lda	FAC + 3
     26  2bd4					      ldy	FAC + 2
     27  2bd4					      ENDIF
     28  2bd4					      ENDM		; @pull @push
     29  2bd4
     30  2bd4							; Convert float on stack to word
     31  2bd4					      MAC	f_cword_float
     32  2bd4					      F_cint_float
     33  2bd4					      ENDM		; @pull @push
     34  2bd4
     35  2bd4							; Convert float on stack to long
     36  2bd4					      MAC	f_clong_float
     37  2bd4					      plfloattofac
     38  2bd4					      import	I_FPLIB
     39  2bd4					      jsr	QINT
     40  2bd4					      IF	!FPUSH
     41  2bd4					      lda	FAC + 3
     42  2bd4					      pha
     43  2bd4					      lda	FAC + 2
     44  2bd4					      pha
     45  2bd4					      lda	FAC + 1
     46  2bd4					      pha
     47  2bd4					      ELSE
     48  2bd4					      lda	FAC + 3
     49  2bd4					      ldy	FAC + 2
     50  2bd4					      ldx	FAC + 1
     51  2bd4					      ENDIF
     52  2bd4					      ENDM		; @pull @push
------- FILE core/conv/conv.asm
------- FILE xcb3lib.asm
     17  2bd4							; Numeric comparisons
------- FILE core/comp/comp.asm LEVEL 3 PASS 4
      0  2bd4					      INCLUDE	"core/comp/comp.asm"
------- FILE core/comp/_byte.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/comp/_byte.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Compare two bytes on stack for less than
      4  2bd4					      MAC	cmpbytelt
      5  2bd4					      IF	!FPULL
      6  2bd4					      pla
      7  2bd4					      ENDIF
      8  2bd4					      sta	R0
      9  2bd4					      pla
     10  2bd4					      cmp	R0
     11  2bd4					      bcs	.phf
     12  2bd4					      ptrue
     13  2bd4					      bne	.q
     14  2bd4				   .phf       pfalse
     15  2bd4				   .q
     16  2bd4					      ENDM		; @pull @push
     17  2bd4
     18  2bd4							; Compare two bytes on stack for less than or equal
     19  2bd4					      MAC	cmpbytelte
     20  2bd4					      IF	!FPULL
     21  2bd4					      pla
     22  2bd4					      ENDIF
     23  2bd4					      sta	R0
     24  2bd4					      pla
     25  2bd4					      cmp	R0
     26  2bd4					      bcc	.pht
     27  2bd4					      beq	.pht
     28  2bd4					      pfalse
     29  2bd4					      beq	.q
     30  2bd4				   .pht       ptrue
     31  2bd4				   .q
     32  2bd4					      ENDM		; @pull @push
     33  2bd4
     34  2bd4							; Compare two bytes on stack for greater than or equal
     35  2bd4					      MAC	cmpbytegte
     36  2bd4					      IF	!FPULL
     37  2bd4					      pla
     38  2bd4					      ENDIF
     39  2bd4					      sta	R0
     40  2bd4					      pla
     41  2bd4					      cmp	R0
     42  2bd4					      bcs	.pht
     43  2bd4					      pfalse
     44  2bd4					      beq	.q
     45  2bd4				   .pht       ptrue
     46  2bd4				   .q
     47  2bd4					      ENDM		; @pull @push
     48  2bd4
     49  2bd4							; Compare two bytes on stack for equality
     50  2bd4					      MAC	cmpbyteeq
     51  2bd4					      IF	!FPULL
     52  2bd4					      pla
     53  2bd4					      ENDIF
     54  2bd4					      sta	R0
     55  2bd4					      pla
     56  2bd4					      cmp	R0
     57  2bd4					      beq	.pht
     58  2bd4					      pfalse
     59  2bd4					      beq	.q
     60  2bd4				   .pht       ptrue
     61  2bd4				   .q
     62  2bd4					      ENDM		; @pull @push
     63  2bd4
     64  2bd4							; Compare two bytes on stack for inequality
     65  2bd4					      MAC	cmpbyteneq
     66  2bd4					      IF	!FPULL
     67  2bd4					      pla
     68  2bd4					      ENDIF
     69  2bd4					      sta	R0
     70  2bd4					      pla
     71  2bd4					      cmp	R0
     72  2bd4					      bne	.pht
     73  2bd4					      pfalse
     74  2bd4					      beq	.q
     75  2bd4				   .pht       ptrue
     76  2bd4				   .q
     77  2bd4					      ENDM		; @pull @push
     78  2bd4
     79  2bd4							; Compare two bytes on stack for greater than
     80  2bd4					      MAC	cmpbytegt
     81  2bd4					      IF	!FPULL
     82  2bd4					      pla
     83  2bd4					      ENDIF
     84  2bd4					      sta	R0
     85  2bd4					      pla
     86  2bd4					      cmp	R0
     87  2bd4					      bcc	.phf
     88  2bd4					      beq	.phf
     89  2bd4					      ptrue
     90  2bd4					      bne	.q
     91  2bd4				   .phf       pfalse
     92  2bd4				   .q
     93  2bd4					      ENDM		; @pull @push
------- FILE core/comp/comp.asm
------- FILE core/comp/_word.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/comp/_word.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Compare two words on stack for equality
      4  2bd4					      MAC	cmpwordeq
      5  2bd4					      IF	!FPULL
      6  2bd4					      pla
      7  2bd4					      sta	R2
      8  2bd4					      pla
      9  2bd4					      sta	R1
     10  2bd4					      ELSE
     11  2bd4					      sta	R1
     12  2bd4					      sty	R2
     13  2bd4					      ENDIF
     14  2bd4					      pla
     15  2bd4					      cmp	R2
     16  2bd4					      bne	.phf
     17  2bd4					      pla
     18  2bd4					      cmp	R1
     19  2bd4					      bne	.phf + 1
     20  2bd4					      ptrue
     21  2bd4					      bne	.q
     22  2bd4				   .phf
     23  2bd4					      pla
     24  2bd4					      pfalse
     25  2bd4				   .q
     26  2bd4					      ENDM		; @pull @push
     27  2bd4
     28  2bd4							; Compare two words on stack for inequality
     29  2bd4					      MAC	cmpwordneq
     30  2bd4					      IF	!FPULL
     31  2bd4					      pla
     32  2bd4					      sta	R2
     33  2bd4					      pla
     34  2bd4					      sta	R1
     35  2bd4					      ELSE
     36  2bd4					      sta	R1
     37  2bd4					      sty	R2
     38  2bd4					      ENDIF
     39  2bd4					      pla
     40  2bd4					      cmp	R2
     41  2bd4					      bne	.pht
     42  2bd4					      pla
     43  2bd4					      cmp	R1
     44  2bd4					      bne	.pht+1
     45  2bd4					      pfalse
     46  2bd4					      beq	.q
     47  2bd4				   .pht
     48  2bd4					      pla
     49  2bd4					      ptrue
     50  2bd4				   .q
     51  2bd4					      ENDM		; @pull @push
     52  2bd4
     53  2bd4							; Compare two words on stack for less than
     54  2bd4					      MAC	cmpwordlt
     55  2bd4					      tsx
     56  2bd4					      lda.wx	stack + 4
     57  2bd4					      cmp.wx	stack + 2
     58  2bd4					      lda.wx	stack + 3
     59  2bd4					      sbc.wx	stack + 1
     60  2bd4					      bcc	.true
     61  2bd4					      lda	#0
     62  2bd4					      beq	.1
     63  2bd4				   .true
     64  2bd4					      lda	#255
     65  2bd4				   .1
     66  2bd4					      sta.wx	stack + 4
     67  2bd4					      inx
     68  2bd4					      inx
     69  2bd4					      inx
     70  2bd4					      txs
     71  2bd4					      ENDM
     72  2bd4
     73  2bd4							; Compare two words on stack for greater than or equal
     74  2bd4					      MAC	cmpwordgte
     75  2bd4					      tsx
     76  2bd4					      lda.wx	stack + 4
     77  2bd4					      cmp.wx	stack + 2
     78  2bd4					      lda.wx	stack + 3
     79  2bd4					      sbc.wx	stack + 1
     80  2bd4					      bcs	.true
     81  2bd4					      lda	#0
     82  2bd4					      beq	.1
     83  2bd4				   .true
     84  2bd4					      lda	#255
     85  2bd4				   .1
     86  2bd4					      sta.wx	stack + 4
     87  2bd4					      inx
     88  2bd4					      inx
     89  2bd4					      inx
     90  2bd4					      txs
     91  2bd4					      ENDM
     92  2bd4
     93  2bd4							; Compare two words on stack for greater than
     94  2bd4					      MAC	cmpwordgt
     95  2bd4					      tsx
     96  2bd4					      lda.wx	stack + 2
     97  2bd4					      cmp.wx	stack + 4
     98  2bd4					      lda.wx	stack + 1
     99  2bd4					      sbc.wx	stack + 3
    100  2bd4					      bcc	.true
    101  2bd4					      lda	#0
    102  2bd4					      beq	.1
    103  2bd4				   .true
    104  2bd4					      lda	#255
    105  2bd4				   .1
    106  2bd4					      sta.wx	stack + 4
    107  2bd4					      inx
    108  2bd4					      inx
    109  2bd4					      inx
    110  2bd4					      txs
    111  2bd4					      ENDM
    112  2bd4
    113  2bd4							; Compare two words on stack for less than or equal
    114  2bd4					      MAC	cmpwordlte
    115  2bd4					      tsx
    116  2bd4					      lda.wx	stack + 2
    117  2bd4					      cmp.wx	stack + 4
    118  2bd4					      lda.wx	stack + 1
    119  2bd4					      sbc.wx	stack + 3
    120  2bd4					      bcs	.true
    121  2bd4					      lda	#0
    122  2bd4					      beq	.1
    123  2bd4				   .true
    124  2bd4					      lda	#255
    125  2bd4				   .1
    126  2bd4					      sta.wx	stack + 4
    127  2bd4					      inx
    128  2bd4					      inx
    129  2bd4					      inx
    130  2bd4					      txs
    131  2bd4					      ENDM
------- FILE core/comp/comp.asm
------- FILE core/comp/_int.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/comp/_int.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Compare top 2 ints on stack for equality
      4  2bd4					      MAC	cmpinteq
      5  2bd4					      cmpwordeq
      6  2bd4					      ENDM		; @pull @push
      7  2bd4
      8  2bd4							; Compare top 2 ints on stack for inequality
      9  2bd4					      MAC	cmpintneq
     10  2bd4					      cmpwordneq
     11  2bd4					      ENDM		; @pull @push
     12  2bd4
     13  2bd4							; Compare two ints on stack for less than
     14  2bd4					      MAC	cmpintlt
     15  2bd4					      tsx
     16  2bd4					      lda.wx	stack+4
     17  2bd4					      cmp.wx	stack+2
     18  2bd4					      lda.wx	stack+3
     19  2bd4					      sbc.wx	stack+1
     20  2bd4					      bvc	.1
     21  2bd4					      eor	#$80
     22  2bd4				   .1
     23  2bd4					      bmi	.pht
     24  2bd4					      inx
     25  2bd4					      inx
     26  2bd4					      inx
     27  2bd4					      inx
     28  2bd4					      txs
     29  2bd4					      pfalse
     30  2bd4					      IF	!FPUSH
     31  2bd4					      beq	* + 10
     32  2bd4					      ELSE
     33  2bd4					      beq	* + 9
     34  2bd4					      ENDIF
     35  2bd4				   .pht
     36  2bd4					      inx
     37  2bd4					      inx
     38  2bd4					      inx
     39  2bd4					      inx
     40  2bd4					      txs
     41  2bd4					      ptrue
     42  2bd4					      ENDM		; @push
     43  2bd4
     44  2bd4							; Compare two words on stack for greater than or equal
     45  2bd4					      MAC	cmpintgte
     46  2bd4					      tsx
     47  2bd4					      lda.wx	stack+4
     48  2bd4					      cmp.wx	stack+2
     49  2bd4					      lda.wx	stack+3
     50  2bd4					      sbc.wx	stack+1
     51  2bd4					      bvc	.1
     52  2bd4					      eor	#$80
     53  2bd4				   .1
     54  2bd4					      bmi	.phf
     55  2bd4					      inx
     56  2bd4					      inx
     57  2bd4					      inx
     58  2bd4					      inx
     59  2bd4					      txs
     60  2bd4					      ptrue
     61  2bd4					      IF	!FPUSH
     62  2bd4					      bne	* + 10
     63  2bd4					      ELSE
     64  2bd4					      bne	* + 9
     65  2bd4					      ENDIF
     66  2bd4				   .phf       inx
     67  2bd4					      inx
     68  2bd4					      inx
     69  2bd4					      inx
     70  2bd4					      txs
     71  2bd4					      pfalse
     72  2bd4					      ENDM		; @push
     73  2bd4
     74  2bd4							; Compare two ints on stack for greater than
     75  2bd4					      MAC	cmpintgt
     76  2bd4					      tsx
     77  2bd4					      lda.wx	stack+2
     78  2bd4					      cmp.wx	stack+4
     79  2bd4					      lda.wx	stack+1
     80  2bd4					      sbc.wx	stack+3
     81  2bd4					      bvc	.1
     82  2bd4					      eor	#$80
     83  2bd4				   .1
     84  2bd4					      bmi	.pht
     85  2bd4					      inx
     86  2bd4					      inx
     87  2bd4					      inx
     88  2bd4					      inx
     89  2bd4					      txs
     90  2bd4					      pfalse
     91  2bd4					      IF	!FPUSH
     92  2bd4					      beq	* + 10
     93  2bd4					      ELSE
     94  2bd4					      beq	* + 9
     95  2bd4					      ENDIF
     96  2bd4				   .pht       inx
     97  2bd4					      inx
     98  2bd4					      inx
     99  2bd4					      inx
    100  2bd4					      txs
    101  2bd4					      ptrue
    102  2bd4					      ENDM		; @push
    103  2bd4
    104  2bd4							; Compare two ints on stack for less than or equal
    105  2bd4					      MAC	cmpintlte
    106  2bd4					      tsx
    107  2bd4					      lda.wx	stack+2
    108  2bd4					      cmp.wx	stack+4
    109  2bd4					      lda.wx	stack+1
    110  2bd4					      sbc.wx	stack+3
    111  2bd4					      bvc	.1
    112  2bd4					      eor	#$80
    113  2bd4				   .1
    114  2bd4					      bmi	.phf
    115  2bd4					      inx
    116  2bd4					      inx
    117  2bd4					      inx
    118  2bd4					      inx
    119  2bd4					      txs
    120  2bd4					      ptrue
    121  2bd4					      IF	!FPUSH
    122  2bd4					      bne	* + 10
    123  2bd4					      ELSE
    124  2bd4					      bne	* + 9
    125  2bd4					      ENDIF
    126  2bd4				   .phf       inx
    127  2bd4					      inx
    128  2bd4					      inx
    129  2bd4					      inx
    130  2bd4					      txs
    131  2bd4					      pfalse
    132  2bd4					      ENDM		; @push
------- FILE core/comp/comp.asm
------- FILE core/comp/_long.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/comp/_long.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Compare two long ints on stack for equality
      4  2bd4					      MAC	cmplongeq
      5  2bd4					      tsx
      6  2bd4					      lda.wx	stack+6
      7  2bd4					      cmp.wx	stack+3
      8  2bd4					      bne	.false
      9  2bd4					      lda.wx	stack+5
     10  2bd4					      cmp.wx	stack+2
     11  2bd4					      bne	.false
     12  2bd4					      lda.wx	stack+4
     13  2bd4					      cmp.wx	stack+1
     14  2bd4					      bne	.false
     15  2bd4					      txa
     16  2bd4					      clc
     17  2bd4					      adc	#6
     18  2bd4					      tax
     19  2bd4					      txs
     20  2bd4					      ptrue
     21  2bd4					      bne	.q
     22  2bd4				   .false
     23  2bd4					      txa
     24  2bd4					      clc
     25  2bd4					      adc	#6
     26  2bd4					      tax
     27  2bd4					      txs
     28  2bd4					      pfalse
     29  2bd4				   .q
     30  2bd4					      ENDM		; @push
     31  2bd4
     32  2bd4							; Compare two long ints on stack for inequality
     33  2bd4					      MAC	cmplongneq
     34  2bd4					      tsx
     35  2bd4					      lda.wx	stack+6
     36  2bd4					      cmp.wx	stack+3
     37  2bd4					      bne	.true
     38  2bd4					      lda.wx	stack+5
     39  2bd4					      cmp.wx	stack+2
     40  2bd4					      bne	.true
     41  2bd4					      lda.wx	stack+4
     42  2bd4					      cmp.wx	stack+1
     43  2bd4					      bne	.true
     44  2bd4					      txa
     45  2bd4					      clc
     46  2bd4					      adc	#6
     47  2bd4					      tax
     48  2bd4					      txs
     49  2bd4					      pfalse
     50  2bd4					      beq	.q
     51  2bd4				   .true
     52  2bd4					      txa
     53  2bd4					      clc
     54  2bd4					      adc	#6
     55  2bd4					      tax
     56  2bd4					      txs
     57  2bd4					      ptrue
     58  2bd4				   .q
     59  2bd4					      ENDM		; @push
     60  2bd4
     61  2bd4							; Helper macro for long int comparisons
     62  2bd4					      MAC	_lcomparison
     63  2bd4					      tsx
     64  2bd4					      lda.wx	stack+6
     65  2bd4					      cmp.wx	stack+3
     66  2bd4					      lda.wx	stack+5
     67  2bd4					      sbc.wx	stack+2
     68  2bd4					      lda.wx	stack+4
     69  2bd4					      sbc.wx	stack+1
     70  2bd4					      bvc	*+4
     71  2bd4					      eor	#$80
     72  2bd4					      ENDM
     73  2bd4
     74  2bd4							; Compare two long ints on stack for less than
     75  2bd4					      MAC	cmplonglt
     76  2bd4					      _lcomparison
     77  2bd4					      bmi	.true
     78  2bd4					      txa
     79  2bd4					      clc
     80  2bd4					      adc	#6
     81  2bd4					      tax
     82  2bd4					      txs
     83  2bd4					      pfalse
     84  2bd4					      beq	.q
     85  2bd4				   .true
     86  2bd4					      txa
     87  2bd4					      clc
     88  2bd4					      adc	#6
     89  2bd4					      tax
     90  2bd4					      txs
     91  2bd4					      ptrue
     92  2bd4				   .q
     93  2bd4					      ENDM		; @push
     94  2bd4
     95  2bd4							; Compare two long ints on stack for greater than or equal
     96  2bd4					      MAC	cmplonggte
     97  2bd4					      _lcomparison
     98  2bd4					      bpl	.true
     99  2bd4					      txa
    100  2bd4					      clc
    101  2bd4					      adc	#6
    102  2bd4					      tax
    103  2bd4					      txs
    104  2bd4					      pfalse
    105  2bd4					      beq	.q
    106  2bd4				   .true
    107  2bd4					      txa
    108  2bd4					      clc
    109  2bd4					      adc	#6
    110  2bd4					      tax
    111  2bd4					      txs
    112  2bd4					      ptrue
    113  2bd4				   .q
    114  2bd4					      ENDM		; @push
    115  2bd4
    116  2bd4							; Compare two long ints on stack for less than or equal
    117  2bd4					      MAC	cmplonglte
    118  2bd4					      tsx
    119  2bd4					      lda.wx	stack+3
    120  2bd4					      cmp.wx	stack+6
    121  2bd4					      lda.wx	stack+2
    122  2bd4					      sbc.wx	stack+5
    123  2bd4					      lda.wx	stack+1
    124  2bd4					      sbc.wx	stack+4
    125  2bd4					      bvc	.1
    126  2bd4					      eor	#$80
    127  2bd4				   .1
    128  2bd4					      bmi	.phf
    129  2bd4					      txa
    130  2bd4					      clc
    131  2bd4					      adc	#6
    132  2bd4					      tax
    133  2bd4					      txs
    134  2bd4					      ptrue
    135  2bd4					      bne	.q
    136  2bd4				   .phf
    137  2bd4					      txa
    138  2bd4					      clc
    139  2bd4					      adc	#6
    140  2bd4					      tax
    141  2bd4					      txs
    142  2bd4					      pfalse
    143  2bd4				   .q
    144  2bd4					      ENDM		; @push
    145  2bd4
    146  2bd4							; Compare two long ints on stack for greater than
    147  2bd4					      MAC	cmplonggt
    148  2bd4					      tsx
    149  2bd4					      lda.wx	stack+3
    150  2bd4					      cmp.wx	stack+6
    151  2bd4					      lda.wx	stack+2
    152  2bd4					      sbc.wx	stack+5
    153  2bd4					      lda.wx	stack+1
    154  2bd4					      sbc.wx	stack+4
    155  2bd4					      bvc	.1
    156  2bd4					      eor	#$80
    157  2bd4				   .1
    158  2bd4					      bmi	.pht
    159  2bd4					      txa
    160  2bd4					      clc
    161  2bd4					      adc	#6
    162  2bd4					      tax
    163  2bd4					      txs
    164  2bd4					      pfalse
    165  2bd4					      beq	.q
    166  2bd4				   .pht
    167  2bd4					      txa
    168  2bd4					      clc
    169  2bd4					      adc	#6
    170  2bd4					      tax
    171  2bd4					      txs
    172  2bd4					      ptrue
    173  2bd4				   .q
    174  2bd4					      ENDM		; @push
------- FILE core/comp/comp.asm
------- FILE core/comp/_float.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/comp/_float.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4					      MAC	cmpfloateq
      4  2bd4					      plfloattofac
      5  2bd4					      tsx
      6  2bd4					      inx
      7  2bd4					      stx	DEST
      8  2bd4					      ldy	#$01
      9  2bd4					      import	I_FPLIB
     10  2bd4					      jsr	FCOMP2
     11  2bd4					      beq	.true
     12  2bd4					      discardfloat
     13  2bd4					      pfalse
     14  2bd4					      IF	!FPUSH
     15  2bd4					      beq	* + 11
     16  2bd4					      ELSE
     17  2bd4					      beq	* + 10
     18  2bd4					      ENDIF
     19  2bd4				   .true
     20  2bd4					      discardfloat
     21  2bd4					      ptrue
     22  2bd4					      ENDM		; @pull @push
     23  2bd4
     24  2bd4					      MAC	cmpfloatneq
     25  2bd4					      plfloattofac
     26  2bd4					      tsx
     27  2bd4					      inx
     28  2bd4					      stx	DEST
     29  2bd4					      ldy	#$01
     30  2bd4					      import	I_FPLIB
     31  2bd4					      jsr	FCOMP2
     32  2bd4					      bne	.true
     33  2bd4					      discardfloat
     34  2bd4					      pfalse
     35  2bd4					      IF	!FPUSH
     36  2bd4					      beq	* + 11
     37  2bd4					      ELSE
     38  2bd4					      beq	* + 10
     39  2bd4					      ENDIF
     40  2bd4				   .true
     41  2bd4					      discardfloat
     42  2bd4					      ptrue
     43  2bd4					      ENDM		; @pull @push
     44  2bd4
     45  2bd4							; Compare top 2 floats on stack for greater than
     46  2bd4					      MAC	cmpfloatgt
     47  2bd4					      plfloattofac
     48  2bd4					      tsx
     49  2bd4					      inx
     50  2bd4					      stx	DEST
     51  2bd4					      ldy	#$01
     52  2bd4					      import	I_FPLIB
     53  2bd4					      jsr	FCOMP2
     54  2bd4					      bmi	.true
     55  2bd4					      discardfloat
     56  2bd4					      pfalse
     57  2bd4					      IF	!FPUSH
     58  2bd4					      beq	* + 11
     59  2bd4					      ELSE
     60  2bd4					      beq	* + 10
     61  2bd4					      ENDIF
     62  2bd4				   .true
     63  2bd4					      discardfloat
     64  2bd4					      ptrue
     65  2bd4					      ENDM		; @pull @push
     66  2bd4
     67  2bd4							; Compare top 2 floats on stack for less than
     68  2bd4					      MAC	cmpfloatlt
     69  2bd4					      plfloattofac
     70  2bd4					      tsx
     71  2bd4					      inx
     72  2bd4					      stx	DEST
     73  2bd4					      ldy	#$01
     74  2bd4					      import	I_FPLIB
     75  2bd4					      jsr	FCOMP2
     76  2bd4					      cmp	#$01
     77  2bd4					      beq	.true
     78  2bd4					      discardfloat
     79  2bd4					      pfalse
     80  2bd4					      IF	!FPUSH
     81  2bd4					      beq	* + 11
     82  2bd4					      ELSE
     83  2bd4					      beq	* + 10
     84  2bd4					      ENDIF
     85  2bd4				   .true
     86  2bd4					      discardfloat
     87  2bd4					      ptrue
     88  2bd4					      ENDM		; @pull @push
     89  2bd4
     90  2bd4							; Compare top 2 floats on stack for less than or equal
     91  2bd4					      MAC	cmpfloatlte
     92  2bd4					      plfloattofac
     93  2bd4					      tsx
     94  2bd4					      inx
     95  2bd4					      stx	DEST
     96  2bd4					      ldy	#$01
     97  2bd4					      import	I_FPLIB
     98  2bd4					      jsr	FCOMP2
     99  2bd4					      bmi	.false
    100  2bd4					      discardfloat
    101  2bd4					      ptrue
    102  2bd4					      IF	!FPUSH
    103  2bd4					      bne	* + 11
    104  2bd4					      ELSE
    105  2bd4					      bne	* + 10
    106  2bd4					      ENDIF
    107  2bd4				   .false
    108  2bd4					      discardfloat
    109  2bd4					      pfalse
    110  2bd4					      ENDM		; @pull @push
    111  2bd4
    112  2bd4							; Compare top 2 floats on stack for greater than or equal
    113  2bd4					      MAC	cmpfloatgte
    114  2bd4					      plfloattofac
    115  2bd4					      tsx
    116  2bd4					      inx
    117  2bd4					      stx	DEST
    118  2bd4					      ldy	#$01
    119  2bd4					      import	I_FPLIB
    120  2bd4					      jsr	FCOMP2
    121  2bd4					      cmp	#$01
    122  2bd4					      beq	.false
    123  2bd4					      discardfloat
    124  2bd4					      ptrue
    125  2bd4					      IF	!FPUSH
    126  2bd4					      bne	* + 11
    127  2bd4					      ELSE
    128  2bd4					      bne	* + 10
    129  2bd4					      ENDIF
    130  2bd4				   .false
    131  2bd4					      discardfloat
    132  2bd4					      pfalse
    133  2bd4					      ENDM		; @pull @push
------- FILE core/comp/comp.asm
------- FILE core/comp/_decimal.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/comp/_decimal.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Compare two decimals on stack for equality
      4  2bd4					      MAC	cmpdecimaleq
      5  2bd4					      cmpwordeq
      6  2bd4					      ENDM		; @pull @push
      7  2bd4
      8  2bd4							; Compare two decimals on stack for inequality
      9  2bd4					      MAC	cmpdecimalneq
     10  2bd4					      cmpwordneq
     11  2bd4					      ENDM		; @pull @push
     12  2bd4
     13  2bd4							; Compare two decimals on stack for less than
     14  2bd4							; older < newer
     15  2bd4					      MAC	cmpdecimallt
     16  2bd4					      cmpwordlt
     17  2bd4					      ENDM
     18  2bd4
     19  2bd4							; Compare two decimals on stack for greater than or equal
     20  2bd4							; older >= newer
     21  2bd4					      MAC	cmpdecimalgte
     22  2bd4					      cmpwordgte
     23  2bd4					      ENDM
     24  2bd4
     25  2bd4							; Compare two decimals on stack for greater than
     26  2bd4							; older > newer
     27  2bd4					      MAC	cmpdecimalgt
     28  2bd4					      cmpwordgt
     29  2bd4					      ENDM
     30  2bd4
     31  2bd4							; Compare two decimals on stack for less than or equal
     32  2bd4							; older <= newer
     33  2bd4					      MAC	cmpdecimallte
     34  2bd4					      cmpwordlte
     35  2bd4					      ENDM
------- FILE core/comp/comp.asm
------- FILE core/comp/_string.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/comp/_string.asm"
      1  2bd4							; Compare top two strings on stack for equality
      2  2bd4					      MAC	cmpstringeq
      3  2bd4					      import	I_STRCMP
      4  2bd4					      jsr	I_STRCMP
      5  2bd4					      beq	.true
      6  2bd4					      pfalse
      7  2bd4					      beq	.exit
      8  2bd4				   .true
      9  2bd4					      ptrue
     10  2bd4				   .exit
     11  2bd4					      ENDM		; @push
     12  2bd4
     13  2bd4							; Compare top two strings on stack for inequality
     14  2bd4					      MAC	cmpstringneq
     15  2bd4					      import	I_STRCMP
     16  2bd4					      jsr	I_STRCMP
     17  2bd4					      bne	.true
     18  2bd4					      pfalse
     19  2bd4					      beq	.exit
     20  2bd4				   .true
     21  2bd4					      ptrue
     22  2bd4				   .exit
     23  2bd4					      ENDM		; @push
     24  2bd4
     25  2bd4				  -	      IFCONST	I_STRCMP_IMPORTED
     26  2bd4				  -			; STRCMP routine
     27  2bd4				  -			; Compares strings on stack
     28  2bd4				  -			; Result in zero flag
     29  2bd4				  -I_STRCMP   SUBROUTINE
     30  2bd4				  -	      lda	#>STRING_WORKAREA
     31  2bd4				  -	      sta	R2 + 1
     32  2bd4				  -	      sta	R0 + 1
     33  2bd4				  -	      ldx	SP
     34  2bd4				  -	      inx
     35  2bd4				  -	      lda	STRING_WORKAREA,x
     36  2bd4				  -	      sta	RB	; LEN(str2)
     37  2bd4				  -	      stx	R2
     38  2bd4				  -	      inx
     39  2bd4				  -	      txa
     40  2bd4				  -	      clc
     41  2bd4				  -	      adc	RB
     42  2bd4				  -	      tax
     43  2bd4				  -	      stx	R0
     44  2bd4				  -	      ldy	#0
     45  2bd4				  -			; Compare length
     46  2bd4				  -	      lda	(R0),y
     47  2bd4				  -	      cmp	(R2),y
     48  2bd4				  -	      beq	.equ
     49  2bd4				  -	      bne	.exit
     50  2bd4				  -.equ
     51  2bd4				  -	      tay
     52  2bd4				  -	      beq	.exit
     53  2bd4				  -.loop
     54  2bd4				  -	      lda	(R2),y
     55  2bd4				  -	      cmp	(R0),y
     56  2bd4				  -	      bne	.exit
     57  2bd4				  -	      dey
     58  2bd4				  -	      bne	.loop
     59  2bd4				  -.exit
     60  2bd4				  -	      php
     61  2bd4				  -			; remove strings from stack
     62  2bd4				  -	      ldy	#0
     63  2bd4				  -	      lda	SP
     64  2bd4				  -	      clc
     65  2bd4				  -	      adc	#2
     66  2bd4				  -	      adc	(R2),y
     67  2bd4				  -	      adc	(R0),y
     68  2bd4				  -	      sta	SP
     69  2bd4				  -	      plp
     70  2bd4				  -	      rts
     71  2bd4					      ENDIF
------- FILE core/comp/comp.asm
------- FILE xcb3lib.asm
     19  2bd4							; Basic arithmetics, boolean logic
------- FILE core/arith/arith.asm LEVEL 3 PASS 4
      0  2bd4					      INCLUDE	"core/arith/arith.asm"
------- FILE core/arith/_byte.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/arith/_byte.asm"
      1  2bd4							; Add top 2 bytes on stack
      2  2bd4					      MAC	addbyte
      3  2bd4					      IF	!FPULL
      4  2bd4					      pla
      5  2bd4					      ENDIF
      6  2bd4					      sta	R0
      7  2bd4					      pla
      8  2bd4					      clc
      9  2bd4					      adc	R0
     10  2bd4					      IF	!FPUSH
     11  2bd4					      pha
     12  2bd4					      ENDIF
     13  2bd4					      ENDM		; @pull @push
     14  2bd4
     15  2bd4							; Substract top 2 bytes on stack
     16  2bd4					      MAC	subbyte
     17  2bd4					      IF	!FPULL
     18  2bd4					      pla
     19  2bd4					      ENDIF
     20  2bd4					      sta	R0
     21  2bd4					      pla
     22  2bd4					      sec
     23  2bd4					      sbc	R0
     24  2bd4					      IF	!FPUSH
     25  2bd4					      pha
     26  2bd4					      ENDIF
     27  2bd4					      ENDM		; @pull @push
     28  2bd4
     29  2bd4							; Perform OR on top 2 bytes of stack
     30  2bd4					      MAC	orbyte
     31  2bd4					      IF	!FPULL
     32  2bd4					      pla
     33  2bd4					      ENDIF
     34  2bd4					      sta	R0
     35  2bd4					      pla
     36  2bd4					      ora	R0
     37  2bd4					      IF	!FPUSH
     38  2bd4					      pha
     39  2bd4					      ENDIF
     40  2bd4					      ENDM		; @pull @push
     41  2bd4
     42  2bd4							; Perform AND on top 2 bytes of stack
     43  2bd4					      MAC	andbyte
     44  2bd4					      IF	!FPULL
     45  2bd4					      pla
     46  2bd4					      ENDIF
     47  2bd4					      sta	R0
     48  2bd4					      pla
     49  2bd4					      and	R0
     50  2bd4					      IF	!FPUSH
     51  2bd4					      pha
     52  2bd4					      ENDIF
     53  2bd4					      ENDM		; @pull @push
     54  2bd4
     55  2bd4							; Perform XOR on top 2 bytes of stack
     56  2bd4					      MAC	xorbyte
     57  2bd4					      IF	!FPULL
     58  2bd4					      pla
     59  2bd4					      ENDIF
     60  2bd4					      sta	R0
     61  2bd4					      pla
     62  2bd4					      eor	R0
     63  2bd4					      IF	!FPUSH
     64  2bd4					      pha
     65  2bd4					      ENDIF
     66  2bd4					      ENDM		; @pull @push
     67  2bd4
     68  2bd4							; Perform NOT on byte on stack
     69  2bd4					      MAC	notbyte
     70  2bd4					      IF	!FPULL
     71  2bd4					      pla
     72  2bd4					      ENDIF
     73  2bd4					      eor	#$FF
     74  2bd4					      IF	!FPUSH
     75  2bd4					      pha
     76  2bd4					      ENDIF
     77  2bd4					      ENDM		; @pull @push
     78  2bd4
     79  2bd4							; Multiply top 2 bytes on stack
     80  2bd4					      MAC	mulbyte
     81  2bd4					      IF	!FPULL
     82  2bd4					      pla
     83  2bd4					      ENDIF
     84  2bd4					      sta	R0
     85  2bd4					      pla
     86  2bd4					      sta	R1
     87  2bd4					      import	I_NUCLEUS_MULBYTE
     88  2bd4					      jsr	NUCLEUS_MULBYTE
     89  2bd4					      IF	!FPUSH
     90  2bd4					      pha
     91  2bd4					      ENDIF
     92  2bd4					      ENDM		; @pull @push
     93  2bd4
     94  2bd4							; Divide two bytes on stack
     95  2bd4					      MAC	divbyte
     96  2bd4					      IF	!FPULL
     97  2bd4					      pla
     98  2bd4					      ENDIF
     99  2bd4					      bne	.ok
    100  2bd4					      lda	#ERR_DIVZERO
    101  2bd4					      import	I_RUNTIME_ERROR
    102  2bd4					      jmp	RUNTIME_ERROR
    103  2bd4				   .ok
    104  2bd4					      sta	R1
    105  2bd4					      pla
    106  2bd4					      sta	R0
    107  2bd4					      import	I_NUCLEUS_DIVBYTE
    108  2bd4					      jsr	NUCLEUS_DIVBYTE
    109  2bd4					      lda	R0
    110  2bd4					      IF	!FPUSH
    111  2bd4					      pha
    112  2bd4					      ENDIF
    113  2bd4					      ENDM		; @pull @push
    114  2bd4
    115  2bd4							; Modulo two bytes on stack
    116  2bd4					      MAC	modbyte
    117  2bd4					      IF	!FPULL
    118  2bd4					      pla
    119  2bd4					      ENDIF
    120  2bd4					      sta	R1
    121  2bd4					      pla
    122  2bd4					      sta	R0
    123  2bd4					      import	I_NUCLEUS_DIVBYTE
    124  2bd4					      jsr	NUCLEUS_DIVBYTE
    125  2bd4					      IF	!FPUSH
    126  2bd4					      pha
    127  2bd4					      ENDIF
    128  2bd4					      ENDM		; @pull @push
    129  2bd4
    130  2bd4							; Shift left with const number of binary places
    131  2bd4					      MAC	lshiftbytewconst
    132  2bd4					      IF	!FPULL
    133  2bd4					      pla
    134  2bd4					      ENDIF
    135  2bd4					      REPEAT	{1}
    136  2bd4					      asl
    137  2bd4					      REPEND
    138  2bd4					      IF	!FPUSH
    139  2bd4					      pha
    140  2bd4					      ENDIF
    141  2bd4					      ENDM		; @pull @push
    142  2bd4
    143  2bd4							; Shift right with const number of binary places
    144  2bd4					      MAC	rshiftbytewconst
    145  2bd4					      IF	!FPULL
    146  2bd4					      pla
    147  2bd4					      ENDIF
    148  2bd4					      REPEAT	{1}
    149  2bd4					      lsr
    150  2bd4					      REPEND
    151  2bd4					      IF	!FPUSH
    152  2bd4					      pha
    153  2bd4					      ENDIF
    154  2bd4					      ENDM		; @pull @push
    155  2bd4
    156  2bd4							; Shift left with number of binary places
    157  2bd4							; stored in a byte on top of stack
    158  2bd4					      MAC	lshiftbyte
    159  2bd4					      IF	!FPULL
    160  2bd4					      pla
    161  2bd4					      ENDIF
    162  2bd4					      tay
    163  2bd4					      pla
    164  2bd4				   .loop
    165  2bd4					      cpy	#$00
    166  2bd4					      beq	.endloop
    167  2bd4					      asl
    168  2bd4					      dey
    169  2bd4					      bpl	.loop	; = branch always
    170  2bd4				   .endloop
    171  2bd4					      IF	!FPUSH
    172  2bd4					      pha
    173  2bd4					      ENDIF
    174  2bd4					      ENDM		; @pull @push
    175  2bd4
    176  2bd4							; Shift right with number of binary places
    177  2bd4							; stored in a byte on top of stack
    178  2bd4					      MAC	rshiftbyte
    179  2bd4					      IF	!FPULL
    180  2bd4					      pla
    181  2bd4					      ENDIF
    182  2bd4					      tay
    183  2bd4					      pla
    184  2bd4				   .loop
    185  2bd4					      cpy	#$00
    186  2bd4					      beq	.endloop
    187  2bd4					      lsr
    188  2bd4					      dey
    189  2bd4					      bpl	.loop	; = branch always
    190  2bd4				   .endloop
    191  2bd4					      IF	!FPUSH
    192  2bd4					      pha
    193  2bd4					      ENDIF
    194  2bd4					      ENDM		; @pull @push
    195  2bd4
    196  2bd4							; Multiply bytes
    197  2bd4							; by White Flame 20030207
    198  2bd4							; Factors in R0 and R1
    199  2bd4							; Result in A
    200  2bd4				  -	      IFCONST	I_NUCLEUS_MULBYTE_IMPORTED
    201  2bd4				  -NUCLEUS_MULBYTE SUBROUTINE
    202  2bd4				  -	      lda	#$00
    203  2bd4				  -	      beq	.enterLoop
    204  2bd4				  -.doAdd
    205  2bd4				  -	      clc
    206  2bd4				  -	      adc	R0
    207  2bd4				  -.loop
    208  2bd4				  -	      asl	R0
    209  2bd4				  -.enterLoop
    210  2bd4				  -	      lsr	R1
    211  2bd4				  -	      bcs	.doAdd
    212  2bd4				  -	      bne	.loop
    213  2bd4				  -.end
    214  2bd4				  -	      rts
    215  2bd4					      ENDIF
    216  2bd4
    217  2bd4							; Divide bytes
    218  2bd4							; By Whyte Flame
    219  2bd4							; https://codebase64.org/doku.php?id=base:8bit_divide_8bit_product
    220  2bd4							; Dividend in R0
    221  2bd4							; Divisor in R1
    222  2bd4							; Result in R0
    223  2bd4				  -	      IFCONST	I_NUCLEUS_DIVBYTE_IMPORTED
    224  2bd4				  -NUCLEUS_DIVBYTE SUBROUTINE
    225  2bd4				  -	      lda	#$00
    226  2bd4				  -	      ldx	#$07
    227  2bd4				  -	      clc
    228  2bd4				  -.1	      rol	R0
    229  2bd4				  -	      rol
    230  2bd4				  -	      cmp	R1
    231  2bd4				  -	      bcc	.2
    232  2bd4				  -	      sbc	R1
    233  2bd4				  -.2	      dex
    234  2bd4				  -	      bpl	.1
    235  2bd4				  -	      rol	R0
    236  2bd4				  -	      rts
    237  2bd4					      ENDIF
------- FILE core/arith/arith.asm
------- FILE core/arith/_int.asm LEVEL 4 PASS 4
      0  2bd4					      INCLUDE	"core/arith/_int.asm"
      1  2bd4					      PROCESSOR	6502
      2  2bd4
      3  2bd4							; Add top 2 ints on stack
      4  2bd4					      MAC	addint
      5  2bd4					      addword
      6  2bd4					      ENDM
      7  2bd4
      8  2bd4							; Subtract top 2 ints on stack
      9  2bd4					      MAC	subint
     10  2bd4					      subword
     11  2bd4					      ENDM
     12  2bd4
     13  2bd4							; Multiply top 2 ints on stack
     14  2bd4					      MAC	mulint
     15  2bd4					      IF	!FPULL
     16  2bd4					      pla
     17  2bd4					      sta	R1
     18  2bd4					      pla
     19  2bd4					      sta	R0
     20  2bd4					      ELSE
     21  2bd4					      sta	R0
     22  2bd4					      sty	R1
     23  2bd4					      ENDIF
     24  2bd4					      pla
     25  2bd4					      sta	R3
     26  2bd4					      pla
     27  2bd4					      sta	R2
     28  2bd4					      import	I_NUCLEUS_MUL16
     29  2bd4					      jsr	NUCLEUS_MUL16
     30  2bd4					      IF	!FPUSH
     31  2bd4					      lda	R0
     32  2bd4					      pha
     33  2bd4					      lda	R1
     34  2bd4					      pha
     35  2bd4					      ELSE
     36  2bd4					      lda	R0
     37  2bd4					      ldy	R1
     38  2bd4					      ENDIF
     39  2bd4					      ENDM		; @pull @push
     40  2bd4
     41  2bd4							; Divide top 2 ints on stack
     42  2bd4					      MAC	divint
     43  2bd4					      plwordvar	R0
     44  2bd4					      plwordvar	R2
     45  2bd4					      lda	R0
     46  2bd4					      bne	.ok
     47  2bd4					      lda	R1
     48  2bd4					      bne	.ok
     49  2bd4					      import	I_RUNTIME_ERROR
     50  2bd4					      lda	#ERR_DIVZERO
     51  2bd4					      jmp	RUNTIME_ERROR
     52  2bd4				   .ok
     53  2bd4					      import	I_NUCLEUS_DIV16
     54  2bd4					      jsr	NUCLEUS_DIV16
     55  2bd4					      pintvar	R2
     56  2bd4					      ENDM		; @push
     57  2bd4
     58  2bd4							; Modulo of top 2 ints on stack
     59  2bd4					      MAC	modint
     60  2bd4					      plwordvar	R0
     61  2bd4					      plwordvar	R2
     62  2bd4					      lda	R0
     63  2bd4					      bne	.ok
     64  2bd4					      lda	R1
     65  2bd4					      bne	.ok
     66  2bd4					      import	I_RUNTIME_ERROR
     67  2bd4					      lda	#ERR_DIVZERO
     68  2bd4					      jmp	RUNTIME_ERROR
     69  2bd4				   .ok
     70  2bd4					      import	I_NUCLEUS_DIV16
     71  2bd4					      jsr	NUCLEUS_DIV16
     72  2bd4					      pintvar	R4
     73  2bd4					      ENDM		; @push
     74  2bd4
     75  2bd4							; Perform NOT on int on stack
     76  2bd4					      MAC	notint
     77  2bd4					      notword
     78  2bd4					      ENDM		; @pull @push
     79  2bd4
     80  2bd4							; Perform AND on top 2 ints on stack
     81  2bd4					      MAC	andint
     82  2bd4					      andword
     83  2bd4					      ENDM
     84  2bd4
     85  2bd4							; Perform OR on top 2 ints on stack
     86  2bd4					      MAC	orint
     87  2bd4					      orword
     88  2bd4					      ENDM
     89  2bd4
     90  2bd4							; Perform XOR on top 2 ints of stack
     91  2bd4					      MAC	xorint
     92  2bd4					      xorword
     93  2bd4					      ENDM
     94  2bd4
     95  2bd4							; Take two's complement of int
     96  2bd4					      MAC	twoscplint
     97  2bd4					      lda	{1}+1
     98  2bd4					      eor	#$ff
     99  2bd4					      sta	{1}+1
    100  2bd4					      lda	{1}
    101  2bd4					      eor	#$ff
    102  2bd4					      clc
    103  2bd4					      adc	#$01
    104  2bd4					      sta	{1}
    105  2bd4					      bne	.skip
    106  2bd4					      inc	{1}+1
    107  2bd4				   .skip
    108  2bd4					      ENDM
    109  2bd4
    110  2bd4							; Negate int on stack
    111  2bd4					      MAC	negint
    112  2bd4					      IF	!FPULL
    113  2bd4					      pla
    114  2bd4					      tay
    115  2bd4					      pla
    116  2bd4					      ENDIF
    117  2bd4					      tax
    118  2bd4					      tya
    119  2bd4					      eor	#$ff
    120  2bd4					      tay
    121  2bd4					      txa
    122  2bd4					      eor	#$ff
    123  2bd4					      clc
    124  2bd4					      adc	#1
    125  2bd4					      bne	.skip
    126  2bd4					      iny
    127  2bd4				   .skip
    128  2bd4					      IF	!FPUSH
    129  2bd4					      pha
    130  2bd4					      tya
    131  2bd4					      pha
    132  2bd4					      ENDIF
    133  2bd4					      ENDM		; @pull
    134  2bd4
    135  2bd4							; Shift left with number of binary places
    136  2bd4							; stored in a byte on top of stack
    137  2bd4					      MAC	lshiftint
    138  2bd4					      lshiftword
    139  2bd4					      ENDM		; @pull
    140  2bd4
    141  2bd4							; LSHIFT() function
    142  2bd4							; with constant argument
    143  2bd4					      MAC	lshiftintwconst
    144  2bd4					      lshiftwordwconst	{1}
    145  2bd4					      ENDM
    146  2bd4
    147  2bd4							; Shift right with number of binary places
    148  2bd4							; stored in a byte on top of stack
    149  2bd4					      MAC	rshiftint
    150  2bd4					      IF	!FPULL
    151  2bd4					      pla
    152  2bd4					      ENDIF
    153  2bd4					      tay
    154  2bd4					      tsx
    155  2bd4				   .loop
    156  2bd4					      cpy	#$00
    157  2bd4					      beq	.endloop
    158  2bd4							; Move sign to carry
    159  2bd4					      lda.wx	stack + 1
    160  2bd4					      asl
    161  2bd4					      ror.wx	stack + 1
    162  2bd4					      ror.wx	stack + 2
    163  2bd4					      dey
    164  2bd4					      bpl	.loop	; = branch always
    165  2bd4				   .endloop
    166  2bd4					      ENDM		; @pull
    167  2bd4
    168  2bd4							; RSHIFT() function
    169  2bd4							; with constant argument
    170  2bd4					      MAC	rshiftintwconst
    171  2bd4					      tsx
    172  2bd4					      REPEAT	{1}
    173  2bd4					      lda.wx	stack + 1
    174  2bd4					      asl
    175  2bd4					      ror.wx	stack + 1
    176  2bd4					      ror.wx	stack + 2
    177  2bd4					      REPEND
    178  2bd4					      ENDM
    179  2bd4
    180  2bd4							; Signed 16-bit multiplication
    181  2bd4					      IFCONST	I_NUCLEUS_MUL16_IMPORTED
      0  2bd4					      import	I_NUCLEUS_MULU16
      1  2bd4				   I_NUCLEUS_MULU16_IMPORTED SET	1
    183  2bd4				   NUCLEUS_MUL16 SUBROUTINE
    184  2bd4		       a0 00		      ldy	#$00	; .y will hold the sign of product
    185  2bd6		       a5 03		      lda	R1
    186  2bd8		       10 14		      bpl	.skip	; if factor1 is negative
      0  2bda					      twoscplint	R0	; then factor1 := -factor1
      1  2bda		       a5 03		      lda	R0+1
      2  2bdc		       49 ff		      eor	#$ff
      3  2bde		       85 03		      sta	R0+1
      4  2be0		       a5 02		      lda	R0
      5  2be2		       49 ff		      eor	#$ff
      6  2be4		       18		      clc
      7  2be5		       69 01		      adc	#$01
      8  2be7		       85 02		      sta	R0
      9  2be9		       d0 02		      bne	.skip
     10  2beb		       e6 03		      inc	R0+1
     11  2bed				   .skip
    188  2bed		       c8		      iny		; and switch sign
    189  2bee				   .skip
    190  2bee		       a5 05		      lda	R3
    191  2bf0		       10 14		      bpl	.skip2	; if factor2 is negative
      0  2bf2					      twoscplint	R2	; then factor2 := -factor2
      1  2bf2		       a5 05		      lda	R2+1
      2  2bf4		       49 ff		      eor	#$ff
      3  2bf6		       85 05		      sta	R2+1
      4  2bf8		       a5 04		      lda	R2
      5  2bfa		       49 ff		      eor	#$ff
      6  2bfc		       18		      clc
      7  2bfd		       69 01		      adc	#$01
      8  2bff		       85 04		      sta	R2
      9  2c01		       d0 02		      bne	.skip
     10  2c03		       e6 05		      inc	R2+1
     11  2c05				   .skip
    193  2c05		       c8		      iny		; and switch sign
    194  2c06				   .skip2
    195  2c06		       20 22 2c 	      jsr	NUCLEUS_MULU16	; do unsigned multiplication
    196  2c09		       98		      tya
    197  2c0a		       29 01		      and	#$01	; if .x is odd
    198  2c0c		       f0 13		      beq	.q
      0  2c0e					      twoscplint	R0	; then product := -product
      1  2c0e		       a5 03		      lda	R0+1
      2  2c10		       49 ff		      eor	#$ff
      3  2c12		       85 03		      sta	R0+1
      4  2c14		       a5 02		      lda	R0
      5  2c16		       49 ff		      eor	#$ff
      6  2c18		       18		      clc
      7  2c19		       69 01		      adc	#$01
      8  2c1b		       85 02		      sta	R0
      9  2c1d		       d0 02		      bne	.skip
     10  2c1f		       e6 03		      inc	R0+1
     11  2c21				   .skip
    200  2c21		       60	   .q	      rts
    201  2c22					      ENDIF
    202  2c22
    203  2c22							; Signed 16-bit division
    204  2c22				  -	      IFCONST	I_NUCLEUS_DIV16_IMPORTED
    205  2c22				  -	      import	I_NUCLEUS_DIVU16
    206  2c22				  -NUCLEUS_DIV16 SUBROUTINE
    207  2c22				  -	      ldx	#$00
    208  2c22				  -	      lda	R2+1
    209  2c22				  -	      bpl	.skip
    210  2c22				  -	      twoscplint	R2
    211  2c22				  -	      inx
    212  2c22				  -.skip
    213  2c22				  -	      lda	R0+1
    214  2c22				  -	      bpl	.skip2
    215  2c22				  -	      twoscplint	R0
    216  2c22				  -	      inx
    217  2c22				  -.skip2
    218  2c22				  -	      txa
    219  2c22				  -	      pha
    220  2c22				  -	      jsr	NUCLEUS_DIVU16
    221  2c22				  -	      pla
    222  2c22				  -	      and	#$01
    223  2c22				  -	      beq	.q
    224  2c22				  -	      twoscplint	R2
    225  2c22				  -.q	      rts
    226  2c22					      ENDIF
------- FILE core/arith/arith.asm
------- FILE core/arith/_word.asm LEVEL 4 PASS 4
      0  2c22					      INCLUDE	"core/arith/_word.asm"
      1  2c22					      PROCESSOR	6502
      2  2c22
      3  2c22							; Add top 2 words on stack
      4  2c22							; 32 cycles - could it be less?
      5  2c22					      MAC	addword
      6  2c22					      tsx
      7  2c22					      lda.wx	stack + 2
      8  2c22					      clc
      9  2c22					      adc.wx	stack + 4
     10  2c22					      sta.wx	stack + 4
     11  2c22					      pla
     12  2c22					      adc.wx	stack + 3
     13  2c22					      sta.wx	stack + 3
     14  2c22					      pla
     15  2c22					      ENDM
     16  2c22
     17  2c22							; Substract top 2 words on stack
     18  2c22					      MAC	subword
     19  2c22					      tsx
     20  2c22					      lda.wx	stack + 4
     21  2c22					      sec
     22  2c22					      sbc.wx	stack + 2
     23  2c22					      sta.wx	stack + 4
     24  2c22					      lda.wx	stack + 3
     25  2c22					      sbc.wx	stack + 1
     26  2c22					      sta.wx	stack + 3
     27  2c22					      inx
     28  2c22					      inx
     29  2c22					      txs
     30  2c22					      ENDM
     31  2c22
     32  2c22							; Multiply top 2 words on stack
     33  2c22					      MAC	mulword
     34  2c22					      IF	!FPULL
     35  2c22					      pla
     36  2c22					      sta	R1
     37  2c22					      pla
     38  2c22					      sta	R0
     39  2c22					      ELSE
     40  2c22					      sta	R0
     41  2c22					      sty	R1
     42  2c22					      ENDIF
     43  2c22					      pla
     44  2c22					      sta	R3
     45  2c22					      pla
     46  2c22					      sta	R2
     47  2c22					      import	I_NUCLEUS_MULU16
     48  2c22					      jsr	NUCLEUS_MULU16
     49  2c22					      IF	!FPUSH
     50  2c22					      lda	R0
     51  2c22					      pha
     52  2c22					      lda	R1
     53  2c22					      pha
     54  2c22					      ELSE
     55  2c22					      lda	R0
     56  2c22					      ldy	R1
     57  2c22					      ENDIF
     58  2c22					      ENDM		; @pull @push
     59  2c22
     60  2c22							; Divide top 2 words on stack
     61  2c22					      MAC	divword
     62  2c22					      plwordvar	R0
     63  2c22					      plwordvar	R2
     64  2c22					      lda	R0
     65  2c22					      bne	.ok
     66  2c22					      lda	R1
     67  2c22					      bne	.ok
     68  2c22					      import	I_RUNTIME_ERROR
     69  2c22					      lda	#ERR_DIVZERO
     70  2c22					      jmp	RUNTIME_ERROR
     71  2c22				   .ok
     72  2c22					      import	I_NUCLEUS_DIVU16
     73  2c22					      jsr	NUCLEUS_DIVU16
     74  2c22					      pwordvar	R2
     75  2c22					      ENDM		; @push
     76  2c22
     77  2c22							; Modulo of top 2 words on stack
     78  2c22					      MAC	modword
     79  2c22					      plwordvar	R0
     80  2c22					      plwordvar	R2
     81  2c22					      lda	R0
     82  2c22					      bne	.ok
     83  2c22					      lda	R1
     84  2c22					      bne	.ok
     85  2c22					      import	I_RUNTIME_ERROR
     86  2c22					      lda	#ERR_DIVZERO
     87  2c22					      jmp	RUNTIME_ERROR
     88  2c22				   .ok
     89  2c22					      import	I_NUCLEUS_DIVU16
     90  2c22					      jsr	NUCLEUS_DIVU16
     91  2c22					      pwordvar	R4
     92  2c22					      ENDM		; @push
     93  2c22
     94  2c22							; Perform NOT on word on stack
     95  2c22					      MAC	notword
     96  2c22					      IF	!FPULL
     97  2c22					      tsx
     98  2c22					      lda.wx	stack + 1
     99  2c22					      eor	#$ff
    100  2c22					      sta.wx	stack + 1
    101  2c22					      lda.wx	stack + 2
    102  2c22					      eor	#$ff
    103  2c22					      sta.wx	stack + 2
    104  2c22					      ELSE
    105  2c22					      tax
    106  2c22					      tya
    107  2c22					      eor	#$ff
    108  2c22					      tay
    109  2c22					      txa
    110  2c22					      eor	#$ff
    111  2c22					      IF	!FPUSH
    112  2c22					      pha
    113  2c22					      tya
    114  2c22					      pha
    115  2c22					      ENDIF
    116  2c22					      ENDIF
    117  2c22					      ENDM		; @pull @push
    118  2c22
    119  2c22							; Perform AND on top 2 words on stack
    120  2c22					      MAC	andword
    121  2c22					      pla
    122  2c22					      tay
    123  2c22					      pla
    124  2c22					      tsx
    125  2c22					      and.wx	stack + 2
    126  2c22					      sta.wx	stack + 2
    127  2c22					      tya
    128  2c22					      and.wx	stack + 1
    129  2c22					      sta.wx	stack + 1
    130  2c22					      ENDM
    131  2c22
    132  2c22							; Perform OR on top 2 words on stack
    133  2c22					      MAC	orword
    134  2c22					      pla
    135  2c22					      tay
    136  2c22					      pla
    137  2c22					      tsx
    138  2c22					      ora.wx	stack + 2
    139  2c22					      sta.wx	stack + 2
    140  2c22					      tya
    141  2c22					      ora.wx	stack + 1
    142  2c22					      sta.wx	stack + 1
    143  2c22					      ENDM
    144  2c22
    145  2c22							; Perform XOR on top 2 words of stack
    146  2c22					      MAC	xorword
    147  2c22					      pla
    148  2c22					      tay
    149  2c22					      pla
    150  2c22					      tsx
    151  2c22					      eor.wx	stack + 2
    152  2c22					      sta.wx	stack + 2
    153  2c22					      tya
    154  2c22					      eor.wx	stack + 1
    155  2c22					      sta.wx	stack + 1
    156  2c22					      ENDM
    157  2c22
    158  2c22							; Shift left with number of binary places
    159  2c22							; stored in a byte on top of stack
    160  2c22					      MAC	lshiftword
    161  2c22					      IF	!FPULL
    162  2c22					      pla
    163  2c22					      ENDIF
    164  2c22					      tay
    165  2c22					      tsx
    166  2c22				   .loop
    167  2c22					      cpy	#$00
    168  2c22					      beq	.endloop
    169  2c22					      asl.wx	stack+2
    170  2c22					      rol.wx	stack+1
    171  2c22					      dey
    172  2c22					      bpl	.loop	; = branch always
    173  2c22				   .endloop
    174  2c22					      ENDM		; @pull
    175  2c22
    176  2c22							; LSHIFT() function
    177  2c22							; with constant argument
    178  2c22					      MAC	lshiftwordwconst
    179  2c22					      tsx
    180  2c22					      REPEAT	{1}
    181  2c22					      asl.wx	stack+2
    182  2c22					      rol.wx	stack+1
    183  2c22					      REPEND
    184  2c22					      ENDM
    185  2c22
    186  2c22							; Shift right with number of binary places
    187  2c22							; stored in a byte on top of stack
    188  2c22					      MAC	rshiftword
    189  2c22					      IF	!FPULL
    190  2c22					      pla
    191  2c22					      ENDIF
    192  2c22					      tay
    193  2c22					      tsx
    194  2c22				   .loop
    195  2c22					      cpy	#$00
    196  2c22					      beq	.endloop
    197  2c22					      lsr.wx	stack+1
    198  2c22					      ror.wx	stack+2
    199  2c22					      dey
    200  2c22					      bpl	.loop	; = branch always
    201  2c22				   .endloop
    202  2c22					      ENDM		; @pull
    203  2c22
    204  2c22							; RSHIFT() function
    205  2c22							; with constant argument
    206  2c22					      MAC	rshiftwordwconst
    207  2c22					      tsx
    208  2c22					      REPEAT	{1}
    209  2c22					      lsr.wx	stack+1
    210  2c22					      ror.wx	stack+2
    211  2c22					      REPEND
    212  2c22					      ENDM
    213  2c22
    214  2c22							; Multiply unsigned words in R0 and R2, with 16-bit result in R0
    215  2c22							; and 16-bit overflow in R5
    216  2c22					      IFCONST	I_NUCLEUS_MULU16_IMPORTED
    217  2c22				   NUCLEUS_MULU16 SUBROUTINE
    218  2c22		       a2 11		      ldx	#$11
    219  2c24		       a9 00		      lda	#$00
    220  2c26		       85 07		      sta	R5
    221  2c28		       18		      clc
    222  2c29		       6a	   .1	      ror
    223  2c2a		       66 07		      ror	R5
    224  2c2c		       66 03		      ror	R1
    225  2c2e		       66 02		      ror	R0
    226  2c30		       ca		      dex
    227  2c31		       f0 12		      beq	.q
    228  2c33		       90 f4		      bcc	.1
    229  2c35		       85 08		      sta	R6
    230  2c37		       a5 07		      lda	R5
    231  2c39		       18		      clc
    232  2c3a		       65 04		      adc	R2
    233  2c3c		       85 07		      sta	R5
    234  2c3e		       a5 08		      lda	R6
    235  2c40		       65 05		      adc	R3
    236  2c42		       4c 29 2c 	      jmp	.1
    237  2c45		       85 08	   .q	      sta	R6
    238  2c47		       60		      rts
    239  2c48					      ENDIF
    240  2c48
    241  2c48							; 16 bit unsigned division
    242  2c48							; Author: unknown
    243  2c48							; https://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
    244  2c48				  -	      IFCONST	I_NUCLEUS_DIVU16_IMPORTED
    245  2c48				  -NUCLEUS_DIVU16 SUBROUTINE
    246  2c48				  -.divisor   EQU	R0
    247  2c48				  -.dividend  EQU	R2
    248  2c48				  -.remainder EQU	R4
    249  2c48				  -.result    EQU	.dividend	; save memory by reusing divident to store the result
    250  2c48				  -	      lda	#0	;preset remainder to 0
    251  2c48				  -	      sta	.remainder
    252  2c48				  -	      sta	.remainder+1
    253  2c48				  -	      ldx	#16	;repeat for each bit: ...
    254  2c48				  -.divloop
    255  2c48				  -	      asl	.dividend	;dividend lb & hb*2, msb -> Carry
    256  2c48				  -	      rol	.dividend+1
    257  2c48				  -	      rol	.remainder	;remainder lb & hb * 2 + msb from carry
    258  2c48				  -	      rol	.remainder+1
    259  2c48				  -	      lda	.remainder
    260  2c48				  -	      sec
    261  2c48				  -	      sbc	.divisor	;substract divisor to see if it fits in
    262  2c48				  -	      tay		;lb result -> Y, for we may need it later
    263  2c48				  -	      lda	.remainder+1
    264  2c48				  -	      sbc	.divisor+1
    265  2c48				  -	      bcc	.skip	;if carry=0 then divisor didn't fit in yet
    266  2c48				  -
    267  2c48				  -	      sta	.remainder+1	;else save substraction result as new remainder,
    268  2c48				  -	      sty	.remainder
    269  2c48				  -	      inc	.result	;and INCrement result cause divisor fit in 1 times
    270  2c48				  -.skip
    271  2c48				  -	      dex
    272  2c48				  -	      bne	.divloop
    273  2c48				  -	      rts
    274  2c48					      ENDIF
------- FILE core/arith/arith.asm
------- FILE core/arith/_long.asm LEVEL 4 PASS 4
      0  2c48					      INCLUDE	"core/arith/_long.asm"
      1  2c48					      PROCESSOR	6502
      2  2c48
      3  2c48							; Perform OR on top 2 long ints of stack
      4  2c48					      MAC	orlong
      5  2c48					      tsx
      6  2c48					      lda.wx	stack + 4
      7  2c48					      ora.wx	stack + 1
      8  2c48					      sta.wx	stack + 4
      9  2c48					      lda.wx	stack + 5
     10  2c48					      ora.wx	stack + 2
     11  2c48					      sta.wx	stack + 5
     12  2c48					      lda.wx	stack + 6
     13  2c48					      ora.wx	stack + 3
     14  2c48					      sta.wx	stack + 6
     15  2c48					      inx
     16  2c48					      inx
     17  2c48					      inx
     18  2c48					      txs
     19  2c48					      ENDM
     20  2c48
     21  2c48							; Perform AND on top 2 long ints of stack
     22  2c48					      MAC	andlong
     23  2c48					      tsx
     24  2c48					      lda.wx	stack + 4
     25  2c48					      and.wx	stack + 1
     26  2c48					      sta.wx	stack + 4
     27  2c48					      lda.wx	stack + 5
     28  2c48					      and.wx	stack + 2
     29  2c48					      sta.wx	stack + 5
     30  2c48					      lda.wx	stack + 6
     31  2c48					      and.wx	stack + 3
     32  2c48					      sta.wx	stack + 6
     33  2c48					      inx
     34  2c48					      inx
     35  2c48					      inx
     36  2c48					      txs
     37  2c48					      ENDM
     38  2c48
     39  2c48							; Perform XOR on top 2 long ints of stack
     40  2c48					      MAC	xorlong
     41  2c48					      tsx
     42  2c48					      lda.wx	stack + 4
     43  2c48					      eor.wx	stack + 1
     44  2c48					      sta.wx	stack + 4
     45  2c48					      lda.wx	stack + 5
     46  2c48					      eor.wx	stack + 2
     47  2c48					      sta.wx	stack + 5
     48  2c48					      lda.wx	stack + 6
     49  2c48					      eor.wx	stack + 3
     50  2c48					      sta.wx	stack + 6
     51  2c48					      inx
     52  2c48					      inx
     53  2c48					      inx
     54  2c48					      txs
     55  2c48					      ENDM
     56  2c48
     57  2c48							; Add long ints on stack
     58  2c48					      MAC	addlong
     59  2c48					      tsx
     60  2c48					      clc
     61  2c48					      lda.wx	stack + 3
     62  2c48					      adc.wx	stack + 6
     63  2c48					      sta.wx	stack + 6
     64  2c48					      lda.wx	stack + 2
     65  2c48					      adc.wx	stack + 5
     66  2c48					      sta.wx	stack + 5
     67  2c48					      pla
     68  2c48					      adc.wx	stack + 4
     69  2c48					      sta.wx	stack + 4
     70  2c48					      inx
     71  2c48					      inx
     72  2c48					      inx
     73  2c48					      txs
     74  2c48					      ENDM
     75  2c48
     76  2c48							; Substract long ints on stack
     77  2c48					      MAC	sublong
     78  2c48					      tsx
     79  2c48					      sec
     80  2c48					      lda.wx	stack + 6
     81  2c48					      sbc.wx	stack + 3
     82  2c48					      sta.wx	stack + 6
     83  2c48					      lda.wx	stack + 5
     84  2c48					      sbc.wx	stack + 2
     85  2c48					      sta.wx	stack + 5
     86  2c48					      lda.wx	stack + 4
     87  2c48					      sbc.wx	stack + 1
     88  2c48					      sta.wx	stack + 4
     89  2c48					      inx
     90  2c48					      inx
     91  2c48					      inx
     92  2c48					      txs
     93  2c48					      ENDM
     94  2c48
     95  2c48							; Switch sign of long integer
     96  2c48					      MAC	twoscpllong
     97  2c48					      lda	{1} + 2
     98  2c48					      eor	#$ff
     99  2c48					      sta	{1} + 2
    100  2c48					      lda	{1} + 1
    101  2c48					      eor	#$ff
    102  2c48					      sta	{1} + 1
    103  2c48					      lda	{1}
    104  2c48					      eor	#$ff
    105  2c48					      clc
    106  2c48					      adc	#$01
    107  2c48					      sta	{1}
    108  2c48					      bne	.1
    109  2c48					      inc	{1} + 1
    110  2c48					      bne	.1
    111  2c48					      inc	{1} + 2
    112  2c48				   .1
    113  2c48					      ENDM
    114  2c48
    115  2c48							; Multiply top 2 long ints on stack
    116  2c48					      MAC	mullong
    117  2c48					      IF	!FPULL
    118  2c48					      pla
    119  2c48					      sta	R6
    120  2c48					      pla
    121  2c48					      sta	R5
    122  2c48					      pla
    123  2c48					      sta	R4
    124  2c48					      ELSE
    125  2c48					      sta	R4
    126  2c48					      sty	R5
    127  2c48					      stx	R6
    128  2c48					      ENDIF
    129  2c48					      pla
    130  2c48					      sta	R9
    131  2c48					      pla
    132  2c48					      sta	R8
    133  2c48					      pla
    134  2c48					      sta	R7
    135  2c48					      import	I_NUCLEUS_MUL24
    136  2c48					      jsr	NUCLEUS_MUL24
    137  2c48					      IF	!FPUSH
    138  2c48					      lda	R0
    139  2c48					      pha
    140  2c48					      lda	R1
    141  2c48					      pha
    142  2c48					      lda	R2
    143  2c48					      pha
    144  2c48					      ELSE
    145  2c48					      lda	R0
    146  2c48					      ldy	R1
    147  2c48					      ldx	R2
    148  2c48					      ENDIF
    149  2c48					      ENDM		; @pull @push
    150  2c48
    151  2c48							; Divide top 2 long ints on stack
    152  2c48					      MAC	divlong
    153  2c48					      IF	!FPULL
    154  2c48					      pla
    155  2c48					      sta	R7 + 2
    156  2c48					      pla
    157  2c48					      sta	R7 + 1
    158  2c48					      pla
    159  2c48					      sta	R7
    160  2c48					      ELSE
    161  2c48					      sta	R7
    162  2c48					      sty	R7 + 1
    163  2c48					      stx	R7 + 2
    164  2c48					      ENDIF
    165  2c48					      pla
    166  2c48					      sta	R4 + 2
    167  2c48					      pla
    168  2c48					      sta	R4 + 1
    169  2c48					      pla
    170  2c48					      sta	R4
    171  2c48					      import	I_NUCLEUS_DIV24
    172  2c48					      jsr	NUCLEUS_DIV24
    173  2c48					      IF	!FPUSH
    174  2c48					      lda	R4
    175  2c48					      pha
    176  2c48					      lda	R4 + 1
    177  2c48					      pha
    178  2c48					      lda	R4 + 2
    179  2c48					      pha
    180  2c48					      ELSE
    181  2c48					      lda	R4
    182  2c48					      ldy	R4 + 1
    183  2c48					      ldx	R4 + 2
    184  2c48					      ENDIF
    185  2c48					      ENDM		; @pull @push
    186  2c48
    187  2c48							; Modulo of top 2 long ints on stack
    188  2c48					      MAC	modlong
    189  2c48					      IF	!FPULL
    190  2c48					      pla
    191  2c48					      sta	R7 + 2
    192  2c48					      pla
    193  2c48					      sta	R7 + 1
    194  2c48					      pla
    195  2c48					      sta	R7
    196  2c48					      ELSE
    197  2c48					      sta	R7
    198  2c48					      sty	R7 + 1
    199  2c48					      stx	R7 + 2
    200  2c48					      ENDIF
    201  2c48					      pla
    202  2c48					      sta	R4 + 2
    203  2c48					      pla
    204  2c48					      sta	R4 + 1
    205  2c48					      pla
    206  2c48					      sta	R4
    207  2c48					      import	I_NUCLEUS_DIV24
    208  2c48					      jsr	NUCLEUS_DIV24
    209  2c48					      IF	!FPUSH
    210  2c48					      lda	R0
    211  2c48					      pha
    212  2c48					      lda	R0 + 1
    213  2c48					      pha
    214  2c48					      lda	R0 + 2
    215  2c48					      pha
    216  2c48					      ELSE
    217  2c48					      lda	R0
    218  2c48					      ldy	R0 + 1
    219  2c48					      ldx	R0 + 2
    220  2c48					      ENDIF
    221  2c48					      ENDM		; @pull @push
    222  2c48
    223  2c48							; Perform NOT on long int on stack
    224  2c48					      MAC	notlong
    225  2c48					      tsx
    226  2c48					      lda.wx	stack + 1
    227  2c48					      eor	#$ff
    228  2c48					      sta.wx	stack + 1
    229  2c48					      lda.wx	stack + 2
    230  2c48					      eor	#$ff
    231  2c48					      sta.wx	stack + 2
    232  2c48					      lda.wx	stack + 3
    233  2c48					      eor	#$ff
    234  2c48					      sta.wx	stack + 3
    235  2c48					      ENDM
    236  2c48
    237  2c48							; Negate long int on stack
    238  2c48					      MAC	neglong
    239  2c48					      tsx
    240  2c48					      lda.wx	stack + 3
    241  2c48					      eor	#$ff
    242  2c48					      sta.wx	stack + 3
    243  2c48					      lda.wx	stack + 2
    244  2c48					      eor	#$ff
    245  2c48					      sta.wx	stack + 2
    246  2c48					      lda.wx	stack + 1
    247  2c48					      eor	#$ff
    248  2c48					      clc
    249  2c48					      adc	#01
    250  2c48					      sta.wx	stack + 1
    251  2c48					      bne	.q
    252  2c48					      inc.wx	stack + 2
    253  2c48					      bne	.q
    254  2c48					      inc.wx	stack + 3
    255  2c48				   .q
    256  2c48					      ENDM
    257  2c48
    258  2c48							; Shift left with number of binary places
    259  2c48							; stored in a byte on top of stack
    260  2c48					      MAC	lshiftlong
    261  2c48					      IF	!FPULL
    262  2c48					      pla
    263  2c48					      ENDIF
    264  2c48					      tay
    265  2c48					      tsx
    266  2c48				   .loop
    267  2c48					      cpy	#$00
    268  2c48					      beq	.endloop
    269  2c48					      asl.wx	stack + 3
    270  2c48					      rol.wx	stack + 2
    271  2c48					      rol.wx	stack + 1
    272  2c48					      dey
    273  2c48					      bpl	.loop	; = branch always
    274  2c48				   .endloop
    275  2c48					      ENDM		; @pull
    276  2c48
    277  2c48							; LSHIFT() function
    278  2c48							; with constant argument
    279  2c48					      MAC	lshiftlongwconst
    280  2c48					      tsx
    281  2c48					      REPEAT	{1}
    282  2c48					      asl.wx	stack + 3
    283  2c48					      rol.wx	stack + 2
    284  2c48					      rol.wx	stack + 1
    285  2c48					      REPEND
    286  2c48					      ENDM
    287  2c48
    288  2c48							; Shift right with number of binary places
    289  2c48							; stored in a byte on top of stack
    290  2c48					      MAC	rshiftlong
    291  2c48					      IF	!FPULL
    292  2c48					      pla
    293  2c48					      ENDIF
    294  2c48					      tay
    295  2c48					      tsx
    296  2c48				   .loop
    297  2c48					      cpy	#$00
    298  2c48					      beq	.endloop
    299  2c48					      lda.wx	stack + 1
    300  2c48					      asl
    301  2c48					      ror.wx	stack + 1
    302  2c48					      ror.wx	stack + 2
    303  2c48					      ror.wx	stack + 3
    304  2c48					      dey
    305  2c48					      bpl	.loop	; = branch always
    306  2c48				   .endloop
    307  2c48					      ENDM		; @pull
    308  2c48
    309  2c48							; RSHIFT() function
    310  2c48							; with constant argument
    311  2c48					      MAC	rshiftlongwconst
    312  2c48					      tsx
    313  2c48					      REPEAT	{1}
    314  2c48					      lda.wx	stack + 1
    315  2c48					      asl
    316  2c48					      ror.wx	stack + 1
    317  2c48					      ror.wx	stack + 2
    318  2c48					      ror.wx	stack + 3
    319  2c48					      REPEND
    320  2c48					      ENDM
    321  2c48
    322  2c48							; Signed 24-bit multiply routine
    323  2c48				  -	      IFCONST	I_NUCLEUS_MUL24_IMPORTED
    324  2c48				  -NUCLEUS_MUL24 SUBROUTINE
    325  2c48				  -.factor1   EQU	R4
    326  2c48				  -.factor2   EQU	R7
    327  2c48				  -.product   EQU	R0
    328  2c48				  -
    329  2c48				  -	      ldx	#$00
    330  2c48				  -	      lda	R4 + 2
    331  2c48				  -	      bpl	.skip
    332  2c48				  -	      twoscpllong	R4
    333  2c48				  -	      inx
    334  2c48				  -.skip
    335  2c48				  -	      lda	R7 + 2
    336  2c48				  -	      bpl	.skip2
    337  2c48				  -	      twoscpllong	R7
    338  2c48				  -	      inx
    339  2c48				  -.skip2
    340  2c48				  -	      jsr	NUCLEUS_MULU24
    341  2c48				  -	      txa
    342  2c48				  -	      and	#$01
    343  2c48				  -	      beq	.q
    344  2c48				  -	      twoscpllong	R0
    345  2c48				  -.q	      rts
    346  2c48				  -
    347  2c48				  -			; Unsigned 24-bit multiply routine
    348  2c48				  -NUCLEUS_MULU24 SUBROUTINE
    349  2c48				  -.factor1   EQU	R4
    350  2c48				  -.factor2   EQU	R7
    351  2c48				  -.product   EQU	R0
    352  2c48				  -
    353  2c48				  -	      lda	#$00
    354  2c48				  -	      sta	R0
    355  2c48				  -	      sta	R0 + 1
    356  2c48				  -	      sta	R0 + 2
    357  2c48				  -
    358  2c48				  -.loop
    359  2c48				  -	      lda	R7
    360  2c48				  -	      bne	.nz
    361  2c48				  -	      lda	R7 + 1
    362  2c48				  -	      bne	.nz
    363  2c48				  -	      lda	R7 + 2
    364  2c48				  -	      bne	.nz
    365  2c48				  -	      rts
    366  2c48				  -.nz
    367  2c48				  -	      lda	R7
    368  2c48				  -	      and	#$01
    369  2c48				  -	      beq	.skip
    370  2c48				  -
    371  2c48				  -	      lda	R4
    372  2c48				  -	      clc
    373  2c48				  -	      adc	R0
    374  2c48				  -	      sta	R0
    375  2c48				  -
    376  2c48				  -	      lda	R4 + 1
    377  2c48				  -	      adc	R0 + 1
    378  2c48				  -	      sta	R0 + 1
    379  2c48				  -
    380  2c48				  -	      lda	R4 + 2
    381  2c48				  -	      adc	R0 + 2
    382  2c48				  -	      sta	R0 + 2
    383  2c48				  -
    384  2c48				  -.skip
    385  2c48				  -	      asl	R4
    386  2c48				  -	      rol	R4 + 1
    387  2c48				  -	      rol	R4 + 2
    388  2c48				  -	      lsr	R7 + 2
    389  2c48				  -	      ror	R7 + 1
    390  2c48				  -	      ror	R7
    391  2c48				  -
    392  2c48				  -	      jmp	.loop
    393  2c48					      ENDIF
    394  2c48
    395  2c48							; Signed 24-bit multiply routine
    396  2c48				  -	      IFCONST	I_NUCLEUS_DIV24_IMPORTED
    397  2c48				  -NUCLEUS_DIV24 SUBROUTINE
    398  2c48				  -
    399  2c48				  -.dividend  EQU	R4
    400  2c48				  -.divisor   EQU	R7
    401  2c48				  -
    402  2c48				  -	      ldx	#$00
    403  2c48				  -	      lda	R4 + 2
    404  2c48				  -	      bpl	.skip
    405  2c48				  -	      twoscpllong	R4
    406  2c48				  -	      inx
    407  2c48				  -.skip
    408  2c48				  -	      lda	R7 + 2
    409  2c48				  -	      bpl	.skip2
    410  2c48				  -	      twoscpllong	R7
    411  2c48				  -	      inx
    412  2c48				  -.skip2
    413  2c48				  -	      txa
    414  2c48				  -	      pha
    415  2c48				  -	      jsr	NUCLEUS_DIVU24
    416  2c48				  -	      pla
    417  2c48				  -	      and	#$01
    418  2c48				  -	      beq	.q
    419  2c48				  -	      twoscpllong	R4
    420  2c48				  -.q	      rts
    421  2c48				  -
    422  2c48				  -			; Unsigned 24 integer division
    423  2c48				  -			; the result goes to dividend and remainder variables
    424  2c48				  -			; https://codebase64.org/doku.php?id=base:24bit_division_24-bit_result
    425  2c48				  -NUCLEUS_DIVU24 SUBROUTINE
    426  2c48				  -.dividend  EQU	R4
    427  2c48				  -.divisor   EQU	R7
    428  2c48				  -.remainder EQU	R0
    429  2c48				  -.pztemp    EQU	R3
    430  2c48				  -
    431  2c48				  -	      lda	.divisor
    432  2c48				  -	      bne	.ok
    433  2c48				  -	      lda	.divisor + 1
    434  2c48				  -	      bne	.ok
    435  2c48				  -	      lda	.divisor + 2
    436  2c48				  -	      bne	.ok
    437  2c48				  -	      import	I_RUNTIME_ERROR
    438  2c48				  -	      lda	#ERR_DIVZERO
    439  2c48				  -	      jmp	RUNTIME_ERROR
    440  2c48				  -.ok
    441  2c48				  -	      lda	#0
    442  2c48				  -	      sta	.remainder
    443  2c48				  -	      sta	.remainder + 1
    444  2c48				  -	      sta	.remainder + 2
    445  2c48				  -	      ldx	#24	;repeat for each bit: ...
    446  2c48				  -
    447  2c48				  -.divloop
    448  2c48				  -	      asl	.dividend
    449  2c48				  -	      rol	.dividend + 1
    450  2c48				  -	      rol	.dividend + 2
    451  2c48				  -	      rol	.remainder
    452  2c48				  -	      rol	.remainder + 1
    453  2c48				  -	      rol	.remainder + 2
    454  2c48				  -	      lda	.remainder
    455  2c48				  -	      sec
    456  2c48				  -	      sbc	.divisor
    457  2c48				  -	      tay
    458  2c48				  -	      lda	.remainder + 1
    459  2c48				  -	      sbc	.divisor + 1
    460  2c48				  -	      sta	.pztemp
    461  2c48				  -	      lda	.remainder + 2
    462  2c48				  -	      sbc	.divisor + 2
    463  2c48				  -	      bcc	.skip
    464  2c48				  -
    465  2c48				  -	      sta	.remainder + 2
    466  2c48				  -	      lda	.pztemp
    467  2c48				  -	      sta	.remainder + 1
    468  2c48				  -	      sty	.remainder
    469  2c48				  -	      inc	.dividend
    470  2c48				  -
    471  2c48				  -.skip
    472  2c48				  -	      dex
    473  2c48				  -	      bne	.divloop
    474  2c48				  -	      rts
    475  2c48					      ENDIF
------- FILE core/arith/arith.asm
------- FILE core/arith/_float.asm LEVEL 4 PASS 4
      0  2c48					      INCLUDE	"core/arith/_float.asm"
      1  2c48					      PROCESSOR	6502
      2  2c48
      3  2c48							; Add top 2 floats on stack
      4  2c48					      MAC	addfloat
      5  2c48					      plfloattofac
      6  2c48					      plfloattoarg
      7  2c48					      import	I_FPLIB
      8  2c48					      jsr	FADDT
      9  2c48					      pfac
     10  2c48					      ENDM		; @push
     11  2c48
     12  2c48							; Subtract top 2 floats on stack
     13  2c48					      MAC	subfloat
     14  2c48					      plfloattofac
     15  2c48					      plfloattoarg
     16  2c48					      import	I_FPLIB
     17  2c48					      jsr	FSUBT
     18  2c48					      pfac
     19  2c48					      ENDM		; @push
     20  2c48
     21  2c48							; Multiply top 2 floats on stack
     22  2c48					      MAC	mulfloat
     23  2c48					      plfloattofac
     24  2c48					      plfloattoarg
     25  2c48					      import	I_FPLIB
     26  2c48					      jsr	FMULTT
     27  2c48					      pfac
     28  2c48					      ENDM		; @push
     29  2c48
     30  2c48							; Divide top 2 floats on stack
     31  2c48					      MAC	divfloat
     32  2c48					      plfloattofac
     33  2c48					      plfloattoarg
     34  2c48					      import	I_FPLIB
     35  2c48					      jsr	FDIVT
     36  2c48					      pfac
     37  2c48					      ENDM		; @push
     38  2c48
     39  2c48							; Modulo of top 2 floats on stack
     40  2c48					      MAC	modfloat
     41  2c48					      plfloattofac
     42  2c48					      plfloattoarg
     43  2c48					      import	I_FMOD
     44  2c48					      jsr	I_FMOD
     45  2c48					      pfac
     46  2c48					      ENDM		; @push
     47  2c48
     48  2c48							; Negate float on stack
     49  2c48					      MAC	negfloat
     50  2c48					      tsx
     51  2c48					      lda	stack + 2,x
     52  2c48					      eor	#%10000000
     53  2c48					      sta	stack + 2,x
     54  2c48					      ENDM
     55  2c48
     56  2c48							; Discard top float on stack
     57  2c48					      MAC	discardfloat
     58  2c48					      tsx
     59  2c48					      inx
     60  2c48					      inx
     61  2c48					      inx
     62  2c48					      inx
     63  2c48					      txs
     64  2c48					      ENDM
     65  2c48
     66  2c48				  -	      IFCONST	I_FMOD_IMPORTED
     67  2c48				  -I_FMOD     SUBROUTINE
     68  2c48				  -	      ldx	#<.tmp
     69  2c48				  -	      ldy	#>.tmp
     70  2c48				  -	      import	I_FPLIB
     71  2c48				  -	      jsr	STORE_FAC_AT_YX_ROUNDED
     72  2c48				  -	      jsr	FDIVT
     73  2c48				  -	      jsr	COPY_FAC_TO_ARG_ROUNDED
     74  2c48				  -	      import	I_INT
     75  2c48				  -	      jsr	INT
     76  2c48				  -	      jsr	FSUBT
     77  2c48				  -	      lda	#<.tmp
     78  2c48				  -	      ldy	#>.tmp
     79  2c48				  -	      jmp	FMULT
     80  2c48				  -.tmp       HEX	00 00 00 00
     81  2c48					      ENDIF
------- FILE core/arith/arith.asm
------- FILE core/arith/_decimal.asm LEVEL 4 PASS 4
      0  2c48					      INCLUDE	"core/arith/_decimal.asm"
      1  2c48					      PROCESSOR	6502
      2  2c48
      3  2c48							; Add top 2 decimals on stack
      4  2c48					      MAC	adddecimal
      5  2c48					      IF	!USEIRQ
      6  2c48					      sei
      7  2c48					      ENDIF
      8  2c48					      sed
      9  2c48					      addword
     10  2c48					      cld
     11  2c48					      IF	!USEIRQ
     12  2c48					      cli
     13  2c48					      ENDIF
     14  2c48					      ENDM
     15  2c48
     16  2c48							; Substract top 2 decimals on stack
     17  2c48					      MAC	subdecimal
     18  2c48					      IF	!USEIRQ
     19  2c48					      sei
     20  2c48					      ENDIF
     21  2c48					      sed
     22  2c48					      subword
     23  2c48					      cld
     24  2c48					      IF	!USEIRQ
     25  2c48					      cli
     26  2c48					      ENDIF
     27  2c48					      ENDM
     28  2c48
     29  2c48							; Perform AND on top 2 decimals on stack
     30  2c48					      MAC	anddecimal
     31  2c48					      andword
     32  2c48					      ENDM
     33  2c48
     34  2c48							; Perform OR on top 2 decimals on stack
     35  2c48					      MAC	ordecimal
     36  2c48					      orword
     37  2c48					      ENDM
     38  2c48
     39  2c48							; Perform XOR on top 2 decimals of stack
     40  2c48					      MAC	xordecimal
     41  2c48					      xorword
     42  2c48					      ENDM
     43  2c48
     44  2c48							; Perform NOT on top 2 decimals of stack
     45  2c48					      MAC	notdecimal
     46  2c48					      notword
     47  2c48					      ENDM		; @pull
------- FILE core/arith/arith.asm
------- FILE xcb3lib.asm
     21  2c48							; Program structures
------- FILE core/struct/struct.asm LEVEL 3 PASS 4
      0  2c48					      INCLUDE	"core/struct/struct.asm"
      1  2c48							; This universal macro
      2  2c48							; can be used for if, while, until
      3  2c48							; usage:
      4  2c48							; cond_stmt <false_label> [, <else_label>]
      5  2c48					      MAC	cond_stmt
      6  2c48					      IF	!FPULL
      7  2c48					      pla
      8  2c48					      ENDIF
      9  2c48					      bne	* + 5
     10  2c48					      IF	{2} > 0 && {2} < $10000	; Both values represent void
     11  2c48					      jmp	{2}
     12  2c48					      ELSE
     13  2c48					      jmp	{1}
     14  2c48					      ENDIF
     15  2c48					      ENDM		; @pull
     16  2c48
     17  2c48							; Same as above but it enters block if
     18  2c48							; Contidion evals to false
     19  2c48					      MAC	neg_cond_stmt
     20  2c48					      IF	!FPULL
     21  2c48					      pla
     22  2c48					      ENDIF
     23  2c48					      beq	* + 5
     24  2c48					      IF	{2} > 0 && {2} < $10000	; Both values represent void
     25  2c48					      jmp	{2}
     26  2c48					      ELSE
     27  2c48					      jmp	{1}
     28  2c48					      ENDIF
     29  2c48					      ENDM		; @pull
     30  2c48
     31  2c48							; Jumps to block {1} if true
     32  2c48							; Or to next case {2} otherwise
     33  2c48					      MAC	case
     34  2c48					      IF	!FPULL
     35  2c48					      pla
     36  2c48					      ENDIF
     37  2c48					      bne	.true
     38  2c48					      jmp	{2}
     39  2c48				   .true
     40  2c48					      jmp	{1}
     41  2c48					      ENDIF
     42  2c48					      ENDM		;@pull
     43  2c48
     44  2c48							; Entry of FOR loop (integer counter)
     45  2c48							; Usage: forint <block id>, <counter_var>, <limit>, <step_var>, <is_limit_const>
     46  2c48					      MAC	forint
     47  2c48					      IFCONST	{4}
     48  2c48							; Check if step is negative
     49  2c48					      lda	{4} + 1
     50  2c48							; it is positive: do the regular comparison
     51  2c48					      bpl	.cmp
     52  2c48				   .neg
     53  2c48							; compare counter var to limit (downwards)
     54  2c48					      IF	{5} == 1	; Limit is constant
     55  2c48					      lda	{2}
     56  2c48					      cmp	#<{3}
     57  2c48					      lda	{2} + 1
     58  2c48					      sbc	#>{3}
     59  2c48					      ELSE
     60  2c48					      lda	{2}
     61  2c48					      cmp	{3}
     62  2c48					      lda	{2} + 1
     63  2c48					      sbc	{3} + 1
     64  2c48					      ENDIF
     65  2c48					      bpl	.enter	; Enter the code block
     66  2c48					      jmp	_ENDFOR_{1}	; Exit loop
     67  2c48					      ENDIF
     68  2c48				   .cmp
     69  2c48							; compare counter var to limit var (upwards)
     70  2c48					      IF	{5} == 1	; Limit is constant
     71  2c48					      lda	#<{3}
     72  2c48					      cmp	{2}
     73  2c48					      lda	#>{3}
     74  2c48					      sbc	{2} + 1
     75  2c48					      ELSE
     76  2c48					      lda	{3}
     77  2c48					      cmp	{2}
     78  2c48					      lda	{3} + 1
     79  2c48					      sbc	{2} + 1
     80  2c48					      ENDIF
     81  2c48					      bpl	.enter	; Enter the code block
     82  2c48					      jmp	_ENDFOR_{1}	; Exit loop
     83  2c48				   .enter
     84  2c48					      ENDM
     85  2c48
     86  2c48							; NEXT routine (integer index)
     87  2c48							; Usage: nextint <block id>, <counter_var>, <step_var>
     88  2c48					      MAC	nextint
     89  2c48							; increment index variable
     90  2c48					      IFCONST	{3}
     91  2c48							; increment with step
     92  2c48					      clc
     93  2c48					      lda	{3}
     94  2c48					      adc	{2}
     95  2c48					      sta	{2}
     96  2c48					      lda	{3} + 1
     97  2c48					      adc	{2} + 1
     98  2c48					      sta	{2} + 1
     99  2c48					      ELSE
    100  2c48							; increment with 1
    101  2c48					      inc	{2}
    102  2c48					      bne	.skip
    103  2c48					      inc	{2} + 1
    104  2c48					      ENDIF
    105  2c48				   .skip
    106  2c48							; Jump back to loop entry
    107  2c48					      jmp	_FOR_{1}
    108  2c48					      ENDM
    109  2c48
    110  2c48							; Entry of FOR loop (long counter)
    111  2c48							; Usage: forlong <block id>, <counter_var>, <limit_var>, <step_var>, <is_limit_const>
    112  2c48					      MAC	forlong
    113  2c48					      IFCONST	{4}
    114  2c48							; Check if step is negative
    115  2c48					      lda	{4} + 2
    116  2c48							; it is positive: do the regular comparison
    117  2c48					      bpl	.cmp
    118  2c48				   .neg
    119  2c48							; compare counter var to limit var (downwards)
    120  2c48					      IF	{5} == 1	; Limit is constant
    121  2c48					      lda	{2}
    122  2c48					      cmp	#<{3}
    123  2c48					      lda	{2} + 1
    124  2c48					      sbc	#>{3}
    125  2c48					      lda	{2} + 2
    126  2c48					      sbc	#[{3} >> 16]
    127  2c48					      ELSE
    128  2c48					      lda	{2}
    129  2c48					      cmp	{3}
    130  2c48					      lda	{2} + 1
    131  2c48					      sbc	{3} + 1
    132  2c48					      lda	{2} + 2
    133  2c48					      sbc	{3} + 2
    134  2c48					      ENDIF
    135  2c48					      bpl	.enter	; Enter the code block
    136  2c48					      jmp	_ENDFOR_{1}	; Exit loop
    137  2c48					      ENDIF
    138  2c48				   .cmp
    139  2c48							; compare counter var to limit var (upwards)
    140  2c48					      IF	{5} == 1	; Limit is constant
    141  2c48					      lda	#<{3}
    142  2c48					      cmp	{2}
    143  2c48					      lda	#>{3}
    144  2c48					      sbc	{2} + 1
    145  2c48					      lda	#[{3} >> 16]
    146  2c48					      sbc	{2} + 2
    147  2c48					      ELSE
    148  2c48					      lda	{3}
    149  2c48					      cmp	{2}
    150  2c48					      lda	{3} + 1
    151  2c48					      sbc	{2} + 1
    152  2c48					      lda	{3} + 2
    153  2c48					      sbc	{2} + 2
    154  2c48					      ENDIF
    155  2c48					      bpl	.enter	; Enter the code block
    156  2c48					      jmp	_ENDFOR_{1}	; Exit loop
    157  2c48				   .enter
    158  2c48					      ENDM
    159  2c48
    160  2c48							; NEXT routine (long counter)
    161  2c48							; Usage: nextint <block id>, <counter_var>, <step_var>
    162  2c48					      MAC	nextlong
    163  2c48							; increment index variable
    164  2c48					      IFCONST	{3}
    165  2c48							; increment with step
    166  2c48					      clc
    167  2c48					      lda	{3}
    168  2c48					      adc	{2}
    169  2c48					      sta	{2}
    170  2c48					      lda	{3} + 1
    171  2c48					      adc	{2} + 1
    172  2c48					      sta	{2} + 1
    173  2c48					      lda	{3} + 2
    174  2c48					      adc	{2} + 2
    175  2c48					      sta	{2} + 2
    176  2c48					      ELSE
    177  2c48							; increment with 1
    178  2c48					      inc	{2}
    179  2c48					      bne	.skip
    180  2c48					      inc	{2} + 1
    181  2c48					      bne	.skip
    182  2c48					      inc	{2} + 2
    183  2c48					      ENDIF
    184  2c48				   .skip
    185  2c48							; Jump back to loop entry
    186  2c48					      jmp	_FOR_{1}
    187  2c48					      ENDM
    188  2c48
    189  2c48							; Usage: forword <block id>, <counter_var>, <limit_var>, <step_var>, <is_limit_const>
    190  2c48					      MAC	forword
    191  2c48							; compare index to max
    192  2c48					      IF	{5} == 1	; Constant limit
    193  2c48					      lda	#<{3}
    194  2c48					      cmp	{2}
    195  2c48					      lda	#>{3}
    196  2c48					      sbc	{2} + 1
    197  2c48					      ELSE
    198  2c48					      lda	{3}
    199  2c48					      cmp	{2}
    200  2c48					      lda	{3} + 1
    201  2c48					      sbc	{2} + 1
    202  2c48					      ENDIF
    203  2c48					      bcs	.enter	; Enter the code block
    204  2c48					      jmp	_ENDFOR_{1}	; Exit loop
    205  2c48				   .enter
    206  2c48					      ENDM
    207  2c48
    208  2c48							; NEXT routine (word counter)
    209  2c48							; Usage: nextb <block id>, <counter var>, <step var>
    210  2c48					      MAC	nextword
    211  2c48							; increment index variable
    212  2c48					      IFCONST	{3}
    213  2c48							; increment with step
    214  2c48					      clc
    215  2c48					      lda	{3}
    216  2c48					      adc	{2}
    217  2c48					      sta	{2}
    218  2c48					      lda	{3} + 1
    219  2c48					      adc	{2} + 1
    220  2c48					      sta	{2} + 1
    221  2c48							; don't roll over
    222  2c48					      bcs	_ENDFOR_{1}
    223  2c48					      ELSE
    224  2c48							; increment with one
    225  2c48					      inc	{2}
    226  2c48					      bne	.skip
    227  2c48					      inc	{2} + 1
    228  2c48							; don't roll over
    229  2c48					      beq	_ENDFOR_{1}
    230  2c48				   .skip
    231  2c48					      ENDIF
    232  2c48					      jmp	_FOR_{1}
    233  2c48					      ENDM
    234  2c48
    235  2c48							; Entry of FOR loop (byte index)
    236  2c48							; Usage: forbyte <block id>, <counter_var>, <limit_var>, <step_var>, <is_limit_const>
    237  2c48					      MAC	forbyte
    238  2c48							; compare index to max
    239  2c48					      IF	{5} == 1
    240  2c48					      lda	#{3}
    241  2c48					      ELSE
    242  2c48					      lda	{3}
    243  2c48					      ENDIF
    244  2c48					      cmp	{2}
    245  2c48					      bcs	.enter
    246  2c48							;index is gte, exit loop
    247  2c48					      jmp	_ENDFOR_{1}
    248  2c48				   .enter
    249  2c48					      ENDM
    250  2c48
    251  2c48							; NEXT routine (byte index)
    252  2c48							; Usage: nextb <block id>, <counter var>, <step var>
    253  2c48					      MAC	nextbyte
    254  2c48							; increment index variable
    255  2c48					      IFCONST	{3}
    256  2c48							; increment with step
    257  2c48					      clc
    258  2c48					      lda	{3}
    259  2c48					      adc	{2}
    260  2c48					      sta	{2}
    261  2c48							; don't roll over
    262  2c48					      bcs	_ENDFOR_{1}
    263  2c48					      ELSE
    264  2c48							; increment with one
    265  2c48					      inc	{2}
    266  2c48							; don't roll over
    267  2c48					      beq	_ENDFOR_{1}
    268  2c48					      ENDIF
    269  2c48					      jmp	_FOR_{1}
    270  2c48					      ENDM
    271  2c48
    272  2c48							; Entry of FOR loop (float counter)
    273  2c48							; Usage: forfloat <block id>, <counter_var>, <limit_var>, <step_var>
    274  2c48					      MAC	forfloat
    275  2c48					      import	I_FPLIB
    276  2c48					      lda	#<{2}
    277  2c48					      ldy	#>{2}
    278  2c48					      jsr	LOAD_FAC_FROM_YA
    279  2c48					      lda	#<{3}
    280  2c48					      ldy	#>{3}
    281  2c48					      jsr	FCOMP
    282  2c48							; result comparison in A
    283  2c48					      IFCONST	{4}
    284  2c48							; Check if step is negative
    285  2c48					      ldx	{4} + 1
    286  2c48					      bpl	.upwards
    287  2c48					      cmp	#255
    288  2c48					      bne	.enter
    289  2c48					      jmp	_ENDFOR_{1}
    290  2c48					      ENDIF
    291  2c48				   .upwards
    292  2c48					      cmp	#1
    293  2c48					      bne	.enter
    294  2c48					      jmp	_ENDFOR_{1}
    295  2c48				   .enter
    296  2c48					      ENDM
    297  2c48
    298  2c48							; NEXT routine (float index)
    299  2c48							; Usage: nextfloat <block id>, <counter_var>, <step_var>
    300  2c48					      MAC	nextfloat
    301  2c48					      import	I_FPLIB
    302  2c48					      lda	#<{2}
    303  2c48					      ldy	#>{2}
    304  2c48					      jsr	LOAD_FAC_FROM_YA
    305  2c48							; increment index variable
    306  2c48					      IFCONST	{3}
    307  2c48							; increment with step
    308  2c48					      lda	#<{3}
    309  2c48					      ldy	#>{3}
    310  2c48					      ELSE
    311  2c48							; increment with 1
    312  2c48					      lda	#<CON_ONE
    313  2c48					      ldy	#>CON_ONE
    314  2c48					      ENDIF
    315  2c48					      jsr	FADD
    316  2c48					      ldx	#<{2}
    317  2c48					      ldy	#>{2}
    318  2c48					      jsr	STORE_FAC_AT_YX_ROUNDED
    319  2c48				   .skip
    320  2c48							; Jump back to loop entry
    321  2c48					      jmp	_FOR_{1}
    322  2c48					      ENDM
    323  2c48
    324  2c48							; ON GOTO statement
    325  2c48							; Usage: ongoto {lowbytes of labels}, {hibytes of labels}
    326  2c48					      MAC	ongoto
    327  2c48					      IF	!FPULL
    328  2c48					      pla
    329  2c48					      ENDIF
    330  2c48					      tax
    331  2c48					      lda.wx	{1}
    332  2c48					      sta	.jump + 1
    333  2c48					      lda.wx	{2}
    334  2c48					      sta	.jump + 2
    335  2c48				   .jump
    336  2c48					      jmp	$ffff
    337  2c48					      ENDM		; @pull
    338  2c48
    339  2c48							; ON GOSUB statement
    340  2c48							; Usage: ongosub {lowbytes of labels}, {hibytes of labels}
    341  2c48					      MAC	ongosub
    342  2c48					      IF	!FPULL
    343  2c48					      pla
    344  2c48					      ENDIF
    345  2c48					      tax
    346  2c48					      lda.wx	{1}
    347  2c48					      sta	.jump + 1
    348  2c48					      lda.wx	{2}
    349  2c48					      sta	.jump + 2
    350  2c48				   .jump
    351  2c48					      jsr	$ffff
    352  2c48					      ENDM		; @pull
------- FILE xcb3lib.asm
     23  2c48							; Math library, floating point arithmetics
------- FILE math/math.asm LEVEL 3 PASS 4
      0  2c48					      INCLUDE	"math/math.asm"
------- FILE math/_fn.asm LEVEL 4 PASS 4
      0  2c48					      INCLUDE	"math/_fn.asm"
      1  2c48							; XC-BASIC numeric functions
      2  2c48
      3  2c48							; DECLARE FUNCTION ABS AS BYTE (num AS BYTE) SHARED STATIC INLINE
      4  2c48					      MAC	f_abs_byte
      5  2c48					      ENDM
      6  2c48
      7  2c48							; DECLARE FUNCTION ABS AS INT (num AS INT) SHARED STATIC INLINE
      8  2c48					      MAC	f_abs_int
      9  2c48					      tsx
     10  2c48					      lda.wx	stack+1
     11  2c48					      bpl	.skip
     12  2c48					      eor	#$ff
     13  2c48					      sta.wx	stack+1
     14  2c48					      lda.wx	stack+2
     15  2c48					      eor	#$ff
     16  2c48					      clc
     17  2c48					      adc	#$01
     18  2c48					      sta.wx	stack+2
     19  2c48					      bne	.skip
     20  2c48					      inc.wx	stack+1
     21  2c48				   .skip
     22  2c48					      ENDM
     23  2c48
     24  2c48							; DECLARE FUNCTION ABS AS WORD (num AS WORD) SHARED STATIC INLINE
     25  2c48					      MAC	f_abs_word
     26  2c48					      ENDM
     27  2c48
     28  2c48							; DECLARE FUNCTION ABS AS LONG (num AS LONG) SHARED STATIC INLINE
     29  2c48					      MAC	f_abs_long
     30  2c48					      tsx
     31  2c48					      lda.wx	stack + 1
     32  2c48					      bpl	.skip
     33  2c48					      eor	#$ff
     34  2c48					      sta.wx	stack + 1
     35  2c48					      lda.wx	stack + 2
     36  2c48					      eor	#$ff
     37  2c48					      sta.wx	stack + 2
     38  2c48					      lda.wx	stack + 3
     39  2c48					      eor	#$ff
     40  2c48					      clc
     41  2c48					      adc	#$01
     42  2c48					      sta.wx	stack + 3
     43  2c48					      bne	.skip
     44  2c48					      inc.wx	stack + 2
     45  2c48					      bne	.skip
     46  2c48					      inc.wx	stack + 1
     47  2c48				   .skip
     48  2c48					      ENDM
     49  2c48
     50  2c48							; DECLARE FUNCTION ABS AS FLOAT (num AS FLOAT) SHARED STATIC INLINE
     51  2c48					      MAC	f_abs_float
     52  2c48					      tsx
     53  2c48					      lda.wx	stack + 2
     54  2c48					      and	#%01111111
     55  2c48					      sta.wx	stack + 2
     56  2c48					      ENDM
     57  2c48
     58  2c48							; DECLARE FUNCTION SGN AS INT (num AS BYTE) SHARED STATIC INLINE
     59  2c48					      MAC	f_sgn_byte
     60  2c48					      IF	!FPULL
     61  2c48					      pla
     62  2c48					      ENDIF
     63  2c48					      beq	.z
     64  2c48					      lda	#$01
     65  2c48				   .z
     66  2c48					      IF	!FPUSH
     67  2c48					      pha
     68  2c48					      lda	#$00
     69  2c48					      pha
     70  2c48					      ELSE
     71  2c48					      ldy	#$00
     72  2c48					      ENDIF
     73  2c48					      ENDM		; @pull @push
     74  2c48
     75  2c48							; DECLARE FUNCTION SGN AS INT (num AS INT) SHARED STATIC INLINE
     76  2c48					      MAC	f_sgn_int
     77  2c48					      pla
     78  2c48					      bmi	.neg
     79  2c48					      beq	.plz
     80  2c48					      pla
     81  2c48				   .pos
     82  2c48					      pint	1
     83  2c48					      beq	.end
     84  2c48				   .plz
     85  2c48					      pla
     86  2c48					      bne	.pos
     87  2c48					      pint	0
     88  2c48					      beq	.end
     89  2c48				   .neg
     90  2c48					      pla
     91  2c48					      pint	-1
     92  2c48				   .end
     93  2c48					      ENDM		; @push
     94  2c48
     95  2c48							; DECLARE FUNCTION SGN AS INT (num AS WORD) SHARED STATIC INLINE
     96  2c48					      MAC	f_sgn_word
     97  2c48					      pla
     98  2c48					      beq	.plz
     99  2c48					      pla
    100  2c48				   .pos
    101  2c48					      pint	1
    102  2c48					      beq	.end
    103  2c48				   .plz
    104  2c48					      pla
    105  2c48					      bne	.pos
    106  2c48					      pint	0
    107  2c48				   .end
    108  2c48					      ENDM		; @push
    109  2c48
    110  2c48							; DECLARE FUNCTION SGN AS INTEGER (num AS LONG) SHARED STATIC INLINE
    111  2c48					      MAC	f_sgn_long
    112  2c48					      pla
    113  2c48					      bmi	.neg
    114  2c48					      pla
    115  2c48					      bne	.pos
    116  2c48					      pla
    117  2c48					      bne	.pos + 1
    118  2c48					      pint	0
    119  2c48					      beq	.end
    120  2c48				   .pos
    121  2c48					      pla
    122  2c48					      pint	1
    123  2c48					      beq	.end
    124  2c48				   .neg
    125  2c48					      pla
    126  2c48					      pla
    127  2c48					      pint	-1
    128  2c48				   .end
    129  2c48					      ENDM		; @push
    130  2c48
    131  2c48							; DECLARE FUNCTION SGN AS INTEGER (num AS FLOAT) SHARED STATIC INLINE
    132  2c48					      MAC	f_sgn_float
    133  2c48					      IF	!FPULL
    134  2c48					      pla
    135  2c48					      sta	R0
    136  2c48					      pla
    137  2c48					      sta	R1
    138  2c48					      pla
    139  2c48					      pla
    140  2c48					      ELSE
    141  2c48					      pla
    142  2c48					      stx	R0
    143  2c48					      sty	R1
    144  2c48					      ENDIF
    145  2c48					      lda	R0
    146  2c48					      beq	.q
    147  2c48					      lda	R1
    148  2c48					      bmi	.neg
    149  2c48					      lda	#$01
    150  2c48					      bne	.q
    151  2c48				   .neg
    152  2c48					      pint	-1
    153  2c48					      bmi	.end
    154  2c48				   .q
    155  2c48					      IF	!FPUSH
    156  2c48					      pha
    157  2c48					      lda	#0
    158  2c48					      pha
    159  2c48					      ELSE
    160  2c48					      ldy	#0
    161  2c48					      ENDIF
    162  2c48				   .end
    163  2c48					      ENDM		; @pull @push
    164  2c48
    165  2c48							; DECLARE FUNCTION POW AS LONG (base AS WORD, exp AS BYTE) SHARED STATIC INLINE
    166  2c48					      MAC	f_pow_word_byte
    167  2c48					      IF	!FPULL
    168  2c48					      pla
    169  2c48					      ENDIF
    170  2c48					      tax
    171  2c48					      pla
    172  2c48					      sta	FAC + 1
    173  2c48					      pla
    174  2c48					      sta	FAC
    175  2c48					      txa
    176  2c48					      import	I_EXP
    177  2c48					      jsr	I_EXP
    178  2c48					      IF	!FPUSH
    179  2c48					      lda	R0
    180  2c48					      pha
    181  2c48					      lda	R0 + 1
    182  2c48					      pha
    183  2c48					      lda	R0 + 2
    184  2c48					      pha
    185  2c48					      ELSE
    186  2c48					      lda	R0
    187  2c48					      ldy	R0 + 1
    188  2c48					      ldx	R0 + 2
    189  2c48					      ENDIF
    190  2c48					      ENDM		; @pull @push
    191  2c48
    192  2c48							; DECLARE FUNCTION POW AS LONG (base AS INT, exp AS BYTE) OVERRIDE SHARED STATIC INLINE
    193  2c48							; TODO FIND BUG
    194  2c48					      MAC	f_pow_int_byte
    195  2c48				   .SIGN      EQU	ARG
    196  2c48				   .EXP       EQU	ARG + 1
    197  2c48					      IF	!FPULL
    198  2c48					      pla
    199  2c48					      ENDIF
    200  2c48					      sta	.EXP
    201  2c48					      pla
    202  2c48					      sta	FAC + 1
    203  2c48					      pla
    204  2c48					      sta	FAC
    205  2c48					      lda	#0
    206  2c48					      sta	.SIGN
    207  2c48					      lda	FAC + 1
    208  2c48					      bpl	.pos
    209  2c48					      twoscplint	FAC
    210  2c48					      inc	.SIGN
    211  2c48				   .pos
    212  2c48					      lda	.EXP
    213  2c48					      import	I_EXP
    214  2c48					      jsr	I_EXP
    215  2c48					      lda	.SIGN
    216  2c48					      beq	.q
    217  2c48					      lda	.EXP
    218  2c48					      and	#%00000001
    219  2c48					      beq	.q
    220  2c48					      twoscpllong	R0
    221  2c48				   .q
    222  2c48					      IF	!FPUSH
    223  2c48					      lda	R0
    224  2c48					      pha
    225  2c48					      lda	R0 + 1
    226  2c48					      pha
    227  2c48					      lda	R0 + 2
    228  2c48					      pha
    229  2c48					      ELSE
    230  2c48					      lda	R0
    231  2c48					      ldy	R0 + 1
    232  2c48					      ldx	R0 + 2
    233  2c48					      ENDIF
    234  2c48					      ENDM		; @pull @push
    235  2c48
    236  2c48							; Exponentiation
    237  2c48							; taken from https://codebase64.org/doku.php?id=base:exponentiation
    238  2c48				  -	      IFCONST	I_EXP_IMPORTED
    239  2c48				  -I_EXP      SUBROUTINE
    240  2c48				  -			; input:  B value to be raised
    241  2c48				  -			;	   A exponent
    242  2c48				  -			;
    243  2c48				  -			; algo:  if .A=0 res=1
    244  2c48				  -			;	  if .A=1 res=B
    245  2c48				  -			;	      _
    246  2c48				  -			;	     | B if E=1
    247  2c48				  -			; Exp(B,E)= | B*Exp(B,E-1) if E is odd
    248  2c48				  -			;	     |_Exp(B,E/2)*Exp(B,E/2) if E is even
    249  2c48				  -			;
    250  2c48				  -
    251  2c48				  -P	      EQU	R0
    252  2c48				  -M	      EQU	R4
    253  2c48				  -N	      EQU	R8
    254  2c48				  -			; No more pseudo-regs, use FAC
    255  2c48				  -B	      EQU	FAC
    256  2c48				  -
    257  2c48				  -	      tax
    258  2c48				  -	      beq	.res1	; is E==0 ?
    259  2c48				  -	      lda	B
    260  2c48				  -	      lsr
    261  2c48				  -	      ora	B + 1
    262  2c48				  -	      beq	.resB	; if B==0 or B==1 then result=B
    263  2c48				  -	      txa
    264  2c48				  -	      cmp	#1
    265  2c48				  -	      bne	.ExpSub
    266  2c48				  -.resB
    267  2c48				  -	      lda	#0	; E==1 | B==1 | B==0, result=B
    268  2c48				  -	      sta	P + 2
    269  2c48				  -	      sta	P + 3
    270  2c48				  -	      lda	B
    271  2c48				  -	      sta	P
    272  2c48				  -	      lda	B + 1
    273  2c48				  -	      sta	P + 1
    274  2c48				  -	      rts
    275  2c48				  -.res1
    276  2c48				  -	      sta	P + 1	; E=0, result=1
    277  2c48				  -	      sta	P + 2
    278  2c48				  -	      sta	P + 3
    279  2c48				  -	      lda	#1
    280  2c48				  -	      sta	P
    281  2c48				  -	      rts
    282  2c48				  -.ExpSub
    283  2c48				  -	      lsr		; E = int(E/2)
    284  2c48				  -	      beq	.resB	; E is 1
    285  2c48				  -	      bcs	.ExpOdd	; E is Odd
    286  2c48				  -.ExpEven
    287  2c48				  -	      jsr	.ExpSub	; E is Even
    288  2c48				  -	      ldx	#$3
    289  2c48				  -.ldP
    290  2c48				  -	      lda	P,x	; multiply P by itself
    291  2c48				  -	      sta	M,x	; P is the result of a previous mult
    292  2c48				  -	      sta	N,x	; copy P in M and N
    293  2c48				  -	      dex
    294  2c48				  -	      bpl	.ldP
    295  2c48				  -	      bmi	.Mult32
    296  2c48				  -
    297  2c48				  -.ExpOdd
    298  2c48				  -	      asl		; E = 2*int(E/2) (=E-1)
    299  2c48				  -	      jsr	.ExpSub
    300  2c48				  -	      ldx	#$4
    301  2c48				  -.ldD
    302  2c48				  -	      lda	<P-1,x	; multiply P by B
    303  2c48				  -	      sta	<M-1,x	; P is the result of a previous mult
    304  2c48				  -	      dex		; copy P in M
    305  2c48				  -	      bne	.ldD
    306  2c48				  -	      lda	B	; copy B in N
    307  2c48				  -	      sta	N
    308  2c48				  -	      lda	B + 1
    309  2c48				  -	      sta	N + 1
    310  2c48				  -			;lda #0
    311  2c48				  -	      stx	N + 2
    312  2c48				  -	      stx	N + 3
    313  2c48				  -			;jmp Mult32
    314  2c48				  -
    315  2c48				  -.Mult32		; 32=32*32
    316  2c48				  -	      lda	#0
    317  2c48				  -	      sta	P
    318  2c48				  -	      sta	P+1
    319  2c48				  -	      sta	P+2
    320  2c48				  -	      sta	P+3
    321  2c48				  -	      ldy	#$20
    322  2c48				  -.loop
    323  2c48				  -	      asl	P
    324  2c48				  -	      rol	P+1
    325  2c48				  -	      rol	P+2
    326  2c48				  -	      rol	P+3
    327  2c48				  -	      asl	N
    328  2c48				  -	      rol	N+1
    329  2c48				  -	      rol	N+2
    330  2c48				  -	      rol	N+3
    331  2c48				  -	      bcc	.skip
    332  2c48				  -	      clc
    333  2c48				  -	      ldx	#$fc
    334  2c48				  -.add
    335  2c48				  -	      lda.zx	P-252
    336  2c48				  -	      adc.zx	M-252
    337  2c48				  -	      sta.zx	P-252
    338  2c48				  -	      inx
    339  2c48				  -	      bne	.add
    340  2c48				  -.skip
    341  2c48				  -	      dey
    342  2c48				  -	      bne	.loop
    343  2c48				  -	      rts
    344  2c48					      ENDIF
    345  2c48
    346  2c48							; DECLARE FUNCTION POW AS FLOAT (base AS FLOAT, exp AS FLOAT) SHARED STATIC INLINE
    347  2c48					      MAC	f_pow_float_float
    348  2c48					      plfloattofac
    349  2c48					      plfloattoarg
    350  2c48					      import	I_FPLIB
    351  2c48					      jsr	FPWRT
    352  2c48					      pfac
    353  2c48					      ENDM		; @pull @push
    354  2c48
    355  2c48							; DECLARE FUNCTION EXP AS FLOAT (num AS FLOAT) SHARED STATIC INLINE
    356  2c48					      MAC	f_exp_float
    357  2c48					      plfloattofac
    358  2c48					      import	I_FPLIB
    359  2c48					      jsr	EXP
    360  2c48					      pfac
    361  2c48					      ENDM		; @pull @push
    362  2c48
    363  2c48							; DECLARE FUNCTION LOG AS FLOAT (num AS FLOAT) SHARED STATIC INLINE
    364  2c48					      MAC	f_log_float
    365  2c48					      plfloattofac
    366  2c48					      import	I_FPLIB
    367  2c48					      jsr	LOG
    368  2c48					      pfac
    369  2c48					      ENDM		; @pull @push
    370  2c48
    371  2c48							; DECLARE FUNCTION FLOOR AS FLOAT (num AS FLOAT) SHARED STATIC INLINE
    372  2c48					      MAC	f_floor_float
    373  2c48					      plfloattofac
    374  2c48					      import	I_FPLIB
    375  2c48					      jsr	INT
    376  2c48					      pfac
    377  2c48					      ENDM		; @pull @push
    378  2c48
    379  2c48							; DECLARE FUNCTION SQR AS FLOAT (num AS FLOAT) SHARED STATIC INLINE
    380  2c48					      MAC	f_sqr_float
    381  2c48					      plfloattofac
    382  2c48					      import	I_FPLIB
    383  2c48					      jsr	SQR
    384  2c48					      pfac
    385  2c48					      ENDM		; @pull @push
    386  2c48
    387  2c48							; DECLARE FUNCTION SQR AS BYTE (num AS WORD) SHARED STATIC INLINE
    388  2c48					      MAC	f_sqr_word
    389  2c48					      IF	!FPULL
    390  2c48					      pla
    391  2c48					      sta	R0 + 1
    392  2c48					      pla
    393  2c48					      sta	R0
    394  2c48					      ELSE
    395  2c48					      sta	R0
    396  2c48					      sty	R0 + 1
    397  2c48					      ENDIF
    398  2c48					      import	I_SQRW
    399  2c48					      jsr	SQRW
    400  2c48					      IF	!FPUSH
    401  2c48					      pha
    402  2c48					      ENDIF
    403  2c48					      ENDM		; @pull @push
    404  2c48
    405  2c48							; DECLARE FUNCTION SQR AS BYTE (num AS INT) SHARED STATIC INLINE
    406  2c48					      MAC	f_sqr_int
    407  2c48					      IF	!FPULL
    408  2c48					      pla
    409  2c48					      sta	R0 + 1
    410  2c48					      pla
    411  2c48					      sta	R0
    412  2c48					      ELSE
    413  2c48					      sta	R0
    414  2c48					      sty	R0 + 1
    415  2c48					      ENDIF
    416  2c48					      lda	R0 + 1
    417  2c48					      bpl	.ok
    418  2c48					      import	I_RUNTIME_ERROR
    419  2c48					      lda	#ERR_ILQTY
    420  2c48					      jmp	RUNTIME_ERROR
    421  2c48				   .ok
    422  2c48					      import	I_SQRW
    423  2c48					      jsr	SQRW
    424  2c48					      IF	!FPUSH
    425  2c48					      pha
    426  2c48					      ENDIF
    427  2c48					      ENDM		; @pull @push
    428  2c48
    429  2c48							; Square root of a word in R0-R1
    430  2c48							; Returns value in A
    431  2c48							; Remainder in X
    432  2c48							; https://codebase64.org/doku.php?id=base:16bit_and_24bit_sqrt
    433  2c48				  -	      IFCONST	I_SQRW_IMPORTED
    434  2c48				  -SQRW       SUBROUTINE
    435  2c48				  -	      ldy	#$01
    436  2c48				  -	      sty	R2
    437  2c48				  -	      dey
    438  2c48				  -	      sty	R3
    439  2c48				  -.do
    440  2c48				  -	      sec
    441  2c48				  -	      lda	R0
    442  2c48				  -	      tax
    443  2c48				  -	      sbc	R2
    444  2c48				  -	      sta	R0
    445  2c48				  -	      lda	R1
    446  2c48				  -	      sbc	R3
    447  2c48				  -	      sta	R1
    448  2c48				  -	      bcc	.nomore
    449  2c48				  -	      iny
    450  2c48				  -	      lda	R2
    451  2c48				  -	      adc	#$01
    452  2c48				  -	      sta	R2
    453  2c48				  -	      bcc	.do
    454  2c48				  -	      inc	R3
    455  2c48				  -	      bcs	.do
    456  2c48				  -.nomore
    457  2c48				  -	      tya
    458  2c48				  -	      rts
    459  2c48					      ENDIF
    460  2c48
    461  2c48							; DECLARE FUNCTION SQR AS WORD (num AS LONG) OVERRIDE SHARED STATIC INLINE
    462  2c48					      MAC	f_sqr_long
    463  2c48					      pllongvar	R0
    464  2c48					      lda	R0 + 2
    465  2c48					      bpl	.pos
    466  2c48					      import	I_RUNTIME_ERROR
    467  2c48					      lda	#ERR_ILQTY
    468  2c48					      jmp	RUNTIME_ERROR
    469  2c48				   .pos
    470  2c48					      import	I_SQRL
    471  2c48					      jsr	SQRL
    472  2c48					      pwordvar	R8
    473  2c48					      ENDM		; @pull @push
    474  2c48
    475  2c48							; Square Root of a 24bit number
    476  2c48							; by Verz - Jul2019
    477  2c48							; Input in R0
    478  2c48							; Result in AY
    479  2c48				  -	      IFCONST	I_SQRL_IMPORTED
    480  2c48				  -SQRL       SUBROUTINE
    481  2c48				  -	      ldy	#1
    482  2c48				  -	      sty	R4
    483  2c48				  -	      dey
    484  2c48				  -	      sty	R4 + 1
    485  2c48				  -	      sty	R4 + 2
    486  2c48				  -	      sty	R8
    487  2c48				  -	      sty	R8 + 1
    488  2c48				  -.do
    489  2c48				  -	      sec
    490  2c48				  -	      lda	R0
    491  2c48				  -	      sta	RA
    492  2c48				  -	      sbc	R4
    493  2c48				  -	      sta	R0
    494  2c48				  -	      lda	R0 + 1
    495  2c48				  -	      sta	RA + 1
    496  2c48				  -	      sbc	R4 + 1
    497  2c48				  -	      sta	R0 + 1
    498  2c48				  -	      lda	R0 + 2
    499  2c48				  -	      sbc	R4 + 2
    500  2c48				  -	      sta	R0 + 2
    501  2c48				  -	      bcc	.nomore
    502  2c48				  -	      inc	R8
    503  2c48				  -	      bne	.1
    504  2c48				  -	      inc	R8 + 1
    505  2c48				  -.1
    506  2c48				  -	      lda	R4
    507  2c48				  -	      adc	#1
    508  2c48				  -	      sta	R4
    509  2c48				  -	      bcc	.do
    510  2c48				  -	      lda	R4 + 1
    511  2c48				  -	      adc	#0
    512  2c48				  -	      sta	R4 + 1
    513  2c48				  -	      bcc	.do
    514  2c48				  -	      inc	R4 + 2
    515  2c48				  -	      bcs	.do
    516  2c48				  -.nomore
    517  2c48				  -	      lda	R8
    518  2c48				  -	      ldy	R8 + 1
    519  2c48				  -	      rts
    520  2c48					      ENDIF
    521  2c48
    522  2c48
    523  2c48					      IFCONST	I_RANDOMIZE_IMPORTED || I_RND_IMPORTED || I_RNDL_IMPORTED
    524  2c48		       80	   MATH_RND_EXP HEX	80
    525  2c49		       00 00 00    MATH_RND   HEX	00 00 00
    526  2c4c					      ENDIF
    527  2c4c
    528  2c4c							; DECLARE FUNCTION RND AS FLOAT () SHARED STATIC INLINE
    529  2c4c					      MAC	f_rnd
    530  2c4c					      import	I_RND
    531  2c4c					      jsr	I_RND
    532  2c4c					      pfloatvar	MATH_RND_EXP
    533  2c4c					      ENDM		; @push
    534  2c4c
    535  2c4c							; DECLARE FUNCTION RNDL AS LONG () SHARED STATIC INLINE
    536  2c4c					      MAC	f_rndl
    537  2c4c					      import	I_RNDL
    538  2c4c					      REPEAT	3
    539  2c4c					      jsr	I_RNDL
    540  2c4c					      lda	MATH_RND
    541  2c4c					      pha
    542  2c4c					      REPEND
    543  2c4c					      ENDM
    544  2c4c
    545  2c4c							; DECLARE FUNCTION RNDI AS INT () SHARED STATIC INLINE
    546  2c4c					      MAC	f_rndi
    547  2c4c					      import	I_RNDL
    548  2c4c					      REPEAT	2
    549  2c4c					      jsr	I_RNDL
    550  2c4c					      lda	MATH_RND
    551  2c4c					      pha
    552  2c4c					      REPEND
    553  2c4c					      ENDM
    554  2c4c
    555  2c4c							; DECLARE FUNCTION RNDW AS INT () SHARED STATIC INLINE
    556  2c4c					      MAC	f_rndw
    557  2c4c					      F_rndi
    558  2c4c					      ENDM
    559  2c4c
    560  2c4c							; DECLARE FUNCTION RNDB AS BYTE () SHARED STATIC INLINE
    561  2c4c					      MAC	f_rndb
    562  2c4c					      import	I_RNDL
    563  2c4c					      jsr	I_RNDL
    564  2c4c					      lda	MATH_RND
    565  2c4c					      IF	!FPUSH
    566  2c4c					      pha
    567  2c4c					      ENDIF
    568  2c4c					      ENDM		; @ push
    569  2c4c
    570  2c4c							; 6502 LFSR PRNG - 24-bit
    571  2c4c							; Brad Smith, 2019
    572  2c4c							; http://rainwarrior.ca
    573  2c4c					      IFCONST	I_RNDL_IMPORTED
    574  2c4c				   I_RNDL     SUBROUTINE
    575  2c4c							; rotate the middle byte left
    576  2c4c		       ac 4a 2c 	      ldy	MATH_RND + 1	; will move to seed + 2 at the end
    577  2c4f							; compute seed + 1 ($1B>>1 = %1101)
    578  2c4f		       ad 4b 2c 	      lda	MATH_RND + 2
    579  2c52		       4a		      lsr
    580  2c53		       4a		      lsr
    581  2c54		       4a		      lsr
    582  2c55		       4a		      lsr
    583  2c56		       8d 4a 2c 	      sta	MATH_RND + 1	; reverse: %1011
    584  2c59		       4a		      lsr
    585  2c5a		       4a		      lsr
    586  2c5b		       4d 4a 2c 	      eor	MATH_RND + 1
    587  2c5e		       4a		      lsr
    588  2c5f		       4d 4a 2c 	      eor	MATH_RND + 1
    589  2c62		       4d 49 2c 	      eor	MATH_RND + 0
    590  2c65		       8d 4a 2c 	      sta	MATH_RND + 1
    591  2c68							; compute seed+0 ($1B = %00011011)
    592  2c68		       ad 4b 2c 	      lda	MATH_RND + 2
    593  2c6b		       0a		      asl
    594  2c6c		       4d 4b 2c 	      eor	MATH_RND + 2
    595  2c6f		       0a		      asl
    596  2c70		       0a		      asl
    597  2c71		       4d 4b 2c 	      eor	MATH_RND + 2
    598  2c74		       0a		      asl
    599  2c75		       4d 4b 2c 	      eor	MATH_RND + 2
    600  2c78		       8c 4b 2c 	      sty	MATH_RND + 2	; finish rotating byte 1 into 2
    601  2c7b		       8d 49 2c 	      sta	MATH_RND
    602  2c7e		       60		      rts
    603  2c7f					      ENDIF
    604  2c7f
    605  2c7f					      IFCONST	I_RND_IMPORTED
    606  2c7f				   I_RND      SUBROUTINE
      0  2c7f					      import	I_FPLIB
      1  2c7f				   I_FPLIB_IMPORTED SET	1
    608  2c7f		       a9 48		      lda	#<MATH_RND_EXP
    609  2c81		       a0 2c		      ldy	#>MATH_RND_EXP
    610  2c83		       20 bd 2f 	      jsr	LOAD_FAC_FROM_YA
    611  2c86		       a9 b3		      lda	#<.C1
    612  2c88		       a0 2c		      ldy	#>.C1
    613  2c8a		       20 6a 2e 	      jsr	FMULT
    614  2c8d		       a9 b7		      lda	#<.C2
    615  2c8f		       a0 2c		      ldy	#>.C2
    616  2c91		       20 d9 2c 	      jsr	FADD
    617  2c94		       a5 29		      lda	FAC + 1
    618  2c96		       a6 2b		      ldx	FAC + 3
    619  2c98		       85 2b		      sta	FAC + 3
    620  2c9a		       86 29		      stx	FAC + 1
    621  2c9c		       a9 00		      lda	#0
    622  2c9e		       85 2c		      sta	FACSIGN
    623  2ca0		       a5 28		      lda	FAC
    624  2ca2		       85 35		      sta	FACEXTENSION
    625  2ca4		       a9 80		      lda	#$80
    626  2ca6		       85 28		      sta	FAC
    627  2ca8		       38		      sec
    628  2ca9		       20 3d 2d 	      jsr	NORMALIZE_FAC1
    629  2cac		       a2 48		      ldx	#<MATH_RND_EXP
    630  2cae		       a0 2c		      ldy	#>MATH_RND_EXP
    631  2cb0		       4c e6 2f 	      jmp	STORE_FAC_AT_YX_ROUNDED
    632  2cb3
    633  2cb3		       98 35 44 7a .C1	      HEX	98 35 44 7A
    634  2cb7		       68 28 b1 46 .C2	      HEX	68 28 B1 46
    635  2cbb					      ENDIF
    636  2cbb
    637  2cbb					      MAC	f_shl_byte_byte
    638  2cbb					      lshiftbyte
    639  2cbb					      ENDM		; @pull @push
    640  2cbb
    641  2cbb					      MAC	f_shr_byte_byte
    642  2cbb					      rshiftbyte
    643  2cbb					      ENDM		; @pull @push
    644  2cbb
    645  2cbb					      MAC	f_shl_int_byte
    646  2cbb					      lshiftint
    647  2cbb					      ENDM		; @pull
    648  2cbb
    649  2cbb					      MAC	f_shr_int_byte
    650  2cbb					      rshiftint
    651  2cbb					      ENDM		; @pull
    652  2cbb
    653  2cbb					      MAC	f_shl_word_byte
    654  2cbb					      lshiftword
    655  2cbb					      ENDM		; @pull
    656  2cbb
    657  2cbb					      MAC	f_shr_word_byte
    658  2cbb					      rshiftword
    659  2cbb					      ENDM		; @pull
    660  2cbb
    661  2cbb					      MAC	f_shl_long_byte
    662  2cbb					      lshiftlong
    663  2cbb					      ENDM		; @pull
    664  2cbb
    665  2cbb					      MAC	f_shr_long_byte
    666  2cbb					      rshiftlong
    667  2cbb					      ENDM		; @pull
    668  2cbb
------- FILE math/math.asm
------- FILE math/_fplib.asm LEVEL 4 PASS 4
      0  2cbb					      INCLUDE	"math/_fplib.asm"
      1  2cbb							; ======================================================
      2  2cbb							; MS BASIC FLOATING POINT ROUTINES
      3  2cbb							; https://github.com/mist64/msbasic
      4  2cbb							; License: 2-clause BSD
      5  2cbb							; ======================================================
      6  2cbb
      7  2cbb		       00 01	   CONFIG_CBM_ALL EQU	1
      8  2cbb		       00 00	   CONFIG_2B  EQU	0
      9  2cbb		       00 01	   CONFIG_2A  EQU	1
     10  2cbb		       00 00	   CONFIG_2   EQU	0
     11  2cbb		       00 00	   CONFIG_11  EQU	0
     12  2cbb		       00 00	   CONFIG_10A EQU	0
     13  2cbb		       00 01	   CONFIG_SMALL EQU	1
     14  2cbb		       00 00	   CONFIG_ROR_WORKAROUND EQU	0
     15  2cbb		       00 04	   BYTES_FP   EQU	4
     16  2cbb		       00 03	   MANTISSA_BYTES EQU	3
     17  2cbb		       00 00	   AIM65      EQU	0
     18  2cbb		       00 00	   KBD	      EQU	0
     19  2cbb		       00 0a	   MAX_EXPON  EQU	10
     20  2cbb		       00 00	   APPLE_BAD_BYTE EQU	0
     21  2cbb
     22 U003c ????				      SEG.U	ZP
     23 U0016					      ORG	$16
     24 U0016				   CHARAC
     25 U0016		       00		      DS.B	1
     26 U0017				   INDEX
     27 U0017		       00 00		      DS.B	2
     28 U0019				   DEST
     29 U0019				   RESULT
     30 U0019		       00 00 00 00	      DS.B	BYTES_FP
     31 U001d		       00 00		      DS.B	2
     32 U001f				   ARGEXTENSION
     33 U001f				  -	      IF	CONFIG_SMALL == 0
     34 U001f				  -	      DS.B	1
     35 U001f					      ENDIF
     36 U001f				   TEMP1
     37 U001f		       00		      DS.B	1
     38 U0020				   HIGHDS
     39 U0020		       00 00		      DS.B	2
     40 U0022				   HIGHTR
     41 U0022		       00 00		      DS.B	2
     42 U0024				  -	      IF	CONFIG_SMALL == 0
     43 U0024				  -TEMP2
     44 U0024				  -	      DS.B	1
     45 U0024					      ENDIF
     46 U0024				   INDX
     47 U0024				   TMPEXP
     48 U0024					      IF	CONFIG_SMALL
     49 U0024				   TEMP2
     50 U0024					      ENDIF
     51 U0024		       00		      DS.B	1
     52 U0025				   EXPON
     53 U0025		       00		      DS.B	1
     54 U0026				   LOWTR
     55 U0026				  -	      IFNCONST	LOWTRX	; allow override
     56 U0026				  -LOWTRX
     57 U0026					      ENDIF
     58 U0026		       00		      DS.B	1
     59 U0027				   EXPSGN
     60 U0027		       00		      DS.B	1
     61 U0028				   FAC
     62 U0028		       00 00 00 00	      DS.B	4
     63 U002c				   FACSIGN
     64 U002c		       00		      DS.B	1
     65 U002d				   SERLEN
     66 U002d		       00		      DS.B	1
     67 U002e				   SHIFTSIGNEXT
     68 U002e		       00		      DS.B	1
     69 U002f				   ARG
     70 U002f		       00 00 00 00	      DS.B	BYTES_FP
     71 U0033				   ARGSIGN
     72 U0033		       00		      DS.B	1
     73 U0034				   STRNG1
     74 U0034		       00 00		      DS.B	2
     75 U0036				   STRNG2
     76 U0036		       00 00		      DS.B	2
     77 U0038				  -	      IF	AIM65
     78 U0038				  -ATN
     79 U0038				  -	      DS.B	3
     80 U0038				  -ZBE
     81 U0038				  -	      DS.B	1
     82 U0038					      ENDIF
     83 U0038				   VARPNT
     84 U0038		       00 00		      DS.B	2
     85 U003a				   TEMP3
     86 U003a		       00 00		      DS.B	2
     87 U003c
     88 U003c		       00 20	   TEMP1X     =	TEMP1+(5-BYTES_FP)
     89 U003c		       00 2b	   FAC_LAST   =	FAC + BYTES_FP-1
     90 U003c		       00 32	   ARG_LAST   =	ARG + BYTES_FP-1
     91 U003c		       00 34	   SGNCPR     =	STRNG1
     92 U003c		       00 35	   FACEXTENSION =	STRNG1+1
     93 U003c		       00 1c	   RESULT_LAST =	RESULT + BYTES_FP-1
     94 U003c
     95  2cbb					      SEG	"LIBRARY"
     96  2cbb					      IFCONST	I_FPLIB_IMPORTED
     97  2cbb							; ----------------------------------------------------------------------------
     98  2cbb							; ADD 0.5 TO FAC
     99  2cbb							; ----------------------------------------------------------------------------
    100  2cbb				   FADDH
    101  2cbb		       a9 09		      lda	#<CON_HALF
    102  2cbd		       a0 31		      ldy	#>CON_HALF
    103  2cbf		       4c d9 2c 	      jmp	FADD
    104  2cc2
    105  2cc2							; ----------------------------------------------------------------------------
    106  2cc2							; FAC = (Y,A) - FAC
    107  2cc2							; ----------------------------------------------------------------------------
    108  2cc2				   FSUB
    109  2cc2		       20 bf 2e 	      jsr	LOAD_ARG_FROM_YA
    110  2cc5
    111  2cc5							; ----------------------------------------------------------------------------
    112  2cc5							; FAC = ARG - FAC
    113  2cc5							; ----------------------------------------------------------------------------
    114  2cc5				   FSUBT
    115  2cc5		       a5 2c		      lda	FACSIGN
    116  2cc7		       49 ff		      eor	#$FF
    117  2cc9		       85 2c		      sta	FACSIGN
    118  2ccb		       45 33		      eor	ARGSIGN
    119  2ccd		       85 34		      sta	SGNCPR
    120  2ccf		       a5 28		      lda	FAC
    121  2cd1		       4c dc 2c 	      jmp	FADDT
    122  2cd4
    123  2cd4							; ----------------------------------------------------------------------------
    124  2cd4							; SHIFT SMALLER ARGUMENT MORE THAN 7 BITS
    125  2cd4							; ----------------------------------------------------------------------------
    126  2cd4				   FADD1
    127  2cd4		       20 e8 2d 	      jsr	SHIFT_RIGHT
    128  2cd7		       90 3c		      bcc	FADD3
    129  2cd9
    130  2cd9							; ----------------------------------------------------------------------------
    131  2cd9							; FAC = (Y,A) + FAC
    132  2cd9							; ----------------------------------------------------------------------------
    133  2cd9				   FADD
    134  2cd9		       20 bf 2e 	      jsr	LOAD_ARG_FROM_YA
    135  2cdc
    136  2cdc							; ----------------------------------------------------------------------------
    137  2cdc							; FAC = ARG + FAC
    138  2cdc							; ----------------------------------------------------------------------------
    139  2cdc				   FADDT
    140  2cdc		       d0 03		      bne	L365B
    141  2cde		       4c 09 30 	      jmp	COPY_ARG_TO_FAC
    142  2ce1				   L365B
    143  2ce1		       a6 35		      ldx	FACEXTENSION
    144  2ce3		       86 1f		      stx	ARGEXTENSION
    145  2ce5		       a2 2f		      ldx	#ARG
    146  2ce7		       a5 2f		      lda	ARG
    147  2ce9				   FADD2
    148  2ce9		       a8		      tay
    149  2cea		       f0 78		      beq	RTS3
    150  2cec		       38		      sec
    151  2ced		       e5 28		      sbc	FAC
    152  2cef		       f0 24		      beq	FADD3
    153  2cf1		       90 12		      bcc	L367F
    154  2cf3		       84 28		      sty	FAC
    155  2cf5		       a4 33		      ldy	ARGSIGN
    156  2cf7		       84 2c		      sty	FACSIGN
    157  2cf9		       49 ff		      eor	#$FF
    158  2cfb		       69 00		      adc	#$00
    159  2cfd		       a0 00		      ldy	#$00
    160  2cff		       84 1f		      sty	ARGEXTENSION
    161  2d01		       a2 28		      ldx	#FAC
    162  2d03		       d0 04		      bne	L3683
    163  2d05				   L367F
    164  2d05		       a0 00		      ldy	#$00
    165  2d07		       84 35		      sty	FACEXTENSION
    166  2d09				   L3683
    167  2d09		       c9 f9		      cmp	#$F9
    168  2d0b		       30 c7		      bmi	FADD1
    169  2d0d		       a8		      tay
    170  2d0e		       a5 35		      lda	FACEXTENSION
    171  2d10		       56 01		      lsr	1,x
    172  2d12		       20 ff 2d 	      jsr	SHIFT_RIGHT4
    173  2d15				   FADD3
    174  2d15		       24 34		      bit	SGNCPR
    175  2d17		       10 4c		      bpl	FADD4
    176  2d19		       a0 28		      ldy	#FAC
    177  2d1b		       e0 2f		      cpx	#ARG
    178  2d1d		       f0 02		      beq	L369B
    179  2d1f		       a0 2f		      ldy	#ARG
    180  2d21				   L369B
    181  2d21		       38		      sec
    182  2d22		       49 ff		      eor	#$FF
    183  2d24		       65 1f		      adc	ARGEXTENSION
    184  2d26		       85 35		      sta	FACEXTENSION
    185  2d28				  -	      IF	CONFIG_SMALL == 0
    186  2d28				  -	      lda	4,y
    187  2d28				  -	      sbc	4,x
    188  2d28				  -	      sta	FAC+4
    189  2d28					      ENDIF
    190  2d28		       b9 03 00 	      lda	3,y
    191  2d2b		       f5 03		      sbc	3,x
    192  2d2d		       85 2b		      sta	FAC+3
    193  2d2f		       b9 02 00 	      lda	2,y
    194  2d32		       f5 02		      sbc	2,x
    195  2d34		       85 2a		      sta	FAC+2
    196  2d36		       b9 01 00 	      lda	1,y
    197  2d39		       f5 01		      sbc	1,x
    198  2d3b		       85 29		      sta	FAC+1
    199  2d3d
    200  2d3d							; ----------------------------------------------------------------------------
    201  2d3d							; NORMALIZE VALUE IN FAC
    202  2d3d							; ----------------------------------------------------------------------------
    203  2d3d				   NORMALIZE_FAC1
    204  2d3d		       b0 03		      bcs	NORMALIZE_FAC2
    205  2d3f		       20 a4 2d 	      jsr	COMPLEMENT_FAC
    206  2d42				   NORMALIZE_FAC2
    207  2d42		       a0 00		      ldy	#$00
    208  2d44		       98		      tya
    209  2d45		       18		      clc
    210  2d46				   L36C7
    211  2d46		       a6 29		      ldx	FAC+1
    212  2d48		       d0 3e		      bne	NORMALIZE_FAC4
    213  2d4a		       a6 2a		      ldx	FAC+2
    214  2d4c		       86 29		      stx	FAC+1
    215  2d4e		       a6 2b		      ldx	FAC+3
    216  2d50		       86 2a		      stx	FAC+2
    217  2d52					      IF	CONFIG_SMALL
    218  2d52		       a6 35		      ldx	FACEXTENSION
    219  2d54		       86 2b		      stx	FAC+3
    220  2d56				  -	      ELSE
    221  2d56				  -	      ldx	FAC+4
    222  2d56				  -	      stx	FAC+3
    223  2d56				  -	      ldx	FACEXTENSION
    224  2d56				  -	      stx	FAC+4
    225  2d56					      ENDIF
    226  2d56		       84 35		      sty	FACEXTENSION
    227  2d58		       69 08		      adc	#$08
    228  2d5a				  -	      IF	CONFIG_2B
    229  2d5a				  -			; bugfix?
    230  2d5a				  -			; fix does not exist on AppleSoft 2
    231  2d5a				  -	      cmp	#(MANTISSA_BYTES+1)*8
    232  2d5a					      ELSE
    233  2d5a		       c9 18		      cmp	#MANTISSA_BYTES*8
    234  2d5c					      ENDIF
    235  2d5c		       d0 e8		      bne	L36C7
    236  2d5e
    237  2d5e							; ----------------------------------------------------------------------------
    238  2d5e							; SET FAC = 0
    239  2d5e							; (ONLY NECESSARY TO ZERO EXPONENT AND SIGN CELLS)
    240  2d5e							; ----------------------------------------------------------------------------
    241  2d5e				   ZERO_FAC
    242  2d5e		       a9 00		      lda	#$00
    243  2d60				   STA_IN_FAC_SIGN_AND_EXP
    244  2d60		       85 28		      sta	FAC
    245  2d62				   STA_IN_FAC_SIGN
    246  2d62		       85 2c		      sta	FACSIGN
    247  2d64				   RTS3
    248  2d64		       60		      rts
    249  2d65
    250  2d65							; ----------------------------------------------------------------------------
    251  2d65							; ADD MANTISSAS OF FAC AND ARG INTO FAC
    252  2d65							; ----------------------------------------------------------------------------
    253  2d65				   FADD4
    254  2d65		       65 1f		      adc	ARGEXTENSION
    255  2d67		       85 35		      sta	FACEXTENSION
    256  2d69				  -	      IF	CONFIG_SMALL == 0
    257  2d69				  -	      lda	FAC+4
    258  2d69				  -	      adc	ARG+4
    259  2d69				  -	      sta	FAC+4
    260  2d69					      ENDIF
    261  2d69		       a5 2b		      lda	FAC+3
    262  2d6b		       65 32		      adc	ARG+3
    263  2d6d		       85 2b		      sta	FAC+3
    264  2d6f		       a5 2a		      lda	FAC+2
    265  2d71		       65 31		      adc	ARG+2
    266  2d73		       85 2a		      sta	FAC+2
    267  2d75		       a5 29		      lda	FAC+1
    268  2d77		       65 30		      adc	ARG+1
    269  2d79		       85 29		      sta	FAC+1
    270  2d7b		       4c 95 2d 	      jmp	NORMALIZE_FAC5
    271  2d7e
    272  2d7e							; ----------------------------------------------------------------------------
    273  2d7e							; FINISH NORMALIZING FAC
    274  2d7e							; ----------------------------------------------------------------------------
    275  2d7e				   NORMALIZE_FAC3
    276  2d7e		       69 01		      adc	#$01
    277  2d80		       06 35		      asl	FACEXTENSION
    278  2d82				  -	      IF	CONFIG_SMALL == 0
    279  2d82				  -	      rol	FAC+4
    280  2d82					      ENDIF
    281  2d82		       26 2b		      rol	FAC+3
    282  2d84		       26 2a		      rol	FAC+2
    283  2d86		       26 29		      rol	FAC+1
    284  2d88				   NORMALIZE_FAC4
    285  2d88		       10 f4		      bpl	NORMALIZE_FAC3
    286  2d8a		       38		      sec
    287  2d8b		       e5 28		      sbc	FAC
    288  2d8d		       b0 cf		      bcs	ZERO_FAC
    289  2d8f		       49 ff		      eor	#$FF
    290  2d91		       69 01		      adc	#$01
    291  2d93		       85 28		      sta	FAC
    292  2d95				   NORMALIZE_FAC5
    293  2d95		       90 0c		      bcc	L3764
    294  2d97				   NORMALIZE_FAC6
    295  2d97		       e6 28		      inc	FAC
    296  2d99		       f0 36		      beq	OVERFLOW
    297  2d9b					      IF	CONFIG_ROR_WORKAROUND == 0
    298  2d9b		       66 29		      ror	FAC+1
    299  2d9d		       66 2a		      ror	FAC+2
    300  2d9f		       66 2b		      ror	FAC+3
    301  2da1				  -	      IF	CONFIG_SMALL == 0
    302  2da1				  -	      ror	FAC+4
    303  2da1					      ENDIF
    304  2da1		       66 35		      ror	FACEXTENSION
    305  2da3				  -	      ELSE
    306  2da3				  -	      lda	#$00
    307  2da3				  -	      bcc	L372E
    308  2da3				  -	      lda	#$80
    309  2da3				  -L372E
    310  2da3				  -	      lsr	FAC+1
    311  2da3				  -	      ora	FAC+1
    312  2da3				  -	      sta	FAC+1
    313  2da3				  -	      lda	#$00
    314  2da3				  -	      bcc	L373A
    315  2da3				  -	      lda	#$80
    316  2da3				  -L373A
    317  2da3				  -	      lsr	FAC+2
    318  2da3				  -	      ora	FAC+2
    319  2da3				  -	      sta	FAC+2
    320  2da3				  -	      lda	#$00
    321  2da3				  -	      bcc	L3746
    322  2da3				  -	      lda	#$80
    323  2da3				  -L3746
    324  2da3				  -	      lsr	FAC+3
    325  2da3				  -	      ora	FAC+3
    326  2da3				  -	      sta	FAC+3
    327  2da3				  -	      lda	#$00
    328  2da3				  -	      bcc	L3752
    329  2da3				  -	      lda	#$80
    330  2da3				  -L3752
    331  2da3				  -	      lsr	FAC+4
    332  2da3				  -	      ora	FAC+4
    333  2da3				  -	      sta	FAC+4
    334  2da3				  -	      lda	#$00
    335  2da3				  -	      bcc	L375E
    336  2da3				  -	      lda	#$80
    337  2da3				  -L375E
    338  2da3				  -	      lsr	FACEXTENSION
    339  2da3				  -	      ora	FACEXTENSION
    340  2da3				  -	      sta	FACEXTENSION
    341  2da3					      ENDIF
    342  2da3				   L3764
    343  2da3		       60		      rts
    344  2da4
    345  2da4							; ----------------------------------------------------------------------------
    346  2da4							; 2'S COMPLEMENT OF FAC
    347  2da4							; ----------------------------------------------------------------------------
    348  2da4				   COMPLEMENT_FAC
    349  2da4		       a5 2c		      lda	FACSIGN
    350  2da6		       49 ff		      eor	#$FF
    351  2da8		       85 2c		      sta	FACSIGN
    352  2daa
    353  2daa							; ----------------------------------------------------------------------------
    354  2daa							; 2'S COMPLEMENT OF FAC MANTISSA ONLY
    355  2daa							; ----------------------------------------------------------------------------
    356  2daa				   COMPLEMENT_FAC_MANTISSA
    357  2daa		       a5 29		      lda	FAC+1
    358  2dac		       49 ff		      eor	#$FF
    359  2dae		       85 29		      sta	FAC+1
    360  2db0		       a5 2a		      lda	FAC+2
    361  2db2		       49 ff		      eor	#$FF
    362  2db4		       85 2a		      sta	FAC+2
    363  2db6		       a5 2b		      lda	FAC+3
    364  2db8		       49 ff		      eor	#$FF
    365  2dba		       85 2b		      sta	FAC+3
    366  2dbc				  -	      IF	CONFIG_SMALL == 0
    367  2dbc				  -	      lda	FAC+4
    368  2dbc				  -	      eor	#$FF
    369  2dbc				  -	      sta	FAC+4
    370  2dbc					      ENDIF
    371  2dbc		       a5 35		      lda	FACEXTENSION
    372  2dbe		       49 ff		      eor	#$FF
    373  2dc0		       85 35		      sta	FACEXTENSION
    374  2dc2		       e6 35		      inc	FACEXTENSION
    375  2dc4		       d0 0a		      bne	RTS12
    376  2dc6
    377  2dc6							; ----------------------------------------------------------------------------
    378  2dc6							; INCREMENT FAC MANTISSA
    379  2dc6							; ----------------------------------------------------------------------------
    380  2dc6				   INCREMENT_FAC_MANTISSA
    381  2dc6				  -	      IF	CONFIG_SMALL == 0
    382  2dc6				  -	      inc	FAC+4
    383  2dc6				  -	      bne	RTS12
    384  2dc6					      ENDIF
    385  2dc6		       e6 2b		      inc	FAC+3
    386  2dc8		       d0 06		      bne	RTS12
    387  2dca		       e6 2a		      inc	FAC+2
    388  2dcc		       d0 02		      bne	RTS12
    389  2dce		       e6 29		      inc	FAC+1
    390  2dd0				   RTS12
    391  2dd0		       60		      rts
    392  2dd1				   OVERFLOW
      0  2dd1					      import	I_RUNTIME_ERROR
      1  2dd1				   I_RUNTIME_ERROR_IMPORTED SET	1
    394  2dd1		       a9 0f		      lda	#ERR_OVERFLOW
    395  2dd3		       4c 2a 33 	      jmp	RUNTIME_ERROR
    396  2dd6
    397  2dd6							; ----------------------------------------------------------------------------
    398  2dd6							; SHIFT 1,X THRU 5,X RIGHT
    399  2dd6							; (A) = NEGATIVE OF SHIFT COUNT
    400  2dd6							; (X) = POINTER TO BYTES TO BE SHIFTED
    401  2dd6							;
    402  2dd6							; RETURN WITH (Y)=0, CARRY=0, EXTENSION BITS IN A-REG
    403  2dd6							; ----------------------------------------------------------------------------
    404  2dd6				   SHIFT_RIGHT1
    405  2dd6		       a2 18		      ldx	#RESULT-1
    406  2dd8				   SHIFT_RIGHT2
    407  2dd8					      IF	CONFIG_SMALL
    408  2dd8		       b4 03		      ldy	3,x
    409  2dda				  -	      ELSE
    410  2dda				  -	      ldy	4,x
    411  2dda					      ENDIF
    412  2dda		       84 35		      sty	FACEXTENSION
    413  2ddc				  -	      IF	CONFIG_SMALL == 0
    414  2ddc				  -	      ldy	3,x
    415  2ddc				  -	      sty	4,x
    416  2ddc					      ENDIF
    417  2ddc		       b4 02		      ldy	2,x
    418  2dde		       94 03		      sty	3,x
    419  2de0		       b4 01		      ldy	1,x
    420  2de2		       94 02		      sty	2,x
    421  2de4		       a4 2e		      ldy	SHIFTSIGNEXT
    422  2de6		       94 01		      sty	1,x
    423  2de8
    424  2de8							; ----------------------------------------------------------------------------
    425  2de8							; MAIN ENTRY TO RIGHT SHIFT SUBROUTINE
    426  2de8							; ----------------------------------------------------------------------------
    427  2de8				   SHIFT_RIGHT
    428  2de8		       69 08		      adc	#$08
    429  2dea		       30 ec		      bmi	SHIFT_RIGHT2
    430  2dec		       f0 ea		      beq	SHIFT_RIGHT2
    431  2dee		       e9 08		      sbc	#$08
    432  2df0		       a8		      tay
    433  2df1		       a5 35		      lda	FACEXTENSION
    434  2df3		       b0 12		      bcs	SHIFT_RIGHT5
    435  2df5					      IF	CONFIG_ROR_WORKAROUND == 0
    436  2df5				   LB588
    437  2df5		       16 01		      asl	1,x
    438  2df7		       90 02		      bcc	LB58E
    439  2df9		       f6 01		      inc	1,x
    440  2dfb				   LB58E
    441  2dfb		       76 01		      ror	1,x
    442  2dfd		       76 01		      ror	1,x
    443  2dff
    444  2dff							; ----------------------------------------------------------------------------
    445  2dff							; ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
    446  2dff							; ----------------------------------------------------------------------------
    447  2dff				   SHIFT_RIGHT4
    448  2dff		       76 02		      ror	2,x
    449  2e01		       76 03		      ror	3,x
    450  2e03				  -	      IF	CONFIG_SMALL == 0
    451  2e03				  -	      ror	4,x
    452  2e03					      ENDIF
    453  2e03		       6a		      ror
    454  2e04		       c8		      iny
    455  2e05		       d0 ee		      bne	LB588
    456  2e07				  -	      ELSE
    457  2e07				  -L37C4
    458  2e07				  -	      pha
    459  2e07				  -	      lda	1,x
    460  2e07				  -	      and	#$80
    461  2e07				  -	      lsr	1,x
    462  2e07				  -	      ora	1,x
    463  2e07				  -	      sta	1,x
    464  2e07				  -	      .byte	$24
    465  2e07				  -SHIFT_RIGHT4
    466  2e07				  -	      pha
    467  2e07				  -	      lda	#$00
    468  2e07				  -	      bcc	L37D7
    469  2e07				  -	      lda	#$80
    470  2e07				  -L37D7
    471  2e07				  -	      lsr	2,x
    472  2e07				  -	      ora	2,x
    473  2e07				  -	      sta	2,x
    474  2e07				  -	      lda	#$00
    475  2e07				  -	      bcc	L37E3
    476  2e07				  -	      lda	#$80
    477  2e07				  -L37E3
    478  2e07				  -	      lsr	3,x
    479  2e07				  -	      ora	3,x
    480  2e07				  -	      sta	3,x
    481  2e07				  -	      lda	#$00
    482  2e07				  -	      bcc	L37EF
    483  2e07				  -	      lda	#$80
    484  2e07				  -L37EF
    485  2e07				  -	      lsr	4,x
    486  2e07				  -	      ora	4,x
    487  2e07				  -	      sta	4,x
    488  2e07				  -	      pla
    489  2e07				  -	      php
    490  2e07				  -	      lsr
    491  2e07				  -	      plp
    492  2e07				  -	      bcc	L37FD
    493  2e07				  -	      ora	#$80
    494  2e07				  -L37FD
    495  2e07				  -	      iny
    496  2e07				  -	      bne	L37C4
    497  2e07					      ENDIF
    498  2e07				   SHIFT_RIGHT5
    499  2e07		       18		      clc
    500  2e08		       60		      rts
    501  2e09
    502  2e09							; ----------------------------------------------------------------------------
    503  2e09					      IF	CONFIG_SMALL
    504  2e09				   CON_ONE
    505  2e09		       81 00 00 00	      .byte.b	$81,$00,$00,$00
    506  2e0d				   POLY_LOG
    507  2e0d		       02		      .byte.b	$02
    508  2e0e		       80 19 56 62	      .byte.b	$80,$19,$56,$62
    509  2e12		       80 76 22 f3	      .byte.b	$80,$76,$22,$F3
    510  2e16		       82 38 aa 40	      .byte.b	$82,$38,$AA,$40
    511  2e1a				   CON_SQR_HALF
    512  2e1a		       80 35 04 f3	      .byte.b	$80,$35,$04,$F3
    513  2e1e				   CON_SQR_TWO
    514  2e1e		       81 35 04 f3	      .byte.b	$81,$35,$04,$F3
    515  2e22				   CON_NEG_HALF
    516  2e22		       80 80 00 00	      .byte.b	$80,$80,$00,$00
    517  2e26				   CON_LOG_TWO
    518  2e26		       80 31 72 18	      .byte.b	$80,$31,$72,$18
    519  2e2a				  -	      ELSE
    520  2e2a				  -CON_ONE
    521  2e2a				  -	      .byte	$81,$00,$00,$00,$00
    522  2e2a				  -POLY_LOG
    523  2e2a				  -	      .byte	$03
    524  2e2a				  -	      .byte	$7F,$5E,$56,$CB,$79
    525  2e2a				  -	      .byte	$80,$13,$9B,$0B,$64
    526  2e2a				  -	      .byte	$80,$76,$38,$93,$16
    527  2e2a				  -	      .byte	$82,$38,$AA,$3B,$20
    528  2e2a				  -CON_SQR_HALF
    529  2e2a				  -	      .byte	$80,$35,$04,$F3,$34
    530  2e2a				  -CON_SQR_TWO
    531  2e2a				  -	      .byte	$81,$35,$04,$F3,$34
    532  2e2a				  -CON_NEG_HALF
    533  2e2a				  -	      .byte	$80,$80,$00,$00,$00
    534  2e2a				  -CON_LOG_TWO
    535  2e2a				  -	      .byte	$80,$31,$72,$17,$F8
    536  2e2a					      ENDIF
    537  2e2a
    538  2e2a							; ----------------------------------------------------------------------------
    539  2e2a							; "LOG" FUNCTION
    540  2e2a							; ----------------------------------------------------------------------------
    541  2e2a				   LOG
    542  2e2a		       20 38 30 	      jsr	SIGN
    543  2e2d		       f0 02		      beq	GIQ
    544  2e2f		       10 05		      bpl	LOG2
    545  2e31				   GIQ
      0  2e31					      import	I_RUNTIME_ERROR
      1  2e31				   I_RUNTIME_ERROR_IMPORTED SET	1
    547  2e31		       a9 0e		      lda	#ERR_ILQTY
    548  2e33		       4c 2a 33 	      jmp	RUNTIME_ERROR
    549  2e36				   LOG2
    550  2e36		       a5 28		      lda	FAC
    551  2e38		       e9 7f		      sbc	#$7F
    552  2e3a		       48		      pha
    553  2e3b		       a9 80		      lda	#$80
    554  2e3d		       85 28		      sta	FAC
    555  2e3f		       a9 1a		      lda	#<CON_SQR_HALF
    556  2e41		       a0 2e		      ldy	#>CON_SQR_HALF
    557  2e43		       20 d9 2c 	      jsr	FADD
    558  2e46		       a9 1e		      lda	#<CON_SQR_TWO
    559  2e48		       a0 2e		      ldy	#>CON_SQR_TWO
    560  2e4a		       20 3c 2f 	      jsr	FDIV
    561  2e4d		       a9 09		      lda	#<CON_ONE
    562  2e4f		       a0 2e		      ldy	#>CON_ONE
    563  2e51		       20 c2 2c 	      jsr	FSUB
    564  2e54		       a9 0d		      lda	#<POLY_LOG
    565  2e56		       a0 2e		      ldy	#>POLY_LOG
    566  2e58		       20 cf 31 	      jsr	POLYNOMIAL_ODD
    567  2e5b		       a9 22		      lda	#<CON_NEG_HALF
    568  2e5d		       a0 2e		      ldy	#>CON_NEG_HALF
    569  2e5f		       20 d9 2c 	      jsr	FADD
    570  2e62		       68		      pla
    571  2e63		       20 f6 30 	      jsr	ADDACC
    572  2e66		       a9 26		      lda	#<CON_LOG_TWO
    573  2e68		       a0 2e		      ldy	#>CON_LOG_TWO
    574  2e6a
    575  2e6a							; ----------------------------------------------------------------------------
    576  2e6a							; FAC = (Y,A) * FAC
    577  2e6a							; ----------------------------------------------------------------------------
    578  2e6a				   FMULT
    579  2e6a		       20 bf 2e 	      jsr	LOAD_ARG_FROM_YA
    580  2e6d
    581  2e6d							; ----------------------------------------------------------------------------
    582  2e6d							; FAC = ARG * FAC
    583  2e6d							; ----------------------------------------------------------------------------
    584  2e6d				   FMULTT
    585  2e6d		       d0 03		      bne	FMULTT1
    586  2e6f		       4c be 2e 	      jmp	L3903
    587  2e72				   FMULTT1
    588  2e72		       20 e5 2e 	      jsr	ADD_EXPONENTS
    589  2e75		       a9 00		      lda	#$00
    590  2e77		       85 19		      sta	RESULT
    591  2e79		       85 1a		      sta	RESULT+1
    592  2e7b		       85 1b		      sta	RESULT+2
    593  2e7d				  -	      IF	CONFIG_SMALL == 0
    594  2e7d				  -	      sta	RESULT+3
    595  2e7d					      ENDIF
    596  2e7d		       a5 35		      lda	FACEXTENSION
    597  2e7f		       20 94 2e 	      jsr	MULTIPLY1
    598  2e82				  -	      IF	CONFIG_SMALL == 0
    599  2e82				  -	      lda	FAC+4
    600  2e82				  -	      jsr	MULTIPLY1
    601  2e82					      ENDIF
    602  2e82		       a5 2b		      lda	FAC+3
    603  2e84		       20 94 2e 	      jsr	MULTIPLY1
    604  2e87		       a5 2a		      lda	FAC+2
    605  2e89		       20 94 2e 	      jsr	MULTIPLY1
    606  2e8c		       a5 29		      lda	FAC+1
    607  2e8e		       20 99 2e 	      jsr	MULTIPLY2
    608  2e91		       4c ae 2f 	      jmp	COPY_RESULT_INTO_FAC
    609  2e94
    610  2e94							; ----------------------------------------------------------------------------
    611  2e94							; MULTIPLY ARG BY (A) INTO RESULT
    612  2e94							; ----------------------------------------------------------------------------
    613  2e94				   MULTIPLY1
    614  2e94		       d0 03		      bne	MULTIPLY2
    615  2e96		       4c d6 2d 	      jmp	SHIFT_RIGHT1
    616  2e99				   MULTIPLY2
    617  2e99		       4a		      lsr
    618  2e9a		       09 80		      ora	#$80
    619  2e9c				   L38A7
    620  2e9c		       a8		      tay
    621  2e9d		       90 13		      bcc	L38C3
    622  2e9f		       18		      clc
    623  2ea0				  -	      IF	CONFIG_SMALL == 0
    624  2ea0				  -	      lda	RESULT+3
    625  2ea0				  -	      adc	ARG+4
    626  2ea0				  -	      sta	RESULT+3
    627  2ea0					      ENDIF
    628  2ea0		       a5 1b		      lda	RESULT+2
    629  2ea2		       65 32		      adc	ARG+3
    630  2ea4		       85 1b		      sta	RESULT+2
    631  2ea6		       a5 1a		      lda	RESULT+1
    632  2ea8		       65 31		      adc	ARG+2
    633  2eaa		       85 1a		      sta	RESULT+1
    634  2eac		       a5 19		      lda	RESULT
    635  2eae		       65 30		      adc	ARG+1
    636  2eb0		       85 19		      sta	RESULT
    637  2eb2				   L38C3
    638  2eb2					      IF	CONFIG_ROR_WORKAROUND == 0
    639  2eb2		       66 19		      ror	RESULT
    640  2eb4		       66 1a		      ror	RESULT+1
    641  2eb6				  -	      IF	APPLE_BAD_BYTE
    642  2eb6				  -			; this seems to be a bad byte in the dump
    643  2eb6				  -	      .byte	RESULT+2,RESULT+2	; XXX BUG!
    644  2eb6					      ELSE
    645  2eb6		       66 1b		      ror	RESULT+2
    646  2eb8					      ENDIF
    647  2eb8				  -	      IF	CONFIG_SMALL == 0
    648  2eb8				  -	      ror	RESULT+3
    649  2eb8					      ENDIF
    650  2eb8		       66 35		      ror	FACEXTENSION
    651  2eba				  -	      ELSE
    652  2eba				  -	      lda	#$00
    653  2eba				  -	      bcc	L38C9
    654  2eba				  -	      lda	#$80
    655  2eba				  -L38C9
    656  2eba				  -	      lsr	RESULT
    657  2eba				  -	      ora	RESULT
    658  2eba				  -	      sta	RESULT
    659  2eba				  -	      lda	#$00
    660  2eba				  -	      bcc	L38D5
    661  2eba				  -	      lda	#$80
    662  2eba				  -L38D5
    663  2eba				  -	      lsr	RESULT+1
    664  2eba				  -	      ora	RESULT+1
    665  2eba				  -	      sta	RESULT+1
    666  2eba				  -	      lda	#$00
    667  2eba				  -	      bcc	L38E1
    668  2eba				  -	      lda	#$80
    669  2eba				  -L38E1
    670  2eba				  -	      lsr	RESULT+2
    671  2eba				  -	      ora	RESULT+2
    672  2eba				  -	      sta	RESULT+2
    673  2eba				  -	      lda	#$00
    674  2eba				  -	      bcc	L38ED
    675  2eba				  -	      lda	#$80
    676  2eba				  -L38ED
    677  2eba				  -	      lsr	RESULT+3
    678  2eba				  -	      ora	RESULT+3
    679  2eba				  -	      sta	RESULT+3
    680  2eba				  -	      lda	#$00
    681  2eba				  -	      bcc	L38F9
    682  2eba				  -	      lda	#$80
    683  2eba				  -L38F9
    684  2eba				  -	      lsr	FACEXTENSION
    685  2eba				  -	      ora	FACEXTENSION
    686  2eba				  -	      sta	FACEXTENSION
    687  2eba					      ENDIF
    688  2eba		       98		      tya
    689  2ebb		       4a		      lsr
    690  2ebc		       d0 de		      bne	L38A7
    691  2ebe				   L3903
    692  2ebe		       60		      rts
    693  2ebf
    694  2ebf							; ----------------------------------------------------------------------------
    695  2ebf							; UNPACK NUMBER AT (Y,A) INTO ARG
    696  2ebf							; ----------------------------------------------------------------------------
    697  2ebf				   LOAD_ARG_FROM_YA
    698  2ebf		       85 17		      sta	INDEX
    699  2ec1		       84 18		      sty	INDEX+1
    700  2ec3		       a0 03		      ldy	#BYTES_FP-1
    701  2ec5				  -	      IF	CONFIG_SMALL == 0
    702  2ec5				  -	      lda	(INDEX),y
    703  2ec5				  -	      sta	ARG+4
    704  2ec5				  -	      dey
    705  2ec5					      ENDIF
    706  2ec5		       b1 17		      lda	(INDEX),y
    707  2ec7		       85 32		      sta	ARG+3
    708  2ec9		       88		      dey
    709  2eca		       b1 17		      lda	(INDEX),y
    710  2ecc		       85 31		      sta	ARG+2
    711  2ece		       88		      dey
    712  2ecf		       b1 17		      lda	(INDEX),y
    713  2ed1		       85 33		      sta	ARGSIGN
    714  2ed3		       45 2c		      eor	FACSIGN
    715  2ed5		       85 34		      sta	SGNCPR
    716  2ed7		       a5 33		      lda	ARGSIGN
    717  2ed9		       09 80		      ora	#$80
    718  2edb		       85 30		      sta	ARG+1
    719  2edd		       88		      dey
    720  2ede		       b1 17		      lda	(INDEX),y
    721  2ee0		       85 2f		      sta	ARG
    722  2ee2		       a5 28		      lda	FAC
    723  2ee4		       60		      rts
    724  2ee5
    725  2ee5							; ----------------------------------------------------------------------------
    726  2ee5							; ADD EXPONENTS OF ARG AND FAC
    727  2ee5							; (CALLED BY FMULT AND FDIV)
    728  2ee5							;
    729  2ee5							; ALSO CHECK FOR OVERFLOW, AND SET RESULT SIGN
    730  2ee5							; ----------------------------------------------------------------------------
    731  2ee5				   ADD_EXPONENTS
    732  2ee5		       a5 2f		      lda	ARG
    733  2ee7				   ADD_EXPONENTS1
    734  2ee7		       f0 1f		      beq	ZERO
    735  2ee9		       18		      clc
    736  2eea		       65 28		      adc	FAC
    737  2eec		       90 04		      bcc	L393C
    738  2eee		       30 1d		      bmi	JOV
    739  2ef0		       18		      clc
    740  2ef1		       2c		      .byte.b	$2C
    741  2ef2				   L393C
    742  2ef2		       10 14		      bpl	ZERO
    743  2ef4		       69 80		      adc	#$80
    744  2ef6		       85 28		      sta	FAC
    745  2ef8		       d0 03		      bne	L3947
    746  2efa		       4c 62 2d 	      jmp	STA_IN_FAC_SIGN
    747  2efd				   L3947
    748  2efd		       a5 34		      lda	SGNCPR
    749  2eff		       85 2c		      sta	FACSIGN
    750  2f01		       60		      rts
    751  2f02
    752  2f02							; ----------------------------------------------------------------------------
    753  2f02							; IF (FAC) IS POSITIVE, GIVE "OVERFLOW" ERROR
    754  2f02							; IF (FAC) IS NEGATIVE, SET FAC=0, POP ONE RETURN, AND RTS
    755  2f02							; CALLED FROM "EXP" FUNCTION
    756  2f02							; ----------------------------------------------------------------------------
    757  2f02				   OUTOFRNG
    758  2f02		       a5 2c		      lda	FACSIGN
    759  2f04		       49 ff		      eor	#$FF
    760  2f06		       30 05		      bmi	JOV
    761  2f08
    762  2f08							; ----------------------------------------------------------------------------
    763  2f08							; POP RETURN ADDRESS AND SET FAC=0
    764  2f08							; ----------------------------------------------------------------------------
    765  2f08				   ZERO
    766  2f08		       68		      pla
    767  2f09		       68		      pla
    768  2f0a		       4c 5e 2d 	      jmp	ZERO_FAC
    769  2f0d				   JOV
    770  2f0d		       4c d1 2d 	      jmp	OVERFLOW
    771  2f10
    772  2f10							; ----------------------------------------------------------------------------
    773  2f10							; MULTIPLY FAC BY 10
    774  2f10							; ----------------------------------------------------------------------------
    775  2f10				   MUL10
    776  2f10		       20 19 30 	      jsr	COPY_FAC_TO_ARG_ROUNDED
    777  2f13		       aa		      tax
    778  2f14		       f0 10		      beq	L3970
    779  2f16		       18		      clc
    780  2f17		       69 02		      adc	#$02
    781  2f19		       b0 f2		      bcs	JOV
    782  2f1b				   LD9BF
    783  2f1b		       a2 00		      ldx	#$00
    784  2f1d		       86 34		      stx	SGNCPR
    785  2f1f		       20 e9 2c 	      jsr	FADD2
    786  2f22		       e6 28		      inc	FAC
    787  2f24		       f0 e7		      beq	JOV
    788  2f26				   L3970
    789  2f26		       60		      rts
    790  2f27
    791  2f27							; ----------------------------------------------------------------------------
    792  2f27				   CONTEN
    793  2f27					      IF	CONFIG_SMALL
    794  2f27		       84 20 00 00	      .byte.b	$84,$20,$00,$00
    795  2f2b				  -	      ELSE
    796  2f2b				  -	      .byte	$84,$20,$00,$00,$00
    797  2f2b					      ENDIF
    798  2f2b
    799  2f2b							; ----------------------------------------------------------------------------
    800  2f2b							; DIVIDE FAC BY 10
    801  2f2b							; ----------------------------------------------------------------------------
    802  2f2b				   DIV10
    803  2f2b		       20 19 30 	      jsr	COPY_FAC_TO_ARG_ROUNDED
    804  2f2e		       a9 27		      lda	#<CONTEN
    805  2f30		       a0 2f		      ldy	#>CONTEN
    806  2f32		       a2 00		      ldx	#$00
    807  2f34
    808  2f34							; ----------------------------------------------------------------------------
    809  2f34							; FAC = ARG / (Y,A)
    810  2f34							; ----------------------------------------------------------------------------
    811  2f34				   DIV
    812  2f34		       86 34		      stx	SGNCPR
    813  2f36		       20 bd 2f 	      jsr	LOAD_FAC_FROM_YA
    814  2f39		       4c 3f 2f 	      jmp	FDIVT
    815  2f3c
    816  2f3c							; ----------------------------------------------------------------------------
    817  2f3c							; FAC = (Y,A) / FAC
    818  2f3c							; ----------------------------------------------------------------------------
    819  2f3c				   FDIV
    820  2f3c		       20 bf 2e 	      jsr	LOAD_ARG_FROM_YA
    821  2f3f
    822  2f3f							; ----------------------------------------------------------------------------
    823  2f3f							; FAC = ARG / FAC
    824  2f3f							; ----------------------------------------------------------------------------
    825  2f3f				   FDIVT
    826  2f3f		       d0 05		      bne	FDIVT1
      0  2f41					      import	I_RUNTIME_ERROR
      1  2f41				   I_RUNTIME_ERROR_IMPORTED SET	1
    828  2f41		       a9 14		      lda	#ERR_DIVZERO
    829  2f43		       4c 2a 33 	      jmp	RUNTIME_ERROR
    830  2f46				   FDIVT1
    831  2f46		       20 28 30 	      jsr	ROUND_FAC
    832  2f49		       a9 00		      lda	#$00
    833  2f4b		       38		      sec
    834  2f4c		       e5 28		      sbc	FAC
    835  2f4e		       85 28		      sta	FAC
    836  2f50		       20 e5 2e 	      jsr	ADD_EXPONENTS
    837  2f53		       e6 28		      inc	FAC
    838  2f55		       f0 b6		      beq	JOV
    839  2f57		       a2 fd		      ldx	#-MANTISSA_BYTES
    840  2f59		       a9 01		      lda	#$01
    841  2f5b				   L39A1
    842  2f5b		       a4 30		      ldy	ARG+1
    843  2f5d		       c4 29		      cpy	FAC+1
    844  2f5f		       d0 0a		      bne	L39B7
    845  2f61		       a4 31		      ldy	ARG+2
    846  2f63		       c4 2a		      cpy	FAC+2
    847  2f65		       d0 04		      bne	L39B7
    848  2f67		       a4 32		      ldy	ARG+3
    849  2f69		       c4 2b		      cpy	FAC+3
    850  2f6b				  -	      IF	CONFIG_SMALL == 0
    851  2f6b				  -	      bne	L39B7
    852  2f6b				  -	      ldy	ARG+4
    853  2f6b				  -	      cpy	FAC+4
    854  2f6b					      ENDIF
    855  2f6b				   L39B7
    856  2f6b		       08		      php
    857  2f6c		       2a		      rol
    858  2f6d		       90 09		      bcc	L39C4
    859  2f6f		       e8		      inx
    860  2f70		       95 1b		      sta	RESULT_LAST-1,x
    861  2f72		       f0 2a		      beq	L39F2
    862  2f74		       10 2c		      bpl	L39F6
    863  2f76		       a9 01		      lda	#$01
    864  2f78				   L39C4
    865  2f78		       28		      plp
    866  2f79		       b0 0c		      bcs	L39D5
    867  2f7b				   L39C7
    868  2f7b		       06 32		      asl	ARG_LAST
    869  2f7d				  -	      IF	CONFIG_SMALL == 0
    870  2f7d				  -	      rol	ARG+3
    871  2f7d					      ENDIF
    872  2f7d		       26 31		      rol	ARG+2
    873  2f7f		       26 30		      rol	ARG+1
    874  2f81		       b0 e8		      bcs	L39B7
    875  2f83		       30 d6		      bmi	L39A1
    876  2f85		       10 e4		      bpl	L39B7
    877  2f87				   L39D5
    878  2f87		       a8		      tay
    879  2f88				  -	      IF	CONFIG_SMALL == 0
    880  2f88				  -	      lda	ARG+4
    881  2f88				  -	      sbc	FAC+4
    882  2f88				  -	      sta	ARG+4
    883  2f88					      ENDIF
    884  2f88		       a5 32		      lda	ARG+3
    885  2f8a		       e5 2b		      sbc	FAC+3
    886  2f8c		       85 32		      sta	ARG+3
    887  2f8e		       a5 31		      lda	ARG+2
    888  2f90		       e5 2a		      sbc	FAC+2
    889  2f92		       85 31		      sta	ARG+2
    890  2f94		       a5 30		      lda	ARG+1
    891  2f96		       e5 29		      sbc	FAC+1
    892  2f98		       85 30		      sta	ARG+1
    893  2f9a		       98		      tya
    894  2f9b		       4c 7b 2f 	      jmp	L39C7
    895  2f9e				   L39F2
    896  2f9e		       a9 40		      lda	#$40
    897  2fa0		       d0 d6		      bne	L39C4
    898  2fa2				   L39F6
    899  2fa2		       0a		      asl
    900  2fa3		       0a		      asl
    901  2fa4		       0a		      asl
    902  2fa5		       0a		      asl
    903  2fa6		       0a		      asl
    904  2fa7		       0a		      asl
    905  2fa8		       85 35		      sta	FACEXTENSION
    906  2faa		       28		      plp
    907  2fab		       4c ae 2f 	      jmp	COPY_RESULT_INTO_FAC
    908  2fae
    909  2fae							; ----------------------------------------------------------------------------
    910  2fae							; COPY RESULT INTO FAC MANTISSA, AND NORMALIZE
    911  2fae							; ----------------------------------------------------------------------------
    912  2fae				   COPY_RESULT_INTO_FAC
    913  2fae		       a5 19		      lda	RESULT
    914  2fb0		       85 29		      sta	FAC+1
    915  2fb2		       a5 1a		      lda	RESULT+1
    916  2fb4		       85 2a		      sta	FAC+2
    917  2fb6		       a5 1b		      lda	RESULT+2
    918  2fb8		       85 2b		      sta	FAC+3
    919  2fba				  -	      IF	CONFIG_SMALL == 0
    920  2fba				  -	      lda	RESULT+3
    921  2fba				  -	      sta	FAC+4
    922  2fba					      ENDIF
    923  2fba		       4c 42 2d 	      jmp	NORMALIZE_FAC2
    924  2fbd
    925  2fbd							; ----------------------------------------------------------------------------
    926  2fbd							; UNPACK (Y,A) INTO FAC
    927  2fbd							; ----------------------------------------------------------------------------
    928  2fbd				   LOAD_FAC_FROM_YA
    929  2fbd		       85 17		      sta	INDEX
    930  2fbf		       84 18		      sty	INDEX+1
    931  2fc1		       a0 03		      ldy	#MANTISSA_BYTES
    932  2fc3				  -	      IF	CONFIG_SMALL == 0
    933  2fc3				  -	      lda	(INDEX),y
    934  2fc3				  -	      sta	FAC+4
    935  2fc3				  -	      dey
    936  2fc3					      ENDIF
    937  2fc3		       b1 17		      lda	(INDEX),y
    938  2fc5		       85 2b		      sta	FAC+3
    939  2fc7		       88		      dey
    940  2fc8		       b1 17		      lda	(INDEX),y
    941  2fca		       85 2a		      sta	FAC+2
    942  2fcc		       88		      dey
    943  2fcd		       b1 17		      lda	(INDEX),y
    944  2fcf		       85 2c		      sta	FACSIGN
    945  2fd1		       09 80		      ora	#$80
    946  2fd3		       85 29		      sta	FAC+1
    947  2fd5		       88		      dey
    948  2fd6		       b1 17		      lda	(INDEX),y
    949  2fd8		       85 28		      sta	FAC
    950  2fda		       84 35		      sty	FACEXTENSION
    951  2fdc		       60		      rts
    952  2fdd
    953  2fdd							; ----------------------------------------------------------------------------
    954  2fdd							; ROUND FAC, STORE IN TEMP2
    955  2fdd							; ----------------------------------------------------------------------------
    956  2fdd				   STORE_FAC_IN_TEMP2_ROUNDED
    957  2fdd		       a2 24		      ldx	#TEMP2
    958  2fdf		       2c		      .byte.b	$2C
    959  2fe0
    960  2fe0							; ----------------------------------------------------------------------------
    961  2fe0							; ROUND FAC, STORE IN TEMP1
    962  2fe0							; ----------------------------------------------------------------------------
    963  2fe0				   STORE_FAC_IN_TEMP1_ROUNDED
    964  2fe0		       a2 20		      ldx	#TEMP1X
    965  2fe2		       a0 00		      ldy	#$00
    966  2fe4		       f0 00		      beq	STORE_FAC_AT_YX_ROUNDED
    967  2fe6
    968  2fe6							; ----------------------------------------------------------------------------
    969  2fe6							; ROUND FAC, AND STORE AT (Y,X)
    970  2fe6							; ----------------------------------------------------------------------------
    971  2fe6				   STORE_FAC_AT_YX_ROUNDED
    972  2fe6		       20 28 30 	      jsr	ROUND_FAC
    973  2fe9		       86 17		      stx	INDEX
    974  2feb		       84 18		      sty	INDEX+1
    975  2fed		       a0 03		      ldy	#MANTISSA_BYTES
    976  2fef				  -	      IF	CONFIG_SMALL == 0
    977  2fef				  -	      lda	FAC+4
    978  2fef				  -	      sta	(INDEX),y
    979  2fef				  -	      dey
    980  2fef					      ENDIF
    981  2fef		       a5 2b		      lda	FAC+3
    982  2ff1		       91 17		      sta	(INDEX),y
    983  2ff3		       88		      dey
    984  2ff4		       a5 2a		      lda	FAC+2
    985  2ff6		       91 17		      sta	(INDEX),y
    986  2ff8		       88		      dey
    987  2ff9		       a5 2c		      lda	FACSIGN
    988  2ffb		       09 7f		      ora	#$7F
    989  2ffd		       25 29		      and	FAC+1
    990  2fff		       91 17		      sta	(INDEX),y
    991  3001		       88		      dey
    992  3002		       a5 28		      lda	FAC
    993  3004		       91 17		      sta	(INDEX),y
    994  3006		       84 35		      sty	FACEXTENSION
    995  3008		       60		      rts
    996  3009
    997  3009							; ----------------------------------------------------------------------------
    998  3009							; COPY ARG INTO FAC
    999  3009							; ----------------------------------------------------------------------------
   1000  3009				   COPY_ARG_TO_FAC
   1001  3009		       a5 33		      lda	ARGSIGN
   1002  300b				   MFA
   1003  300b		       85 2c		      sta	FACSIGN
   1004  300d		       a2 04		      ldx	#BYTES_FP
   1005  300f				   L3A7A
   1006  300f		       b5 2e		      lda	SHIFTSIGNEXT,x
   1007  3011		       95 27		      sta	EXPSGN,x
   1008  3013		       ca		      dex
   1009  3014		       d0 f9		      bne	L3A7A
   1010  3016		       86 35		      stx	FACEXTENSION
   1011  3018		       60		      rts
   1012  3019
   1013  3019							; ----------------------------------------------------------------------------
   1014  3019							; ROUND FAC AND COPY TO ARG
   1015  3019							; ----------------------------------------------------------------------------
   1016  3019				   COPY_FAC_TO_ARG_ROUNDED
   1017  3019		       20 28 30 	      jsr	ROUND_FAC
   1018  301c				   MAF
   1019  301c		       a2 05		      ldx	#BYTES_FP+1
   1020  301e				   L3A89
   1021  301e		       b5 27		      lda	EXPSGN,x
   1022  3020		       95 2e		      sta	SHIFTSIGNEXT,x
   1023  3022		       ca		      dex
   1024  3023		       d0 f9		      bne	L3A89
   1025  3025		       86 35		      stx	FACEXTENSION
   1026  3027				   RTS14
   1027  3027		       60		      rts
   1028  3028
   1029  3028							; ----------------------------------------------------------------------------
   1030  3028							; ROUND FAC USING EXTENSION BYTE
   1031  3028							; ----------------------------------------------------------------------------
   1032  3028				   ROUND_FAC
   1033  3028		       a5 28		      lda	FAC
   1034  302a		       f0 fb		      beq	RTS14
   1035  302c		       06 35		      asl	FACEXTENSION
   1036  302e		       90 f7		      bcc	RTS14
   1037  3030
   1038  3030							; ----------------------------------------------------------------------------
   1039  3030							; INCREMENT MANTISSA AND RE-NORMALIZE IF CARRY
   1040  3030							; ----------------------------------------------------------------------------
   1041  3030				   INCREMENT_MANTISSA
   1042  3030		       20 c6 2d 	      jsr	INCREMENT_FAC_MANTISSA
   1043  3033		       d0 f2		      bne	RTS14
   1044  3035		       4c 97 2d 	      jmp	NORMALIZE_FAC6
   1045  3038
   1046  3038							; ----------------------------------------------------------------------------
   1047  3038							; TEST FAC FOR ZERO AND SIGN
   1048  3038							;
   1049  3038							; FAC > 0, RETURN +1
   1050  3038							; FAC = 0, RETURN  0
   1051  3038							; FAC < 0, RETURN -1
   1052  3038							; ----------------------------------------------------------------------------
   1053  3038				   SIGN
   1054  3038		       a5 28		      lda	FAC
   1055  303a		       f0 09		      beq	RTS15
   1056  303c				   L3AA7
   1057  303c		       a5 2c		      lda	FACSIGN
   1058  303e				   SIGN2
   1059  303e		       2a		      rol
   1060  303f		       a9 ff		      lda	#$FF
   1061  3041		       b0 02		      bcs	RTS15
   1062  3043		       a9 01		      lda	#$01
   1063  3045				   RTS15
   1064  3045		       60		      rts
   1065  3046
   1066  3046							; ----------------------------------------------------------------------------
   1067  3046							; "SGN" FUNCTION
   1068  3046							; ----------------------------------------------------------------------------
   1069  3046				   SGN
   1070  3046		       20 38 30 	      jsr	SIGN
   1071  3049
   1072  3049							; ----------------------------------------------------------------------------
   1073  3049							; CONVERT (A) INTO FAC, AS SIGNED VALUE -128 TO +127
   1074  3049							; ----------------------------------------------------------------------------
   1075  3049				   FLOAT
   1076  3049		       85 29		      sta	FAC+1
   1077  304b		       a9 00		      lda	#$00
   1078  304d		       85 2a		      sta	FAC+2
   1079  304f		       a2 88		      ldx	#$88
   1080  3051
   1081  3051							; ----------------------------------------------------------------------------
   1082  3051							; FLOAT UNSIGNED VALUE IN FAC+1,2 (HB-LB)
   1083  3051							; (X) = EXPONENT
   1084  3051							; ----------------------------------------------------------------------------
   1085  3051				   FLOAT1
   1086  3051		       a5 29		      lda	FAC+1
   1087  3053		       49 ff		      eor	#$FF
   1088  3055		       2a		      rol
   1089  3056
   1090  3056							; ----------------------------------------------------------------------------
   1091  3056							; FLOAT UNSIGNED VALUE IN FAC+1,2 (HB-LB)
   1092  3056							; (X) = EXPONENT
   1093  3056							; C=0 TO MAKE VALUE NEGATIVE
   1094  3056							; C=1 TO MAKE VALUE POSITIVE
   1095  3056							; ----------------------------------------------------------------------------
   1096  3056				   FLOAT2
   1097  3056		       a9 00		      lda	#$00
   1098  3058				  -	      IFNCONST	CONFIG_SMALL
   1099  3058				  -	      sta	FAC+4
   1100  3058					      ENDIF
   1101  3058		       85 2b		      sta	FAC+3
   1102  305a				   LDB21
   1103  305a		       86 28		      stx	FAC
   1104  305c		       85 35		      sta	FACEXTENSION
   1105  305e		       85 2c		      sta	FACSIGN
   1106  3060		       4c 3d 2d 	      jmp	NORMALIZE_FAC1
   1107  3063
   1108  3063							; ----------------------------------------------------------------------------
   1109  3063							; "ABS" FUNCTION
   1110  3063							; ----------------------------------------------------------------------------
   1111  3063				   ABS
   1112  3063		       46 2c		      lsr	FACSIGN
   1113  3065		       60		      rts
   1114  3066
   1115  3066							; ----------------------------------------------------------------------------
   1116  3066							; COMPARE FAC WITH PACKED # AT (Y,A)
   1117  3066							; RETURN A=1,0,-1 AS (Y,A) IS <,=,> FAC
   1118  3066							; ----------------------------------------------------------------------------
   1119  3066				   FCOMP
   1120  3066		       85 19		      sta	DEST
   1121  3068
   1122  3068							; ----------------------------------------------------------------------------
   1123  3068							; SPECIAL ENTRY FROM "NEXT" PROCESSOR
   1124  3068							; "DEST" ALREADY SET UP
   1125  3068							; ----------------------------------------------------------------------------
   1126  3068				   FCOMP2
   1127  3068		       84 1a		      sty	DEST+1
   1128  306a		       a0 00		      ldy	#$00
   1129  306c		       b1 19		      lda	(DEST),y
   1130  306e		       c8		      iny
   1131  306f		       aa		      tax
   1132  3070		       f0 c6		      beq	SIGN
   1133  3072		       b1 19		      lda	(DEST),y
   1134  3074		       45 2c		      eor	FACSIGN
   1135  3076		       30 c4		      bmi	L3AA7
   1136  3078		       e4 28		      cpx	FAC
   1137  307a		       d0 1a		      bne	L3B0A
   1138  307c		       b1 19		      lda	(DEST),y
   1139  307e		       09 80		      ora	#$80
   1140  3080		       c5 29		      cmp	FAC+1
   1141  3082		       d0 12		      bne	L3B0A
   1142  3084		       c8		      iny
   1143  3085		       b1 19		      lda	(DEST),y
   1144  3087		       c5 2a		      cmp	FAC+2
   1145  3089		       d0 0b		      bne	L3B0A
   1146  308b		       c8		      iny
   1147  308c				  -	      IF	CONFIG_SMALL == 0
   1148  308c				  -	      lda	(DEST),y
   1149  308c				  -	      cmp	FAC+3
   1150  308c				  -	      bne	L3B0A
   1151  308c				  -	      iny
   1152  308c					      ENDIF
   1153  308c		       a9 7f		      lda	#$7F
   1154  308e		       c5 35		      cmp	FACEXTENSION
   1155  3090		       b1 19		      lda	(DEST),y
   1156  3092		       e5 2b		      sbc	FAC_LAST
   1157  3094		       f0 09		      beq	FCOMPEND
   1158  3096				   L3B0A
   1159  3096		       a5 2c		      lda	FACSIGN
   1160  3098		       90 02		      bcc	L3B10
   1161  309a		       49 ff		      eor	#$FF
   1162  309c				   L3B10
   1163  309c		       4c 3e 30 	      jmp	SIGN2
   1164  309f				   FCOMPEND
   1165  309f		       60		      rts
   1166  30a0
   1167  30a0							; ----------------------------------------------------------------------------
   1168  30a0							; QUICK INTEGER FUNCTION
   1169  30a0							;
   1170  30a0							; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
   1171  30a0							; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
   1172  30a0							; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
   1173  30a0							;
   1174  30a0							; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
   1175  30a0							; ----------------------------------------------------------------------------
   1176  30a0				   QINT
   1177  30a0		       a5 28		      lda	FAC
   1178  30a2		       f0 4a		      beq	QINT3
   1179  30a4		       38		      sec
   1180  30a5		       e9 98		      sbc	#120+8*BYTES_FP
   1181  30a7		       24 2c		      bit	FACSIGN
   1182  30a9		       10 09		      bpl	L3B27
   1183  30ab		       aa		      tax
   1184  30ac		       a9 ff		      lda	#$FF
   1185  30ae		       85 2e		      sta	SHIFTSIGNEXT
   1186  30b0		       20 aa 2d 	      jsr	COMPLEMENT_FAC_MANTISSA
   1187  30b3		       8a		      txa
   1188  30b4				   L3B27
   1189  30b4		       a2 28		      ldx	#FAC
   1190  30b6		       c9 f9		      cmp	#$F9
   1191  30b8		       10 06		      bpl	QINT2
   1192  30ba		       20 e8 2d 	      jsr	SHIFT_RIGHT
   1193  30bd		       84 2e		      sty	SHIFTSIGNEXT
   1194  30bf				   L3B32
   1195  30bf		       60		      rts
   1196  30c0				   QINT2
   1197  30c0		       a8		      tay
   1198  30c1		       a5 2c		      lda	FACSIGN
   1199  30c3		       29 80		      and	#$80
   1200  30c5		       46 29		      lsr	FAC+1
   1201  30c7		       05 29		      ora	FAC+1
   1202  30c9		       85 29		      sta	FAC+1
   1203  30cb		       20 ff 2d 	      jsr	SHIFT_RIGHT4
   1204  30ce		       84 2e		      sty	SHIFTSIGNEXT
   1205  30d0		       60		      rts
   1206  30d1
   1207  30d1							; ----------------------------------------------------------------------------
   1208  30d1							; "INT" FUNCTION
   1209  30d1							;
   1210  30d1							; USES QINT TO CONVERT (FAC) TO INTEGER FORM,
   1211  30d1							; AND THEN REFLOATS THE INTEGER.
   1212  30d1							; ----------------------------------------------------------------------------
   1213  30d1				   INT
   1214  30d1		       a5 28		      lda	FAC
   1215  30d3		       c9 98		      cmp	#120+8*BYTES_FP
   1216  30d5		       b0 1e		      bcs	RTS17
   1217  30d7		       20 a0 30 	      jsr	QINT
   1218  30da		       84 35		      sty	FACEXTENSION
   1219  30dc		       a5 2c		      lda	FACSIGN
   1220  30de		       84 2c		      sty	FACSIGN
   1221  30e0		       49 80		      eor	#$80
   1222  30e2		       2a		      rol
   1223  30e3		       a9 98		      lda	#120+8*BYTES_FP
   1224  30e5		       85 28		      sta	FAC
   1225  30e7		       a5 2b		      lda	FAC_LAST
   1226  30e9		       85 16		      sta	CHARAC
   1227  30eb		       4c 3d 2d 	      jmp	NORMALIZE_FAC1
   1228  30ee				   QINT3
   1229  30ee		       85 29		      sta	FAC+1
   1230  30f0		       85 2a		      sta	FAC+2
   1231  30f2		       85 2b		      sta	FAC+3
   1232  30f4				  -	      IF	CONFIG_SMALL == 0
   1233  30f4				  -	      sta	FAC+4
   1234  30f4					      ENDIF
   1235  30f4		       a8		      tay
   1236  30f5				   RTS17
   1237  30f5		       60		      rts
   1238  30f6
   1239  30f6							; ----------------------------------------------------------------------------
   1240  30f6							; ADD (A) TO FAC
   1241  30f6							; ----------------------------------------------------------------------------
   1242  30f6				   ADDACC
   1243  30f6		       48		      pha
   1244  30f7		       20 19 30 	      jsr	COPY_FAC_TO_ARG_ROUNDED
   1245  30fa		       68		      pla
   1246  30fb		       20 49 30 	      jsr	FLOAT
   1247  30fe		       a5 33		      lda	ARGSIGN
   1248  3100		       45 2c		      eor	FACSIGN
   1249  3102		       85 34		      sta	SGNCPR
   1250  3104		       a6 28		      ldx	FAC
   1251  3106		       4c dc 2c 	      jmp	FADDT
   1252  3109
   1253  3109				  -	      IFCONST	I_FIN_IMPORTED
   1254  3109				  -			; ----------------------------------------------------------------------------
   1255  3109				  -			; CONVERT STRING TO FP VALUE IN FAC
   1256  3109				  -			;
   1257  3109				  -			; STRING POINTER IN R0
   1258  3109				  -			; STRING LENGTH IN RA
   1259  3109				  -			; ----------------------------------------------------------------------------
   1260  3109				  -
   1261  3109				  -FIN
   1262  3109				  -	      ldy	#$00
   1263  3109				  -	      sty	RB
   1264  3109				  -	      ldx	#SERLEN-TMPEXP
   1265  3109				  -L3B6F
   1266  3109				  -	      sty	TMPEXP,x
   1267  3109				  -	      dex
   1268  3109				  -	      bpl	L3B6F
   1269  3109				  -	      jsr	CHRGET
   1270  3109				  -	      bcc	FIN2
   1271  3109				  -	      cmp	#$2D	; '-'
   1272  3109				  -	      bne	L3B7E
   1273  3109				  -	      stx	SERLEN
   1274  3109				  -	      beq	FIN1
   1275  3109				  -L3B7E
   1276  3109				  -	      cmp	#$2B	; '+'
   1277  3109				  -	      bne	FIN3
   1278  3109				  -FIN1
   1279  3109				  -	      jsr	CHRGET
   1280  3109				  -FIN2
   1281  3109				  -	      bcc	FIN9
   1282  3109				  -FIN3
   1283  3109				  -	      cmp	#$2E	; '.'
   1284  3109				  -	      beq	FIN10
   1285  3109				  -	      cmp	#$45	; 'e'
   1286  3109				  -	      bne	FIN7
   1287  3109				  -	      jsr	CHRGET
   1288  3109				  -	      bcc	FIN5
   1289  3109				  -	      cmp	#$2D	; '-'
   1290  3109				  -	      beq	L3BA6
   1291  3109				  -	      cmp	#$2D	; '-'
   1292  3109				  -	      beq	L3BA6
   1293  3109				  -	      cmp	#$2B	; '+'
   1294  3109				  -	      beq	FIN4
   1295  3109				  -	      cmp	#$2B	; '+'
   1296  3109				  -	      beq	FIN4
   1297  3109				  -	      bne	FIN6
   1298  3109				  -L3BA6
   1299  3109				  -	      IFNCONST	CONFIG_ROR_WORKAROUND
   1300  3109				  -	      ror	EXPSGN
   1301  3109				  -	      ELSE
   1302  3109				  -	      lda	#$00
   1303  3109				  -	      bcc	L3BAC
   1304  3109				  -	      lda	#$80
   1305  3109				  -L3BAC
   1306  3109				  -	      lsr	EXPSGN
   1307  3109				  -	      ora	EXPSGN
   1308  3109				  -	      sta	EXPSGN
   1309  3109				  -	      ENDIF
   1310  3109				  -FIN4
   1311  3109				  -	      jsr	CHRGET
   1312  3109				  -FIN5
   1313  3109				  -	      bcc	GETEXP
   1314  3109				  -FIN6
   1315  3109				  -	      bit	EXPSGN
   1316  3109				  -	      bpl	FIN7
   1317  3109				  -	      lda	#$00
   1318  3109				  -	      sec
   1319  3109				  -	      sbc	EXPON
   1320  3109				  -	      jmp	FIN8
   1321  3109				  -			; ----------------------------------------------------------------------------
   1322  3109				  -			; FOUND A DECIMAL POINT
   1323  3109				  -			; ----------------------------------------------------------------------------
   1324  3109				  -FIN10
   1325  3109				  -	      IFNCONST	CONFIG_ROR_WORKAROUND
   1326  3109				  -	      ror	LOWTR
   1327  3109				  -	      ELSE
   1328  3109				  -	      lda	#$00
   1329  3109				  -	      bcc	L3BC9
   1330  3109				  -	      lda	#$80
   1331  3109				  -L3BC9
   1332  3109				  -	      lsr	LOWTR
   1333  3109				  -	      ora	LOWTR
   1334  3109				  -	      sta	LOWTR
   1335  3109				  -	      ENDIF
   1336  3109				  -	      bit	LOWTR
   1337  3109				  -	      bvc	FIN1
   1338  3109				  -			; ----------------------------------------------------------------------------
   1339  3109				  -			; NUMBER TERMINATED, ADJUST EXPONENT NOW
   1340  3109				  -			; ----------------------------------------------------------------------------
   1341  3109				  -FIN7
   1342  3109				  -	      lda	EXPON
   1343  3109				  -FIN8
   1344  3109				  -	      sec
   1345  3109				  -	      sbc	INDX
   1346  3109				  -	      sta	EXPON
   1347  3109				  -	      beq	L3BEE
   1348  3109				  -	      bpl	L3BE7
   1349  3109				  -L3BDE
   1350  3109				  -	      jsr	DIV10
   1351  3109				  -	      inc	EXPON
   1352  3109				  -	      bne	L3BDE
   1353  3109				  -	      beq	L3BEE
   1354  3109				  -L3BE7
   1355  3109				  -	      jsr	MUL10
   1356  3109				  -	      dec	EXPON
   1357  3109				  -	      bne	L3BE7
   1358  3109				  -L3BEE
   1359  3109				  -	      lda	SERLEN
   1360  3109				  -	      bmi	L3BF3
   1361  3109				  -	      rts
   1362  3109				  -L3BF3
   1363  3109				  -	      jmp	NEGOP
   1364  3109				  -			; ----------------------------------------------------------------------------
   1365  3109				  -			; ACCUMULATE A DIGIT INTO FAC
   1366  3109				  -			; ----------------------------------------------------------------------------
   1367  3109				  -FIN9
   1368  3109				  -	      pha
   1369  3109				  -	      bit	LOWTR
   1370  3109				  -	      bpl	L3BFD
   1371  3109				  -	      inc	INDX
   1372  3109				  -L3BFD
   1373  3109				  -	      jsr	MUL10
   1374  3109				  -	      pla
   1375  3109				  -	      sec
   1376  3109				  -	      sbc	#$30
   1377  3109				  -	      jsr	ADDACC
   1378  3109				  -	      jmp	FIN1
   1379  3109				  -
   1380  3109				  -			; ----------------------------------------------------------------------------
   1381  3109				  -			; ACCUMULATE DIGIT OF EXPONENT
   1382  3109				  -			; ----------------------------------------------------------------------------
   1383  3109				  -GETEXP
   1384  3109				  -	      lda	EXPON
   1385  3109				  -	      cmp	#MAX_EXPON
   1386  3109				  -	      bcc	L3C2C
   1387  3109				  -	      IF	CONFIG_10A
   1388  3109				  -	      lda	#$64
   1389  3109				  -	      ENDIF
   1390  3109				  -	      bit	EXPSGN
   1391  3109				  -	      IF	CONFIG_10A
   1392  3109				  -	      bmi	L3C3A
   1393  3109				  -	      ELSE
   1394  3109				  -	      bmi	LDC70
   1395  3109				  -	      ENDIF
   1396  3109				  -	      jmp	OVERFLOW
   1397  3109				  -LDC70
   1398  3109				  -	      IFNCONST	CONFIG_10A
   1399  3109				  -	      lda	#$0B
   1400  3109				  -	      ENDIF
   1401  3109				  -L3C2C
   1402  3109				  -	      asl
   1403  3109				  -	      asl
   1404  3109				  -	      clc
   1405  3109				  -	      adc	EXPON
   1406  3109				  -	      asl
   1407  3109				  -	      clc
   1408  3109				  -	      adc	(R0),y
   1409  3109				  -	      sec
   1410  3109				  -	      sbc	#$30
   1411  3109				  -L3C3A
   1412  3109				  -	      sta	EXPON
   1413  3109				  -	      jmp	FIN4
   1414  3109				  -
   1415  3109				  -			; Custom chrget function
   1416  3109				  -			; String pointer already stored in (R0)
   1417  3109				  -			; String length in RA
   1418  3109				  -			; Temp index RB must be set to 0 before first invocation
   1419  3109				  -CHRGET     SUBROUTINE
   1420  3109				  -	      inc	RB	; tmp index
   1421  3109				  -	      ldy	RB
   1422  3109				  -	      cpy	RA
   1423  3109				  -	      bcc	.go
   1424  3109				  -	      beq	.go
   1425  3109				  -			; End of string, set zero flag and return
   1426  3109				  -	      lda	#0
   1427  3109				  -	      rts
   1428  3109				  -.go
   1429  3109				  -	      lda	(R0),y
   1430  3109				  -			; Set carry if not a number
   1431  3109				  -	      cmp	#$3a
   1432  3109				  -	      bcs	.q
   1433  3109				  -	      sec
   1434  3109				  -	      sbc	#$30
   1435  3109				  -	      sec
   1436  3109				  -	      sbc	#$d0
   1437  3109				  -.q
   1438  3109				  -	      rts
   1439  3109					      ENDIF
   1440  3109
   1441  3109							; ----------------------------------------------------------------------------
   1442  3109
   1443  3109				  -	      IFCONST	I_FOUT_IMPORTED
   1444  3109				  -	      IF	CONFIG_SMALL
   1445  3109				  -			; these values are /1000 of what the labels say
   1446  3109				  -CON_99999999_9
   1447  3109				  -	      .byte	$91,$43,$4F,$F8
   1448  3109				  -CON_999999999
   1449  3109				  -	      .byte	$94,$74,$23,$F7
   1450  3109				  -CON_BILLION
   1451  3109				  -	      .byte	$94,$74,$24,$00
   1452  3109				  -	      ELSE
   1453  3109				  -CON_99999999_9
   1454  3109				  -	      .byte	$9B,$3E,$BC,$1F,$FD
   1455  3109				  -CON_999999999
   1456  3109				  -	      IF	CONFIG_10A == 0
   1457  3109				  -	      .byte	$9E,$6E,$6B,$27,$FE
   1458  3109				  -	      ELSE
   1459  3109				  -	      .byte	$9E,$6E,$6B,$27,$FD
   1460  3109				  -	      ENDIF
   1461  3109				  -CON_BILLION
   1462  3109				  -	      .byte	$9E,$6E,$6B,$28,$00
   1463  3109				  -	      ENDIF
   1464  3109				  -
   1465  3109				  -			; ----------------------------------------------------------------------------
   1466  3109				  -			; CONVERT (FAC) TO STRING STARTING AT STACK
   1467  3109				  -			; RETURN WITH (Y,A) POINTING AT STRING
   1468  3109				  -			; ----------------------------------------------------------------------------
   1469  3109				  -FOUT
   1470  3109				  -	      ldy	#$00
   1471  3109				  -	      sty	SHIFTSIGNEXT
   1472  3109				  -	      iny
   1473  3109				  -
   1474  3109				  -			; ----------------------------------------------------------------------------
   1475  3109				  -			; "STR$" FUNCTION ENTERS HERE, WITH (Y)=0
   1476  3109				  -			; SO THAT RESULT STRING STARTS AT STACK-1
   1477  3109				  -			; (THIS IS USED AS A FLAG)
   1478  3109				  -			; ----------------------------------------------------------------------------
   1479  3109				  -FOUT1
   1480  3109				  -	      lda	#$01
   1481  3109				  -	      bit	FACSIGN
   1482  3109				  -	      bpl	L3C73
   1483  3109				  -	      lda	#$2D
   1484  3109				  -L3C73
   1485  3109				  -	      sta	stack,y
   1486  3109				  -	      sta	FACSIGN
   1487  3109				  -	      sty	STRNG2
   1488  3109				  -	      iny
   1489  3109				  -	      lda	#$30
   1490  3109				  -	      ldx	FAC
   1491  3109				  -	      bne	L3C84
   1492  3109				  -	      jmp	FOUT4
   1493  3109				  -L3C84
   1494  3109				  -	      lda	#$00
   1495  3109				  -	      cpx	#$80
   1496  3109				  -	      beq	L3C8C
   1497  3109				  -	      bcs	L3C95
   1498  3109				  -L3C8C
   1499  3109				  -	      lda	#<CON_BILLION
   1500  3109				  -	      ldy	#>CON_BILLION
   1501  3109				  -	      jsr	FMULT
   1502  3109				  -	      IF	CONFIG_SMALL
   1503  3109				  -	      lda	#-6	; exponent adjustment
   1504  3109				  -	      ELSE
   1505  3109				  -	      lda	#-9
   1506  3109				  -	      ENDIF
   1507  3109				  -L3C95
   1508  3109				  -	      sta	INDX
   1509  3109				  -			; ----------------------------------------------------------------------------
   1510  3109				  -			; ADJUST UNTIL 1E8 <= (FAC) <1E9
   1511  3109				  -			; ----------------------------------------------------------------------------
   1512  3109				  -L3C97
   1513  3109				  -	      lda	#<CON_999999999
   1514  3109				  -	      ldy	#>CON_999999999
   1515  3109				  -	      jsr	FCOMP
   1516  3109				  -	      beq	L3CBE
   1517  3109				  -	      bpl	L3CB4
   1518  3109				  -L3CA2
   1519  3109				  -	      lda	#<CON_99999999_9
   1520  3109				  -	      ldy	#>CON_99999999_9
   1521  3109				  -	      jsr	FCOMP
   1522  3109				  -	      beq	L3CAD
   1523  3109				  -	      bpl	L3CBB
   1524  3109				  -L3CAD
   1525  3109				  -	      jsr	MUL10
   1526  3109				  -	      dec	INDX
   1527  3109				  -	      bne	L3CA2
   1528  3109				  -L3CB4
   1529  3109				  -	      jsr	DIV10
   1530  3109				  -	      inc	INDX
   1531  3109				  -	      bne	L3C97
   1532  3109				  -L3CBB
   1533  3109				  -	      jsr	FADDH
   1534  3109				  -L3CBE
   1535  3109				  -	      import	I_QINT
   1536  3109				  -	      jsr	QINT
   1537  3109				  -			; ----------------------------------------------------------------------------
   1538  3109				  -			; FAC+1...FAC+4 IS NOW IN INTEGER FORM
   1539  3109				  -			; WITH POWER OF TEN ADJUSTMENT IN TMPEXP
   1540  3109				  -			;
   1541  3109				  -			; IF -10 < TMPEXP > 1, PRINT IN DECIMAL FORM
   1542  3109				  -			; OTHERWISE, PRINT IN EXPONENTIAL FORM
   1543  3109				  -			; ----------------------------------------------------------------------------
   1544  3109				  -	      ldx	#$01
   1545  3109				  -	      lda	INDX
   1546  3109				  -	      clc
   1547  3109				  -	      adc	#3*BYTES_FP-5
   1548  3109				  -	      bmi	L3CD3
   1549  3109				  -	      cmp	#3*BYTES_FP-4
   1550  3109				  -	      bcs	L3CD4
   1551  3109				  -	      adc	#$FF
   1552  3109				  -	      tax
   1553  3109				  -	      lda	#$02
   1554  3109				  -L3CD3
   1555  3109				  -	      sec
   1556  3109				  -L3CD4
   1557  3109				  -	      sbc	#$02
   1558  3109				  -	      sta	EXPON
   1559  3109				  -	      stx	INDX
   1560  3109				  -	      txa
   1561  3109				  -	      beq	L3CDF
   1562  3109				  -	      bpl	L3CF2
   1563  3109				  -L3CDF
   1564  3109				  -	      ldy	STRNG2
   1565  3109				  -	      lda	#$2E
   1566  3109				  -	      iny
   1567  3109				  -	      sta	stack,y
   1568  3109				  -	      txa
   1569  3109				  -	      beq	L3CF0
   1570  3109				  -	      lda	#$30
   1571  3109				  -	      iny
   1572  3109				  -	      sta	stack,y
   1573  3109				  -L3CF0
   1574  3109				  -	      sty	STRNG2
   1575  3109				  -			; ----------------------------------------------------------------------------
   1576  3109				  -			; NOW DIVIDE BY POWERS OF TEN TO GET SUCCESSIVE DIGITS
   1577  3109				  -			; ----------------------------------------------------------------------------
   1578  3109				  -L3CF2
   1579  3109				  -	      ldy	#$00
   1580  3109				  -LDD3A
   1581  3109				  -	      ldx	#$80
   1582  3109				  -L3CF6
   1583  3109				  -	      lda	FAC_LAST
   1584  3109				  -	      clc
   1585  3109				  -	      IF	CONFIG_SMALL == 0
   1586  3109				  -	      adc	DECTBL+3,y
   1587  3109				  -	      sta	FAC+4
   1588  3109				  -	      lda	FAC+3
   1589  3109				  -	      ENDIF
   1590  3109				  -	      adc	DECTBL+2,y
   1591  3109				  -	      sta	FAC+3
   1592  3109				  -	      lda	FAC+2
   1593  3109				  -	      adc	DECTBL+1,y
   1594  3109				  -	      sta	FAC+2
   1595  3109				  -	      lda	FAC+1
   1596  3109				  -	      adc	DECTBL,y
   1597  3109				  -	      sta	FAC+1
   1598  3109				  -	      inx
   1599  3109				  -	      bcs	L3D1A
   1600  3109				  -	      bpl	L3CF6
   1601  3109				  -	      bmi	L3D1C
   1602  3109				  -L3D1A
   1603  3109				  -	      bmi	L3CF6
   1604  3109				  -L3D1C
   1605  3109				  -	      txa
   1606  3109				  -	      bcc	L3D23
   1607  3109				  -	      eor	#$FF
   1608  3109				  -	      adc	#$0A
   1609  3109				  -L3D23
   1610  3109				  -	      adc	#$2F
   1611  3109				  -	      iny
   1612  3109				  -	      iny
   1613  3109				  -	      iny
   1614  3109				  -	      IF	CONFIG_SMALL == 0
   1615  3109				  -	      iny
   1616  3109				  -	      ENDIF
   1617  3109				  -	      sty	VARPNT
   1618  3109				  -	      ldy	STRNG2
   1619  3109				  -	      iny
   1620  3109				  -	      tax
   1621  3109				  -	      and	#$7F
   1622  3109				  -	      sta	stack,y
   1623  3109				  -	      dec	INDX
   1624  3109				  -	      bne	L3D3E
   1625  3109				  -	      lda	#$2E
   1626  3109				  -	      iny
   1627  3109				  -	      sta	stack,y
   1628  3109				  -L3D3E
   1629  3109				  -	      sty	STRNG2
   1630  3109				  -	      ldy	VARPNT
   1631  3109				  -	      txa
   1632  3109				  -	      eor	#$FF
   1633  3109				  -	      and	#$80
   1634  3109				  -	      tax
   1635  3109				  -	      cpy	#DECTBL_END-DECTBL
   1636  3109				  -	      IF	CONFIG_CBM_ALL
   1637  3109				  -	      beq	LDD96
   1638  3109				  -	      cpy	#$3C	; XXX
   1639  3109				  -	      ENDIF
   1640  3109				  -	      bne	L3CF6
   1641  3109				  -			; ----------------------------------------------------------------------------
   1642  3109				  -			; NINE DIGITS HAVE BEEN STORED IN STRING.  NOW LOOK
   1643  3109				  -			; BACK AND LOP OFF TRAILING ZEROES AND A TRAILING
   1644  3109				  -			; DECIMAL POINT.
   1645  3109				  -			; ----------------------------------------------------------------------------
   1646  3109				  -LDD96
   1647  3109				  -	      ldy	STRNG2
   1648  3109				  -L3D4E
   1649  3109				  -	      lda	stack,y
   1650  3109				  -	      dey
   1651  3109				  -	      cmp	#$30
   1652  3109				  -	      beq	L3D4E
   1653  3109				  -	      cmp	#$2E
   1654  3109				  -	      beq	L3D5B
   1655  3109				  -	      iny
   1656  3109				  -L3D5B
   1657  3109				  -	      lda	#$2B
   1658  3109				  -	      ldx	EXPON
   1659  3109				  -	      beq	L3D8F
   1660  3109				  -	      bpl	L3D6B
   1661  3109				  -	      lda	#$00
   1662  3109				  -	      sec
   1663  3109				  -	      sbc	EXPON
   1664  3109				  -	      tax
   1665  3109				  -	      lda	#$2D
   1666  3109				  -L3D6B
   1667  3109				  -	      sta	stack+2,y
   1668  3109				  -	      lda	#$45
   1669  3109				  -	      sta	stack+1,y
   1670  3109				  -	      txa
   1671  3109				  -	      ldx	#$2F
   1672  3109				  -	      sec
   1673  3109				  -L3D77
   1674  3109				  -	      inx
   1675  3109				  -	      sbc	#$0A
   1676  3109				  -	      bcs	L3D77
   1677  3109				  -	      adc	#$3A
   1678  3109				  -	      sta	stack+4,y
   1679  3109				  -	      txa
   1680  3109				  -	      sta	stack+3,y
   1681  3109				  -			;lda	  #$00
   1682  3109				  -			;sta	  stack+5,y
   1683  3109				  -			;beq	  L3D94
   1684  3109				  -	      iny
   1685  3109				  -	      iny
   1686  3109				  -	      iny
   1687  3109				  -	      iny
   1688  3109				  -	      sty	stack
   1689  3109				  -	      jmp	L3D94
   1690  3109				  -FOUT4
   1691  3109				  -	      sta	stack,y
   1692  3109				  -L3D8F
   1693  3109				  -			;lda	  #$00
   1694  3109				  -			;sta	  stack,y
   1695  3109				  -	      sty	stack
   1696  3109				  -L3D94
   1697  3109				  -	      lda	#<stack
   1698  3109				  -	      ldy	#>stack
   1699  3109				  -	      rts
   1700  3109				  -
   1701  3109				  -			; ----------------------------------------------------------------------------
   1702  3109				  -			; POWERS OF 10 FROM 1E8 DOWN TO 1,
   1703  3109				  -			; AS 32-BIT INTEGERS, WITH ALTERNATING SIGNS
   1704  3109				  -			; ----------------------------------------------------------------------------
   1705  3109				  -DECTBL
   1706  3109				  -	      IF	CONFIG_SMALL
   1707  3109				  -	      .byte	$FE,$79,$60	; -100000
   1708  3109				  -	      .byte	$00,$27,$10	; 10000
   1709  3109				  -	      .byte	$FF,$FC,$18	; -1000
   1710  3109				  -	      .byte	$00,$00,$64	; 100
   1711  3109				  -	      .byte	$FF,$FF,$F6	; -10
   1712  3109				  -	      .byte	$00,$00,$01	; 1
   1713  3109				  -	      ELSE
   1714  3109				  -	      .byte	$FA,$0A,$1F,$00	; -100000000
   1715  3109				  -	      .byte	$00,$98,$96,$80	; 10000000
   1716  3109				  -	      .byte	$FF,$F0,$BD,$C0	; -1000000
   1717  3109				  -	      .byte	$00,$01,$86,$A0	; 100000
   1718  3109				  -	      .byte	$FF,$FF,$D8,$F0	; -10000
   1719  3109				  -	      .byte	$00,$00,$03,$E8	; 1000
   1720  3109				  -	      .byte	$FF,$FF,$FF,$9C	; -100
   1721  3109				  -	      .byte	$00,$00,$00,$0A	; 10
   1722  3109				  -	      .byte	$FF,$FF,$FF,$FF	; -1
   1723  3109				  -	      ENDIF
   1724  3109				  -DECTBL_END
   1725  3109				  -	      IF	CONFIG_CBM_ALL
   1726  3109				  -	      .byte	$FF,$DF,$0A,$80	; TI$
   1727  3109				  -	      .byte	$00,$03,$4B,$C0
   1728  3109				  -	      .byte	$FF,$FF,$73,$60
   1729  3109				  -	      .byte	$00,$00,$0E,$10
   1730  3109				  -	      .byte	$FF,$FF,$FD,$A8
   1731  3109				  -	      .byte	$00,$00,$00,$3C
   1732  3109				  -	      ENDIF
   1733  3109				  -	      IF	CONFIG_2
   1734  3109				  -C_ZERO     =	CON_HALF + 2
   1735  3109				  -	      ENDIF
   1736  3109				  -
   1737  3109					      ENDIF		; /IFCONST I_FOUT_IMPORTED
   1738  3109
   1739  3109							; ----------------------------------------------------------------------------
   1740  3109				   CON_HALF
   1741  3109					      IF	CONFIG_SMALL
   1742  3109		       80 00 00 00	      .byte.b	$80,$00,$00,$00
   1743  310d				  -	      ELSE
   1744  310d				  -	      .byte	$80,$00,$00,$00,$00
   1745  310d					      ENDIF
   1746  310d
   1747  310d							; ----------------------------------------------------------------------------
   1748  310d							; "SQR" FUNCTION
   1749  310d							; ----------------------------------------------------------------------------
   1750  310d				   SQR
   1751  310d		       20 19 30 	      jsr	COPY_FAC_TO_ARG_ROUNDED
   1752  3110		       a9 09		      lda	#<CON_HALF
   1753  3112		       a0 31		      ldy	#>CON_HALF
   1754  3114		       20 bd 2f 	      jsr	LOAD_FAC_FROM_YA
   1755  3117
   1756  3117							; ----------------------------------------------------------------------------
   1757  3117							; EXPONENTIATION OPERATION
   1758  3117							;
   1759  3117							; ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
   1760  3117							; ----------------------------------------------------------------------------
   1761  3117				   FPWRT
   1762  3117		       f0 63		      beq	EXP
   1763  3119		       a5 2f		      lda	ARG
   1764  311b		       d0 03		      bne	L3DD5
   1765  311d		       4c 60 2d 	      jmp	STA_IN_FAC_SIGN_AND_EXP
   1766  3120				   L3DD5
   1767  3120		       a2 3a		      ldx	#TEMP3
   1768  3122		       a0 00		      ldy	#$00
   1769  3124		       20 e6 2f 	      jsr	STORE_FAC_AT_YX_ROUNDED
   1770  3127		       a5 33		      lda	ARGSIGN
   1771  3129		       10 0f		      bpl	L3DEF
   1772  312b		       20 d1 30 	      jsr	INT
   1773  312e		       a9 3a		      lda	#TEMP3
   1774  3130		       a0 00		      ldy	#$00
   1775  3132		       20 66 30 	      jsr	FCOMP
   1776  3135		       d0 03		      bne	L3DEF
   1777  3137		       98		      tya
   1778  3138		       a4 16		      ldy	CHARAC
   1779  313a				   L3DEF
   1780  313a		       20 0b 30 	      jsr	MFA
   1781  313d		       98		      tya
   1782  313e		       48		      pha
   1783  313f		       20 2a 2e 	      jsr	LOG
   1784  3142		       a9 3a		      lda	#TEMP3
   1785  3144		       a0 00		      ldy	#$00
   1786  3146		       20 6a 2e 	      jsr	FMULT
   1787  3149		       20 7c 31 	      jsr	EXP
   1788  314c		       68		      pla
   1789  314d		       4a		      lsr
   1790  314e		       90 0a		      bcc	L3E0F
   1791  3150
   1792  3150							; ----------------------------------------------------------------------------
   1793  3150							; NEGATE VALUE IN FAC
   1794  3150							; ----------------------------------------------------------------------------
   1795  3150				   NEGOP
   1796  3150		       a5 28		      lda	FAC
   1797  3152		       f0 06		      beq	L3E0F
   1798  3154		       a5 2c		      lda	FACSIGN
   1799  3156		       49 ff		      eor	#$FF
   1800  3158		       85 2c		      sta	FACSIGN
   1801  315a				   L3E0F
   1802  315a		       60		      rts
   1803  315b
   1804  315b							; ----------------------------------------------------------------------------
   1805  315b					      IF	CONFIG_SMALL
   1806  315b				   CON_LOG_E
   1807  315b		       81 38 aa 3b	      .byte.b	$81,$38,$AA,$3B
   1808  315f				   POLY_EXP
   1809  315f		       06		      .byte.b	$06
   1810  3160		       74 63 90 8c	      .byte.b	$74,$63,$90,$8C
   1811  3164		       77 23 0c ab	      .byte.b	$77,$23,$0C,$AB
   1812  3168		       7a 1e 94 00	      .byte.b	$7A,$1E,$94,$00
   1813  316c		       7c 63 42 80	      .byte.b	$7C,$63,$42,$80
   1814  3170		       7e 75 fe d0	      .byte.b	$7E,$75,$FE,$D0
   1815  3174		       80 31 72 15	      .byte.b	$80,$31,$72,$15
   1816  3178		       81 00 00 00	      .byte.b	$81,$00,$00,$00
   1817  317c				  -	      ELSE
   1818  317c				  -CON_LOG_E
   1819  317c				  -	      .byte	$81,$38,$AA,$3B,$29
   1820  317c				  -POLY_EXP
   1821  317c				  -	      .byte	$07
   1822  317c				  -	      .byte	$71,$34,$58,$3E,$56
   1823  317c				  -	      .byte	$74,$16,$7E,$B3,$1B
   1824  317c				  -	      .byte	$77,$2F,$EE,$E3,$85
   1825  317c				  -	      .byte	$7A,$1D,$84,$1C,$2A
   1826  317c				  -	      .byte	$7C,$63,$59,$58,$0A
   1827  317c				  -	      .byte	$7E,$75,$FD,$E7,$C6
   1828  317c				  -	      .byte	$80,$31,$72,$18,$10
   1829  317c				  -	      .byte	$81,$00,$00,$00,$00
   1830  317c					      ENDIF
   1831  317c
   1832  317c							; ----------------------------------------------------------------------------
   1833  317c							; "EXP" FUNCTION
   1834  317c							;
   1835  317c							; FAC = E ^ FAC
   1836  317c							; ----------------------------------------------------------------------------
   1837  317c				   EXP
   1838  317c		       a9 5b		      lda	#<CON_LOG_E
   1839  317e		       a0 31		      ldy	#>CON_LOG_E
   1840  3180		       20 6a 2e 	      jsr	FMULT
   1841  3183		       a5 35		      lda	FACEXTENSION
   1842  3185		       69 50		      adc	#$50
   1843  3187		       90 03		      bcc	L3E4E
   1844  3189		       20 30 30 	      jsr	INCREMENT_MANTISSA
   1845  318c				   L3E4E
   1846  318c		       85 1f		      sta	ARGEXTENSION
   1847  318e		       20 1c 30 	      jsr	MAF
   1848  3191		       a5 28		      lda	FAC
   1849  3193		       c9 88		      cmp	#$88
   1850  3195		       90 03		      bcc	L3E5C
   1851  3197				   L3E59
   1852  3197		       20 02 2f 	      jsr	OUTOFRNG
   1853  319a				   L3E5C
   1854  319a		       20 d1 30 	      jsr	INT
   1855  319d		       a5 16		      lda	CHARAC
   1856  319f		       18		      clc
   1857  31a0		       69 81		      adc	#$81
   1858  31a2		       f0 f3		      beq	L3E59
   1859  31a4		       38		      sec
   1860  31a5		       e9 01		      sbc	#$01
   1861  31a7		       48		      pha
   1862  31a8		       a2 04		      ldx	#BYTES_FP
   1863  31aa				   L3E6C
   1864  31aa		       b5 2f		      lda	ARG,x
   1865  31ac		       b4 28		      ldy	FAC,x
   1866  31ae		       95 28		      sta	FAC,x
   1867  31b0		       94 2f		      sty	ARG,x
   1868  31b2		       ca		      dex
   1869  31b3		       10 f5		      bpl	L3E6C
   1870  31b5		       a5 1f		      lda	ARGEXTENSION
   1871  31b7		       85 35		      sta	FACEXTENSION
   1872  31b9		       20 c5 2c 	      jsr	FSUBT
   1873  31bc		       20 50 31 	      jsr	NEGOP
   1874  31bf		       a9 5f		      lda	#<POLY_EXP
   1875  31c1		       a0 31		      ldy	#>POLY_EXP
   1876  31c3		       20 e5 31 	      jsr	POLYNOMIAL
   1877  31c6		       a9 00		      lda	#$00
   1878  31c8		       85 34		      sta	SGNCPR
   1879  31ca		       68		      pla
   1880  31cb		       20 e7 2e 	      jsr	ADD_EXPONENTS1
   1881  31ce		       60		      rts
   1882  31cf
   1883  31cf							; ----------------------------------------------------------------------------
   1884  31cf							; ODD POLYNOMIAL SUBROUTINE
   1885  31cf							;
   1886  31cf							; F(X) = X * P(X^2)
   1887  31cf							;
   1888  31cf							; WHERE:  X IS VALUE IN FAC
   1889  31cf							;	Y,A POINTS AT COEFFICIENT TABLE
   1890  31cf							;	FIRST BYTE OF COEFF. TABLE IS N
   1891  31cf							;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
   1892  31cf							;
   1893  31cf							; P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
   1894  31cf							; ----------------------------------------------------------------------------
   1895  31cf				   POLYNOMIAL_ODD
   1896  31cf		       85 36		      sta	STRNG2
   1897  31d1		       84 37		      sty	STRNG2+1
   1898  31d3		       20 e0 2f 	      jsr	STORE_FAC_IN_TEMP1_ROUNDED
   1899  31d6		       a9 20		      lda	#TEMP1X
   1900  31d8		       20 6a 2e 	      jsr	FMULT
   1901  31db		       20 e9 31 	      jsr	SERMAIN
   1902  31de		       a9 20		      lda	#TEMP1X
   1903  31e0		       a0 00		      ldy	#$00
   1904  31e2		       4c 6a 2e 	      jmp	FMULT
   1905  31e5
   1906  31e5							; ----------------------------------------------------------------------------
   1907  31e5							; NORMAL POLYNOMIAL SUBROUTINE
   1908  31e5							;
   1909  31e5							; P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
   1910  31e5							;
   1911  31e5							; WHERE:  X IS VALUE IN FAC
   1912  31e5							;	Y,A POINTS AT COEFFICIENT TABLE
   1913  31e5							;	FIRST BYTE OF COEFF. TABLE IS N
   1914  31e5							;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
   1915  31e5							; ----------------------------------------------------------------------------
   1916  31e5				   POLYNOMIAL
   1917  31e5		       85 36		      sta	STRNG2
   1918  31e7		       84 37		      sty	STRNG2+1
   1919  31e9				   SERMAIN
   1920  31e9		       20 dd 2f 	      jsr	STORE_FAC_IN_TEMP2_ROUNDED
   1921  31ec		       b1 36		      lda	(STRNG2),y
   1922  31ee		       85 2d		      sta	SERLEN
   1923  31f0		       a4 36		      ldy	STRNG2
   1924  31f2		       c8		      iny
   1925  31f3		       98		      tya
   1926  31f4		       d0 02		      bne	L3EBA
   1927  31f6		       e6 37		      inc	STRNG2+1
   1928  31f8				   L3EBA
   1929  31f8		       85 36		      sta	STRNG2
   1930  31fa		       a4 37		      ldy	STRNG2+1
   1931  31fc				   L3EBE
   1932  31fc		       20 6a 2e 	      jsr	FMULT
   1933  31ff		       a5 36		      lda	STRNG2
   1934  3201		       a4 37		      ldy	STRNG2+1
   1935  3203		       18		      clc
   1936  3204		       69 04		      adc	#BYTES_FP
   1937  3206		       90 01		      bcc	L3ECB
   1938  3208		       c8		      iny
   1939  3209				   L3ECB
   1940  3209		       85 36		      sta	STRNG2
   1941  320b		       84 37		      sty	STRNG2+1
   1942  320d		       20 d9 2c 	      jsr	FADD
   1943  3210		       a9 24		      lda	#TEMP2
   1944  3212		       a0 00		      ldy	#$00
   1945  3214		       c6 2d		      dec	SERLEN
   1946  3216		       d0 e4		      bne	L3EBE
   1947  3218				   RTS19
   1948  3218		       60		      rts
   1949  3219					      ENDIF
------- FILE math/math.asm
------- FILE xcb3lib.asm
     25  3219							; String library
------- FILE string/string.asm LEVEL 3 PASS 4
      0  3219					      INCLUDE	"string/string.asm"
      1  3219		       1d 00	   STRING_WORKAREA EQU	STACKFRAME_TOP
      2  3219
      3  3219				  -	      IF	TARGET & pet
      4  3219				  -STRING_BUFFER1 EQU	$033A
      5  3219				  -STRING_BUFFER2 EQU	$039B
      6  3219					      ELSE
      7  3219		       03 3c	   STRING_BUFFER1 EQU	$033C
      8  3219		       03 9d	   STRING_BUFFER2 EQU	$039D
      9  3219					      ENDIF
     10  3219
------- FILE string/_fn.asm LEVEL 4 PASS 4
      0  3219					      INCLUDE	"string/_fn.asm"
      1  3219							; String functions
      2  3219
      3  3219							; DECLARE FUNCTION LEN AS BYTE (instr$ AS STRING) SHARED STATIC INLINE
      4  3219					      MAC	f_len_string
      5  3219					      ldx	SP
      6  3219					      inx
      7  3219					      lda	STRING_WORKAREA,x
      8  3219					      pha
      9  3219					      clc
     10  3219					      adc	SP
     11  3219					      adc	#1
     12  3219					      sta	SP
     13  3219					      ENDM
     14  3219
     15  3219							; DECLARE FUNCTION RIGHT$ AS STRING (instr$ AS STRING, length AS BYTE) SHARED STATIC INLINE
     16  3219					      MAC	f_right@_string_byte
     17  3219					      IF	!FPULL
     18  3219					      pla
     19  3219					      ENDIF
     20  3219					      import	I_STR_RIGHT
     21  3219					      jsr	STR_RIGHT
     22  3219					      ENDM		; @pull
     23  3219
     24  3219							; RIGHT$ function
     25  3219							; A - length
     26  3219				  -	      IFCONST	I_STR_RIGHT_IMPORTED
     27  3219				  -STR_RIGHT  SUBROUTINE
     28  3219				  -	      ldx	SP
     29  3219				  -	      inx
     30  3219				  -	      cmp	STRING_WORKAREA,x
     31  3219				  -	      bcs	.exit	; length >= string length, leave string as it is
     32  3219				  -			; X = X + len - A
     33  3219				  -	      sta	R0
     34  3219				  -	      txa
     35  3219				  -	      clc
     36  3219				  -	      adc	STRING_WORKAREA,x
     37  3219				  -	      sbc	R0
     38  3219				  -	      tax
     39  3219				  -	      inx
     40  3219				  -	      lda	R0
     41  3219				  -	      sta	STRING_WORKAREA,x
     42  3219				  -	      dex
     43  3219				  -	      stx	SP
     44  3219				  -.exit
     45  3219				  -	      rts
     46  3219					      ENDIF
     47  3219
     48  3219							; DECLARE FUNCTION LEFT$ AS STRING (instr$ AS STRING, length AS BYTE) SHARED STATIC INLINE
     49  3219					      MAC	f_left@_string_byte
     50  3219					      IF	!FPULL
     51  3219					      pla
     52  3219					      ENDIF
     53  3219					      import	I_STR_LEFT
     54  3219					      jsr	STR_LEFT
     55  3219					      ENDM		; @pull
     56  3219
     57  3219							; LEFT$ function
     58  3219							; A - length
     59  3219				  -	      IFCONST	I_STR_LEFT_IMPORTED
     60  3219				  -STR_LEFT   SUBROUTINE
     61  3219				  -	      ldx	SP
     62  3219				  -	      inx
     63  3219				  -	      cmp	STRING_WORKAREA,x
     64  3219				  -	      bcs	.end	; length >= str length, leave string as it is
     65  3219				  -			; Pointer to left part in R2
     66  3219				  -	      stx	R2
     67  3219				  -	      ldy	#>STRING_WORKAREA
     68  3219				  -	      sty	R2 + 1
     69  3219				  -			; Y = X + len - A + 1
     70  3219				  -	      sta	R0
     71  3219				  -	      txa
     72  3219				  -	      clc
     73  3219				  -	      adc	STRING_WORKAREA,x
     74  3219				  -	      sec
     75  3219				  -	      sbc	R0
     76  3219				  -			; Pointer to destination in R4
     77  3219				  -	      sta	R4
     78  3219				  -	      sta	SP
     79  3219				  -	      lda	#>STRING_WORKAREA
     80  3219				  -	      sta	R4 + 1
     81  3219				  -	      ldy	R0
     82  3219				  -	      bne	.loop
     83  3219				  -			; zero length
     84  3219				  -	      tya
     85  3219				  -	      sta	(R4),y
     86  3219				  -	      beq	.wquit
     87  3219				  -.loop
     88  3219				  -	      lda	(R2),y
     89  3219				  -	      sta	(R4),y
     90  3219				  -	      dey
     91  3219				  -	      bne	.loop
     92  3219				  -	      lda	R0
     93  3219				  -	      sta	(R4),y
     94  3219				  -			; write new pointer
     95  3219				  -.wquit
     96  3219				  -	      dec	SP
     97  3219				  -.end
     98  3219				  -	      rts
     99  3219					      ENDIF
    100  3219
    101  3219							; DECLARE FUNCTION MID$ AS STRING (instr$ AS STRING, pos AS BYTE, length AS BYTE) SHARED STATIC INLINE
    102  3219					      MAC	f_mid@_string_byte_byte
    103  3219					      IF	!FPULL
    104  3219					      pla
    105  3219					      ENDIF
    106  3219					      tay
    107  3219					      pla
    108  3219					      import	I_STR_MID
    109  3219					      jsr	STR_MID
    110  3219					      ENDM		; @pull
    111  3219
    112  3219							; MID$ function
    113  3219							; Y - length
    114  3219							; A - pos
    115  3219							; uses the equivalence MID$(x$,p,n)=LEFT$(RIGTH$(x$,LEN(x$)-p),n)
    116  3219				  -	      IFCONST	I_STR_MID_IMPORTED
    117  3219				  -	      import	I_STR_LEFT
    118  3219				  -	      import	I_STR_RIGHT
    119  3219				  -STR_MID    SUBROUTINE
    120  3219				  -	      sta	R0
    121  3219				  -			; LEN(x$)
    122  3219				  -	      ldx	SP
    123  3219				  -	      inx
    124  3219				  -	      lda	STRING_WORKAREA,x
    125  3219				  -	      sec
    126  3219				  -	      sbc	R0
    127  3219				  -	      bpl	.ok
    128  3219				  -			; P >= LEN(x$), return empty string
    129  3219				  -	      stx	R0
    130  3219				  -	      lda	STRING_WORKAREA,x
    131  3219				  -	      clc
    132  3219				  -	      adc	R0
    133  3219				  -	      tax
    134  3219				  -	      lda	#0
    135  3219				  -	      sta	STRING_WORKAREA,x
    136  3219				  -	      dex
    137  3219				  -	      stx	SP
    138  3219				  -	      rts
    139  3219				  -			; P < LEN(x$), do MID$
    140  3219				  -.ok
    141  3219				  -	      sty	R1
    142  3219				  -	      jsr	STR_RIGHT
    143  3219				  -	      lda	R1
    144  3219				  -	      jsr	STR_LEFT
    145  3219				  -	      rts
    146  3219					      ENDIF
    147  3219
    148  3219					      MAC	bytetostr_or_empty
    149  3219					      IF	!FPULL
    150  3219					      pla
    151  3219					      ENDIF
    152  3219					      bne	.nonz
    153  3219					      ldx	SP
    154  3219					      sta	STRING_WORKAREA,x
    155  3219					      bne	.q
    156  3219				   .nonz
    157  3219					      ldx	SP
    158  3219					      sta	STRING_WORKAREA,x
    159  3219					      dex
    160  3219					      lda	#1
    161  3219					      sta	STRING_WORKAREA,x
    162  3219					      dec	SP
    163  3219				   .q
    164  3219					      dec	SP
    165  3219					      ENDM		; @pull
    166  3219
    167  3219							; DECLARE FUNCTION CHR$ AS STRING (charcode AS BYTE) SHARED STATIC INLINE
    168  3219					      MAC	f_chr@_byte
    169  3219					      IF	!FPULL
    170  3219					      pla
    171  3219					      ENDIF
    172  3219					      ldx	SP
    173  3219					      sta	STRING_WORKAREA,x
    174  3219					      dex
    175  3219					      lda	#1
    176  3219					      sta	STRING_WORKAREA,x
    177  3219					      dec	SP
    178  3219					      dec	SP
    179  3219					      ENDM		; @pull
    180  3219
    181  3219							; DECLARE FUNCTION ASC AS BYTE (char$ AS STRING) SHARED STATIC INLINE
    182  3219					      MAC	f_asc_string
    183  3219					      ldx	SP
    184  3219					      inx
    185  3219					      lda	STRING_WORKAREA,x
    186  3219					      tay		; length
    187  3219					      bne	.nonzero
    188  3219					      pha		; zero
    189  3219					      beq	.q
    190  3219				   .nonzero
    191  3219					      inx
    192  3219					      lda	STRING_WORKAREA,x
    193  3219					      pha		; first char
    194  3219				   .q
    195  3219					      iny
    196  3219					      tya
    197  3219					      clc
    198  3219					      adc	SP
    199  3219					      sta	SP
    200  3219					      ENDM
    201  3219
    202  3219							; DECLARE FUNCTION LCASE$ AS STRING (instr$ AS STRING) SHARED STATIC INLINE
    203  3219					      MAC	f_lcase@_string
    204  3219					      import	I_STR_LCASE
    205  3219					      jsr	STR_LCASE
    206  3219					      ENDM
    207  3219
    208  3219				  -	      IFCONST	I_STR_LCASE_IMPORTED
    209  3219				  -STR_LCASE  SUBROUTINE
    210  3219				  -	      ldx	SP
    211  3219				  -	      inx
    212  3219				  -	      stx	.selfmod1 + 1
    213  3219				  -	      stx	.selfmod2 + 1
    214  3219				  -	      lda	STRING_WORKAREA,x
    215  3219				  -	      beq	.exit
    216  3219				  -	      tay
    217  3219				  -.loop
    218  3219				  -.selfmod1
    219  3219				  -	      lda	STRING_WORKAREA,y	; <- address self-modified
    220  3219				  -	      cmp	#$C1
    221  3219				  -	      bcc	.next
    222  3219				  -	      cmp	#$DB
    223  3219				  -	      bcs	.next
    224  3219				  -	      and	#%01111111
    225  3219				  -.selfmod2
    226  3219				  -	      sta	STRING_WORKAREA,y	; <- address self-modified
    227  3219				  -.next
    228  3219				  -	      dey
    229  3219				  -	      bne	.loop
    230  3219				  -.exit
    231  3219				  -	      rts
    232  3219					      ENDIF
    233  3219
    234  3219							; DECLARE FUNCTION UCASE$ AS STRING (instr$ AS STRING) SHARED STATIC INLINE
    235  3219					      MAC	f_ucase@_string
    236  3219					      import	I_STR_UCASE
    237  3219					      jsr	STR_UCASE
    238  3219					      ENDM
    239  3219
    240  3219				  -	      IFCONST	I_STR_UCASE_IMPORTED
    241  3219				  -STR_UCASE  SUBROUTINE
    242  3219				  -	      ldx	SP
    243  3219				  -	      inx
    244  3219				  -	      stx	.selfmod1 + 1
    245  3219				  -	      stx	.selfmod2 + 1
    246  3219				  -	      lda	STRING_WORKAREA,x
    247  3219				  -	      beq	.exit
    248  3219				  -	      tay
    249  3219				  -.loop
    250  3219				  -.selfmod1
    251  3219				  -	      lda	STRING_WORKAREA,y	; <- address self-modified
    252  3219				  -	      cmp	#$41
    253  3219				  -	      bcc	.next
    254  3219				  -	      cmp	#$5B
    255  3219				  -	      bcs	.next
    256  3219				  -	      ora	#%10000000
    257  3219				  -.selfmod2
    258  3219				  -	      sta	STRING_WORKAREA,y	; <- address self-modified
    259  3219				  -.next
    260  3219				  -	      dey
    261  3219				  -	      bne	.loop
    262  3219				  -.exit
    263  3219				  -	      rts
    264  3219					      ENDIF
    265  3219
    266  3219							; DECLARE FUNCTION VAL AS FLOAT (instr$ AS string) SHARED STATIC INLINE
    267  3219					      MAC	f_val_string
    268  3219					      ldx	SP
    269  3219					      inx
    270  3219					      stx	R0
    271  3219					      lda	#>STRING_WORKAREA
    272  3219					      sta	R0 + 1
    273  3219					      lda	STRING_WORKAREA,x
    274  3219					      sta	RA
    275  3219					      import	I_FPLIB
    276  3219					      import	I_FIN
    277  3219					      jsr	FIN
    278  3219					      import	I_STRSCRATCH
    279  3219					      jsr	STRSCRATCH
    280  3219					      pfac
    281  3219					      ENDM		; @push
    282  3219
    283  3219							; DECLARE FUNCTION STR$ AS STRING (number AS BYTE) SHARED STATIC INLINE
    284  3219					      MAC	f_str@_byte
    285  3219					      IF	!FPULL
    286  3219					      pla
    287  3219					      ENDIF
    288  3219					      import	I_STR_BTOS
    289  3219					      jsr	STR_BTOS
    290  3219					      ENDM		; @pull
    291  3219
    292  3219				  -	      IFCONST	I_STR_BTOS_IMPORTED
    293  3219				  -STR_BTOS   SUBROUTINE
    294  3219				  -	      ldx	#0
    295  3219				  -	      stx	R0	; string length
    296  3219				  -	      import	I_STDLIB_BYTE_TO_PETSCII
    297  3219				  -	      jsr	STDLIB_BYTE_TO_PETSCII
    298  3219				  -	      stx	R1
    299  3219				  -	      ldx	SP
    300  3219				  -	      sta	STRING_WORKAREA,x
    301  3219				  -	      dex
    302  3219				  -	      inc	R0
    303  3219				  -	      cpy	#$30	; '0'
    304  3219				  -	      beq	.1
    305  3219				  -	      dex
    306  3219				  -	      tya
    307  3219				  -	      sta	STRING_WORKAREA,x
    308  3219				  -	      inc	R0
    309  3219				  -	      inx
    310  3219				  -	      bne	.2	; bra
    311  3219				  -.1	      lda	R1
    312  3219				  -	      cmp	#$30	; '0'
    313  3219				  -	      beq	.3
    314  3219				  -.2	      lda	R1
    315  3219				  -	      sta	STRING_WORKAREA,x
    316  3219				  -	      inc	R0
    317  3219				  -	      lda	R0
    318  3219				  -	      cmp	#3
    319  3219				  -	      bne	.3
    320  3219				  -	      dex
    321  3219				  -.3	      lda	R0
    322  3219				  -	      cmp	#1
    323  3219				  -	      beq	.4
    324  3219				  -	      dex
    325  3219				  -.4
    326  3219				  -	      sta	STRING_WORKAREA,x
    327  3219				  -	      dex
    328  3219				  -	      stx	SP
    329  3219				  -	      rts
    330  3219					      ENDIF
    331  3219
    332  3219							; DECLARE FUNCTION STR$ AS STRING (number AS DECIMAL) OVERRIDE SHARED STATIC INLINE
    333  3219					      MAC	f_str@_decimal
    334  3219					      IF	!FPULL
    335  3219					      pla
    336  3219					      sta	R0
    337  3219					      pla
    338  3219					      sta	R0 + 1
    339  3219					      ELSE
    340  3219					      sta	R0 + 1
    341  3219					      sty	R0
    342  3219					      ENDIF
    343  3219					      import	I_STR_DTOS
    344  3219					      jsr	STR_DTOS
    345  3219					      ENDM		; @pull
    346  3219
    347  3219				  -	      IFCONST	I_STR_DTOS_IMPORTED
    348  3219				  -STR_DTOS
    349  3219				  -	      ldx	SP
    350  3219				  -	      ldy	#1
    351  3219				  -.loop
    352  3219				  -	      lda	R0,y
    353  3219				  -	      and	#%00001111
    354  3219				  -	      clc
    355  3219				  -	      adc	#$30
    356  3219				  -	      sta	STRING_WORKAREA,x
    357  3219				  -	      dex
    358  3219				  -	      lda	R0,y
    359  3219				  -	      lsr
    360  3219				  -	      lsr
    361  3219				  -	      lsr
    362  3219				  -	      lsr
    363  3219				  -	      clc
    364  3219				  -	      adc	#$30
    365  3219				  -	      sta	STRING_WORKAREA,x
    366  3219				  -	      dex
    367  3219				  -	      dey
    368  3219				  -	      bpl	.loop
    369  3219				  -.over
    370  3219				  -	      lda	#4
    371  3219				  -	      sta	STRING_WORKAREA,x
    372  3219				  -	      dex
    373  3219				  -	      stx	SP
    374  3219				  -	      rts
    375  3219					      ENDIF
    376  3219
    377  3219							; DECLARE FUNCTION STR$ AS STRING (number AS WORD) OVERRIDE SHARED STATIC INLINE
    378  3219					      MAC	f_str@_word
    379  3219					      IF	!FPULL
    380  3219					      pla
    381  3219					      sta	R2 + 1
    382  3219					      pla
    383  3219					      sta	R2
    384  3219					      ELSE
    385  3219					      sta	R2
    386  3219					      sty	R2 + 1
    387  3219					      ENDIF
    388  3219					      import	I_STR_WTOS
    389  3219					      ldx	#0
    390  3219					      jsr	STR_WTOS
    391  3219					      ENDM		; @pull
    392  3219
    393  3219							; DECLARE FUNCTION STR$ AS STRING (number AS INT) OVERRIDE SHARED STATIC INLINE
    394  3219					      MAC	f_str@_int
    395  3219					      IF	!FPULL
    396  3219					      pla
    397  3219					      sta	R2 + 1
    398  3219					      pla
    399  3219					      sta	R2
    400  3219					      ELSE
    401  3219					      sta	R2
    402  3219					      sty	R2 + 1
    403  3219					      ENDIF
    404  3219					      import	I_STR_WTOS
    405  3219					      ldx	#0
    406  3219					      lda	R2 + 1
    407  3219					      bpl	.pos
    408  3219					      twoscplint	R2
    409  3219					      inx
    410  3219				   .pos
    411  3219					      jsr	STR_WTOS
    412  3219					      ENDM		; @pull
    413  3219
    414  3219							; Convert word to string
    415  3219							; expects:
    416  3219							; number in R2
    417  3219							; X=1 if negative (but number already two's complemented)
    418  3219							; X=0 otherwise
    419  3219					      IFCONST	I_STR_WTOS_IMPORTED
    420  3219				   STR_WTOS   SUBROUTINE
    421  3219		       86 02		      stx	R0	; Total number of chars
    422  321b		       8a		      txa
    423  321c		       f0 03		      beq	.pos
    424  321e		       a9 2d		      lda	#$2d	; - sign
    425  3220		       48		      pha
    426  3221				   .pos
    427  3221		       a2 00		      ldx	#00
    428  3223		       86 0c		      stx	RA	; Number of digits
    429  3225				   .do
    430  3225		       a0 00		      ldy	#0
    431  3227							; Check if number < 10^n
    432  3227				   .do2
    433  3227		       a5 05		      lda	R2 + 1
    434  3229		       dd 6e 32 	      cmp.wx	str_pten_16 + 1
    435  322c		       d0 05		      bne	.1
    436  322e		       a5 04		      lda	R2
    437  3230		       dd 6d 32 	      cmp.wx	str_pten_16
    438  3233				   .1
    439  3233		       90 12		      bcc	.next
    440  3235				   .sub
    441  3235							; Count how many times 10^n can be subtracted
    442  3235		       a5 04		      lda	R2
    443  3237		       38		      sec
    444  3238		       fd 6d 32 	      sbc.wx	str_pten_16
    445  323b		       85 04		      sta	R2
    446  323d		       a5 05		      lda	R2 + 1
    447  323f		       fd 6e 32 	      sbc.wx	str_pten_16 + 1
    448  3242		       85 05		      sta	R2 + 1
    449  3244		       c8		      iny
    450  3245		       d0 e0		      bne	.do2
    451  3247				   .next
    452  3247							; Y now holds a decimal digit
    453  3247		       98		      tya
    454  3248		       05 0c		      ora	RA
    455  324a		       f0 09		      beq	.2
    456  324c		       98		      tya
    457  324d		       18		      clc
    458  324e		       69 30		      adc	#$30
    459  3250		       48		      pha
    460  3251		       e6 02		      inc	R0
    461  3253		       e6 0c		      inc	RA
    462  3255				   .2
    463  3255		       e8		      inx
    464  3256		       e8		      inx
    465  3257		       e8		      inx
    466  3258		       e0 0c		      cpx	#12
    467  325a		       d0 c9		      bne	.do
    468  325c		       a5 04		      lda	R2
    469  325e		       18		      clc
    470  325f		       69 30		      adc	#$30
    471  3261		       48		      pha
    472  3262		       e6 02		      inc	R0
    473  3264		       4c 79 32 	      jmp	STR_MOVE_REVSTR
    474  3267					      ENDIF
    475  3267
    476  3267							; DECLARE FUNCTION STR$ AS STRING (number AS LONG) OVERRIDE SHARED STATIC INLINE
    477  3267					      MAC	f_str@_long
    478  3267					      IF	!FPULL
    479  3267					      pla
    480  3267					      sta	R4 + 2
    481  3267					      pla
    482  3267					      sta	R4 + 1
    483  3267					      pla
    484  3267					      sta	R4
    485  3267					      ELSE
    486  3267					      sta	R4
    487  3267					      sty	R4 + 1
    488  3267					      stx	R4 + 2
    489  3267					      ENDIF
    490  3267					      import	I_STR_LTOS
    491  3267					      jsr	STR_LTOS
    492  3267					      ENDM		; @pull
    493  3267
    494  3267							; Convert long to string
    495  3267							; Number in R4
    496  3267				  -	      IFCONST	I_STR_LTOS_IMPORTED
    497  3267				  -STR_LTOS   SUBROUTINE
    498  3267				  -	      ldx	#0
    499  3267				  -	      stx	R0	; Total number of chars
    500  3267				  -	      stx	RA	; Number of digits
    501  3267				  -	      lda	R4 + 2
    502  3267				  -	      bpl	.do
    503  3267				  -	      lda	#$2d	; - sign
    504  3267				  -	      pha
    505  3267				  -	      inc	R0
    506  3267				  -	      twoscpllong	R4
    507  3267				  -.do
    508  3267				  -	      ldy	#0
    509  3267				  -			; Check if number < 10^n
    510  3267				  -.do2
    511  3267				  -	      lda	R4	; NUM1-NUM2
    512  3267				  -	      cmp.wx	str_pten_24
    513  3267				  -	      lda	R4 + 1
    514  3267				  -	      sbc.wx	str_pten_24 + 1
    515  3267				  -	      lda	R4 + 2
    516  3267				  -	      sbc.wx	str_pten_24 + 2
    517  3267				  -	      bcc	.next
    518  3267				  -.sub
    519  3267				  -			; Count how many times 10^n can be subtracted
    520  3267				  -	      lda	R4
    521  3267				  -	      sec
    522  3267				  -	      sbc.wx	str_pten_24
    523  3267				  -	      sta	R4
    524  3267				  -	      lda	R4 + 1
    525  3267				  -	      sbc.wx	str_pten_24 + 1
    526  3267				  -	      sta	R4 + 1
    527  3267				  -	      lda	R4 + 2
    528  3267				  -	      sbc.wx	str_pten_24 + 2
    529  3267				  -	      sta	R4 + 2
    530  3267				  -	      iny
    531  3267				  -	      bne	.do2
    532  3267				  -.next
    533  3267				  -			; Y now holds a decimal digit
    534  3267				  -	      tya
    535  3267				  -	      ora	RA
    536  3267				  -	      beq	.2
    537  3267				  -	      tya
    538  3267				  -	      clc
    539  3267				  -	      adc	#$30
    540  3267				  -	      pha
    541  3267				  -	      inc	R0
    542  3267				  -	      inc	RA
    543  3267				  -.2
    544  3267				  -	      inx
    545  3267				  -	      inx
    546  3267				  -	      inx
    547  3267				  -	      cpx	#18
    548  3267				  -	      bne	.do
    549  3267				  -			; Print last digit
    550  3267				  -	      lda	R4
    551  3267				  -	      clc
    552  3267				  -	      adc	#$30
    553  3267				  -	      pha
    554  3267				  -	      inc	R0
    555  3267				  -	      jmp	STR_MOVE_REVSTR
    556  3267					      ENDIF
    557  3267
    558  3267							; Powers of ten on 24 bits
    559  3267					      IFCONST	I_STR_WTOS_IMPORTED || I_STR_LTOS_IMPORTED
    560  3267				   str_pten_24
    561  3267		       40 42 0f 	      HEX	40 42 0F	;   1000000
    562  326a		       a0 86 01 	      HEX	A0 86 01	;    100000
    563  326d				   str_pten_16
    564  326d		       10 27 00 	      HEX	10 27 00	;     10000
    565  3270		       e8 03 00 	      HEX	E8 03 00	;	1000
    566  3273		       64 00 00 	      HEX	64 00 00	;	 100
    567  3276		       0a 00 00 	      HEX	0A 00 00	;	  10
    568  3279
    569  3279
    570  3279				   STR_MOVE_REVSTR SUBROUTINE
    571  3279							; Move reversed string on stack to string workarea
    572  3279							; Total number of chars in R0
    573  3279		       a5 02		      lda	R0
    574  327b		       85 04		      sta	R2	; R2 reused to save no of chars
    575  327d		       a6 0e		      ldx	SP
    576  327f		       c6 02		      dec	R0
    577  3281				   .loop
    578  3281		       68		      pla
    579  3282		       9d 00 1d 	      sta	STRING_WORKAREA,x
    580  3285		       ca		      dex
    581  3286		       c6 02		      dec	R0
    582  3288		       10 f7		      bpl	.loop
    583  328a		       a5 04		      lda	R2
    584  328c		       9d 00 1d 	      sta	STRING_WORKAREA,x
    585  328f		       ca		      dex
    586  3290		       86 0e		      stx	SP
    587  3292		       60		      rts
    588  3293					      ENDIF
    589  3293
    590  3293							; DECLARE FUNCTION STR$ AS STRING (number AS FLOAT) OVERRIDE SHARED STATIC INLINE
    591  3293					      MAC	f_str@_float
    592  3293					      plfloattofac
    593  3293					      import	I_FPLIB
    594  3293					      import	I_FOUT
    595  3293					      jsr	FOUT
    596  3293					      pstringvar	stack
    597  3293					      ENDM		; @pull
------- FILE string/string.asm
     12  3293
     13  3293							; Reset stack pointer
     14  3293					      MAC	spreset
     15  3293					      lda	#$ff
     16  3293					      sta	SP
     17  3293					      ENDM
     18  3293
     19  3293							; Push string to stack
     20  3293							; Allocating as many bytes as necessary
     21  3293					      MAC	pstringvar
     22  3293					      lda	#<{1}
     23  3293					      sta	R0
     24  3293					      lda	#>{1}
     25  3293					      sta	R0 + 1
     26  3293					      lda	{1}	; get string length
     27  3293					      import	I_STRMOV
     28  3293					      jsr	STRMOV
     29  3293					      ENDM
     30  3293
     31  3293							; Destination pointer = Stack pointer + {offset}
     32  3293					      MAC	stackptrtodestptr
     33  3293					      lda	RC	; Copy pointer
     34  3293					      clc
     35  3293					      adc	#{1}	; Add offset to pointer
     36  3293					      sta	R0
     37  3293					      lda	RC + 1
     38  3293					      adc	#0
     39  3293					      sta	R0 + 1
     40  3293					      ENDM
     41  3293
     42  3293							; Destination pointer = THIS pointer + {offset}
     43  3293					      MAC	thisptrtodestptr
     44  3293					      lda	TH	; Copy pointer
     45  3293					      clc
     46  3293					      adc	#{1}	; Add offset to pointer
     47  3293					      sta	R0
     48  3293					      lda	TH + 1
     49  3293					      adc	#0
     50  3293					      sta	R0 + 1
     51  3293					      ENDM
     52  3293
     53  3293							; Push dynamic string variable onto stack
     54  3293							; Var relative address in {1}
     55  3293					      MAC	pdynstringvar
     56  3293					      stackptrtodestptr	{1}
     57  3293					      ldy	#{1}
     58  3293					      lda	(RC),y	; get string length
     59  3293					      import	I_STRMOV
     60  3293					      jsr	STRMOV
     61  3293					      ENDM
     62  3293
     63  3293							; Pull string off of stack to variable
     64  3293							; Var address in {1}
     65  3293							; Max length (excluding length indicator) in {2} - The target var might be narrower
     66  3293					      MAC	plstringvar
     67  3293					      lda	#<{1}
     68  3293					      sta	R0
     69  3293					      lda	#>{1}
     70  3293					      sta	R0 + 1
     71  3293					      lda	#{2}
     72  3293					      import	I_STRREMOV
     73  3293					      jsr	STRREMOV
     74  3293					      ENDM
     75  3293
     76  3293							; Pull dynamic string on stack to variable
     77  3293							; Var relative address in {1}
     78  3293							; Max length (excluding length indicator) in {2} - The target var might be narrower
     79  3293					      MAC	pldynstringvar
     80  3293					      stackptrtodestptr	{1}
     81  3293					      lda	#{2}
     82  3293					      import	I_STRREMOV
     83  3293					      jsr	STRREMOV
     84  3293					      ENDM
     85  3293
     86  3293							; Push string of an array onto stack
     87  3293							; (indexed by a word)
     88  3293					      MAC	pstringarray
     89  3293					      getaddr	{1}
     90  3293					      ldy	#0
     91  3293					      lda	(R0),y	; get string length
     92  3293					      import	I_STRMOV
     93  3293					      jsr	STRMOV
     94  3293					      ENDM		; @pull
     95  3293
     96  3293							; Push string of an array onto stack
     97  3293							; (indexed by a byte)
     98  3293					      MAC	pstringarrayfast
     99  3293					      IF	!FPULL
    100  3293					      pla
    101  3293					      ENDIF
    102  3293					      tax
    103  3293					      clc
    104  3293					      adc	#<{1}	; R0 = {1} + A
    105  3293					      sta	R0
    106  3293					      lda	#>{1}
    107  3293					      adc	#0
    108  3293					      sta	R0 + 1
    109  3293					      lda	{1},x
    110  3293					      import	I_STRMOV
    111  3293					      jsr	STRMOV
    112  3293					      ENDM		; @pull
    113  3293
    114  3293							; Pull string off of stack and store in array
    115  3293							; (indexed by a word)
    116  3293							; Max length in {2}
    117  3293					      MAC	plstringarray
    118  3293					      getaddr	{1}
    119  3293					      lda	#{2}
    120  3293					      import	I_STRREMOV
    121  3293					      jsr	STRREMOV
    122  3293					      ENDM		; @pull
    123  3293
    124  3293							; Pull string off of stack and store in array
    125  3293							; (indexed by a byte)
    126  3293							; Max length in {2}
    127  3293					      MAC	plstringarrayfast
    128  3293					      IF	!FPULL
    129  3293					      pla
    130  3293					      ENDIF
    131  3293					      tax
    132  3293					      clc
    133  3293					      adc	#<{1}	; R0 = {1} + A
    134  3293					      sta	R0
    135  3293					      lda	#>{1}
    136  3293					      adc	#0
    137  3293					      sta	R0 + 1
    138  3293					      lda	#{2}
    139  3293					      import	I_STRREMOV
    140  3293					      jsr	STRREMOV
    141  3293					      ENDM		; @pull
    142  3293
    143  3293							; Push relative string variable (e.g this.something$)
    144  3293					      MAC	prelativestringvar
    145  3293					      thisptrtodestptr	{1}
    146  3293					      ldy	#{1}
    147  3293					      lda	(TH),y	; get string length
    148  3293					      import	I_STRMOV
    149  3293					      jsr	STRMOV
    150  3293					      ENDM
    151  3293
    152  3293							; Pull byte value and store in relative string variable
    153  3293							; (e.g this.something$)
    154  3293					      MAC	plrelativestringvar
    155  3293					      thisptrtodestptr	{1}
    156  3293					      lda	#{2}
    157  3293					      import	I_STRREMOV
    158  3293					      jsr	STRREMOV
    159  3293					      ENDM
    160  3293
    161  3293							; Move string on stack and update stack pointer
    162  3293							; Length in A
    163  3293							; String ptr in R0
    164  3293					      IFCONST	I_STRMOV_IMPORTED
    165  3293				   STRMOV     SUBROUTINE
    166  3293		       48		      pha		; save length
    167  3294		       a6 0e		      ldx	SP	; current stack pointer
    168  3296		       a8		      tay
    169  3297		       f0 09		      beq	.writelen
    170  3299				   .loop
    171  3299		       b1 02		      lda	(R0),y
    172  329b		       9d 00 1d 	      sta	STRING_WORKAREA,x
    173  329e		       ca		      dex
    174  329f		       88		      dey
    175  32a0		       d0 f7		      bne	.loop
    176  32a2				   .writelen
    177  32a2		       68		      pla		; restore length
    178  32a3		       9d 00 1d 	      sta	STRING_WORKAREA,x
    179  32a6		       ca		      dex
    180  32a7		       86 0e		      stx	SP	; new stack pointer
    181  32a9		       60		      rts
    182  32aa					      ENDIF
    183  32aa
    184  32aa					      IFCONST	I_STRREMOV_IMPORTED
    185  32aa							; Dest ptr to string in R0
    186  32aa							; Max length in A
    187  32aa				   STRREMOV   SUBROUTINE
    188  32aa		       48		      pha
    189  32ab		       a6 0e		      ldx	SP
    190  32ad		       e8		      inx
    191  32ae		       86 04		      stx	R2
    192  32b0		       bd 00 1d 	      lda	STRING_WORKAREA,x
    193  32b3		       18		      clc
    194  32b4		       65 04		      adc	R2
    195  32b6		       85 0e		      sta	SP
    196  32b8		       68		      pla
    197  32b9		       dd 00 1d 	      cmp	STRING_WORKAREA,x	; length of string on stack
    198  32bc		       90 03		      bcc	.skip
    199  32be		       bd 00 1d 	      lda	STRING_WORKAREA,x
    200  32c1				   .skip
    201  32c1							; Modify string length
    202  32c1		       a0 00		      ldy	#0
    203  32c3		       91 02		      sta	(R0),y
    204  32c5		       a8		      tay
    205  32c6		       f0 0f		      beq	.end
    206  32c8							; X = X + A
    207  32c8		       86 04		      stx	R2
    208  32ca		       18		      clc
    209  32cb		       65 04		      adc	R2
    210  32cd		       aa		      tax
    211  32ce				   .loop
    212  32ce		       bd 00 1d 	      lda	STRING_WORKAREA,x
    213  32d1		       91 02		      sta	(R0),y
    214  32d3		       ca		      dex
    215  32d4		       88		      dey
    216  32d5		       d0 f7		      bne	.loop
    217  32d7				   .end
    218  32d7		       60		      rts
    219  32d8					      ENDIF
    220  32d8
    221  32d8				  -	      IFCONST	I_STRREMOV_SC_IMPORTED
    222  32d8				  -			; Dest ptr to string in R0
    223  32d8				  -			; Max length in A
    224  32d8				  -			; Same as above but converts PETSCII to screencode
    225  32d8				  -			; and does not copy length indicator
    226  32d8				  -			; Leaves string length in R3
    227  32d8				  -STRREMOV_SC SUBROUTINE
    228  32d8				  -	      ldx	SP
    229  32d8				  -	      inx
    230  32d8				  -	      cmp	STRING_WORKAREA,x	; length of string on stack
    231  32d8				  -	      bcc	.skip
    232  32d8				  -	      lda	STRING_WORKAREA,x
    233  32d8				  -	      sta	R3
    234  32d8				  -.skip
    235  32d8				  -	      tay
    236  32d8				  -			; X = X + A
    237  32d8				  -	      stx	R2
    238  32d8				  -	      clc
    239  32d8				  -	      adc	R2
    240  32d8				  -	      tax
    241  32d8				  -	      stx	SP	; Move pointer to end of string
    242  32d8				  -	      dey
    243  32d8				  -	      bmi	.end
    244  32d8				  -.loop
    245  32d8				  -	      lda	STRING_WORKAREA,x
    246  32d8				  -	      import	I_PET2SC
    247  32d8				  -	      jsr	PET2SC
    248  32d8				  -	      sta	(R0),y
    249  32d8				  -	      dex
    250  32d8				  -	      dey
    251  32d8				  -	      bpl	.loop
    252  32d8				  -.end
    253  32d8				  -	      rts
    254  32d8					      ENDIF
    255  32d8
    256  32d8				  -	      IFCONST	I_PET2SC_IMPORTED
    257  32d8				  -			; PETSCII to screencode conversion
    258  32d8				  -			; By Mace
    259  32d8				  -PET2SC     SUBROUTINE
    260  32d8				  -	      cmp	#$20
    261  32d8				  -	      bcc	.ddRev
    262  32d8				  -	      cmp	#$60
    263  32d8				  -	      bcc	.dd1
    264  32d8				  -	      cmp	#$80
    265  32d8				  -	      bcc	.dd2
    266  32d8				  -	      cmp	#$a0
    267  32d8				  -	      bcc	.dd3
    268  32d8				  -	      cmp	#$c0
    269  32d8				  -	      bcc	.dd4
    270  32d8				  -	      cmp	#$ff
    271  32d8				  -	      bcc	.ddRev
    272  32d8				  -	      lda	#$7e
    273  32d8				  -	      bne	.ddEnd
    274  32d8				  -.dd2
    275  32d8				  -	      and	#$5f
    276  32d8				  -	      bne	.ddEnd
    277  32d8				  -.dd3
    278  32d8				  -	      ora	#$40
    279  32d8				  -	      bne	.ddEnd
    280  32d8				  -.dd4
    281  32d8				  -	      eor	#$c0
    282  32d8				  -	      bne	.ddEnd
    283  32d8				  -.dd1
    284  32d8				  -	      and	#$3f
    285  32d8				  -	      bpl	.ddEnd
    286  32d8				  -.ddRev
    287  32d8				  -	      eor	#$80
    288  32d8				  -.ddEnd
    289  32d8				  -	      rts
    290  32d8					      ENDIF
    291  32d8
    292  32d8				  -	      IFCONST	I_STRSCRATCH_IMPORTED
    293  32d8				  -			; Remove top string from stack without copying
    294  32d8				  -STRSCRATCH SUBROUTINE
    295  32d8				  -	      ldx	SP
    296  32d8				  -	      inx
    297  32d8				  -	      stx	R0
    298  32d8				  -	      lda	STRING_WORKAREA,x
    299  32d8				  -	      clc
    300  32d8				  -	      adc	R0
    301  32d8				  -	      sta	SP
    302  32d8				  -	      rts
    303  32d8					      ENDIF
    304  32d8
    305  32d8							; Concatenate top two strings on stack
    306  32d8					      MAC	addstring
    307  32d8					      import	I_STR_CONCAT
    308  32d8					      jsr	STR_CONCAT
    309  32d8					      ENDM
    310  32d8
    311  32d8				  -	      IFCONST	I_STR_CONCAT_IMPORTED
    312  32d8				  -STR_CONCAT SUBROUTINE
    313  32d8				  -			; Pull string2
    314  32d8				  -	      plstringvar	STRING_BUFFER2, 96
    315  32d8				  -			; Pull string1
    316  32d8				  -	      plstringvar	STRING_BUFFER1, 96
    317  32d8				  -			; Push string2
    318  32d8				  -	      pstringvar	STRING_BUFFER2
    319  32d8				  -			; Adjust pointer and push string2
    320  32d8				  -	      inc	SP
    321  32d8				  -	      pstringvar	STRING_BUFFER1
    322  32d8				  -			; Calculate and write total length
    323  32d8				  -	      lda	STRING_BUFFER1
    324  32d8				  -	      clc
    325  32d8				  -	      adc	STRING_BUFFER2
    326  32d8				  -	      ldx	SP
    327  32d8				  -	      inx
    328  32d8				  -	      sta	STRING_WORKAREA,x
    329  32d8				  -	      rts
    330  32d8					      ENDIF
    331  32d8
    332  32d8							; Returns pointer (XY) and length (A) to null-terminated
    333  32d8							; string converted from Pascal string on stack
    334  32d8					      MAC	strtonullterm
    335  32d8					      import	I_STR_TONULLTERM
    336  32d8					      jsr	STR_TONULLTERM
    337  32d8					      lda	R1
    338  32d8					      ldx	#<STRING_BUFFER1
    339  32d8					      ldy	#>STRING_BUFFER1
    340  32d8					      ENDM
    341  32d8
    342  32d8							; Converts Pascal string on stack to
    343  32d8							; null-terminated string at STRING_BUFFER1
    344  32d8							; saves string length in R1
    345  32d8				  -	      IFCONST	I_STR_TONULLTERM_IMPORTED
    346  32d8				  -STR_TONULLTERM SUBROUTINE
    347  32d8				  -	      ldx	SP
    348  32d8				  -	      inx
    349  32d8				  -	      lda	STRING_WORKAREA,x
    350  32d8				  -	      sta	R1
    351  32d8				  -	      tay
    352  32d8				  -	      lda	#0
    353  32d8				  -	      sta	STRING_BUFFER1,y
    354  32d8				  -			; X = X + Y + 1
    355  32d8				  -	      sty	R0
    356  32d8				  -	      txa
    357  32d8				  -	      clc
    358  32d8				  -	      adc	R0
    359  32d8				  -	      tax
    360  32d8				  -	      inx
    361  32d8				  -	      stx	SP	; point to next string
    362  32d8				  -.loop
    363  32d8				  -	      lda	STRING_WORKAREA,x
    364  32d8				  -	      sta	[STRING_BUFFER1 - 1],y
    365  32d8				  -	      dex
    366  32d8				  -	      dey
    367  32d8				  -	      bne	.loop
    368  32d8				  -	      rts
    369  32d8					      ENDIF
------- FILE xcb3lib.asm
     27  32d8							; Input-output library
------- FILE io/io.asm LEVEL 3 PASS 4
      0  32d8					      INCLUDE	"io/io.asm"
------- FILE io/_kernal.asm LEVEL 4 PASS 4
      0  32d8					      INCLUDE	"io/_kernal.asm"
      1  32d8		       ff d2	   KERNAL_CHROUT EQU	$FFD2
      2  32d8		       ff f0	   KERNAL_PLOT EQU	$FFF0
      3  32d8		       ff bd	   KERNAL_SETNAM EQU	$FFBD
      4  32d8		       ff ba	   KERNAL_SETLFS EQU	$FFBA
      5  32d8		       ff c0	   KERNAL_OPEN EQU	$FFC0
      6  32d8		       ff b7	   KERNAL_READST EQU	$FFB7
      7  32d8		       ff c3	   KERNAL_CLOSE EQU	$FFC3
      8  32d8		       ff e4	   KERNAL_GETIN EQU	$FFE4
      9  32d8		       ff cf	   KERNAL_CHRIN EQU	$FFCF
     10  32d8		       ff c6	   KERNAL_CHKIN EQU	$FFC6
     11  32d8		       ff c9	   KERNAL_CHKOUT EQU	$FFC9
     12  32d8		       ff cc	   KERNAL_CLRCHN EQU	$FFCC
     13  32d8		       ff d5	   KERNAL_LOAD EQU	$FFD5
     14  32d8		       ff d8	   KERNAL_SAVE EQU	$FFD8
     15  32d8		       00 90	   STATUS     EQU	$90	; KERNAL I/O STATUS
     16  32d8
     17  32d8							; Calls a KERNAL routine
     18  32d8							; Routine address in {1}
     19  32d8					      MAC	kerncall
     20  32d8					      jsr	{1}
     21  32d8					      ENDM
------- FILE io/io.asm
------- FILE io/_screen.asm LEVEL 4 PASS 4
      0  32d8					      INCLUDE	"io/_screen.asm"
      1  32d8				  -	      IF	TARGET == c64
      2  32d8				  -KERNAL_SCREEN_ADDR EQU	$0288
      3  32d8				  -KERNAL_HOME EQU	$E566
      4  32d8				  -SRVEC      EQU	$D9
      5  32d8				  -COLOR_RAM  EQU	$D800
      6  32d8					      ENDIF
      7  32d8
      8  32d8				  -	      IF	TARGET == c128
      9  32d8				  -KERNAL_SCREEN_ADDR EQU	$0A3B
     10  32d8				  -KERNAL_HOME EQU	$C150
     11  32d8				  -SRVEC      EQU	$E0
     12  32d8				  -COLOR_RAM  EQU	$D800
     13  32d8				  -C128_VM1   EQU	$0A2C
     14  32d8					      ENDIF
     15  32d8
     16  32d8				  -	      IF	TARGET & c264
     17  32d8				  -COLOR_RAM  EQU	$0800
     18  32d8					      ENDIF
     19  32d8
     20  32d8					      IF	TARGET & vic20
     21  32d8		       02 88	   KERNAL_SCREEN_ADDR EQU	$0288
     22  32d8		       96 00	   COLOR_RAM  EQU	$9600
     23  32d8				  -	      IF	TARGET == vic20_8k
     24  32d8				  -COLOR_RAM  EQU	$9400
     25  32d8					      ENDIF
     26  32d8					      ENDIF
     27  32d8
     28  32d8							; Various C-64 registers
     29  32d8		       d0 18	   VICII_MEMCONTROL EQU	$D018
     30  32d8		       dd 00	   CIA_DIRECTIONALR EQU	$DD00
     31  32d8		       d0 20	   VICII_BORDER EQU	$D020
     32  32d8		       d0 21	   VICII_BACKGROUND EQU	$D021
     33  32d8							; Various C264 registers
     34  32d8		       ff 0d	   TED_CRSR_LO EQU	$FF0D
     35  32d8		       ff 0c	   TED_CRSR_HI EQU	$FF0C
     36  32d8		       ff 19	   TED_BORDER EQU	$FF19
     37  32d8		       ff 15	   TED_BACKGROUND EQU	$FF15
     38  32d8							; Various VIC-20 registers
     39  32d8		       90 0f	   VICI_BORDER_BG EQU	$900F
     40  32d8
     41  32d8							; Print byte on stack as PETSCII string
     42  32d8					      MAC	printbyte
     43  32d8					      import	I_STDLIB_PRINT_BYTE
     44  32d8					      IF	!FPULL
     45  32d8					      pla
     46  32d8					      ENDIF
     47  32d8					      jsr	STDLIB_PRINT_BYTE
     48  32d8					      ENDM		; @pull
     49  32d8
     50  32d8							; Print int on stack as PETSCII string
     51  32d8					      MAC	printint
     52  32d8					      F_str@_int
     53  32d8					      printstring
     54  32d8					      ENDM		; @pull
     55  32d8
     56  32d8							; Print word on stack as PETSCII string
     57  32d8					      MAC	printword
     58  32d8					      F_str@_word
     59  32d8					      printstring
     60  32d8					      ENDM		; @pull
     61  32d8
     62  32d8							; Print word on stack as PETSCII string
     63  32d8					      MAC	printdecimal
     64  32d8					      import	I_STDLIB_PRINT_DECIMAL
     65  32d8					      IF	!FPULL
     66  32d8					      pla
     67  32d8					      sta	R2 + 1
     68  32d8					      pla
     69  32d8					      sta	R2
     70  32d8					      ELSE
     71  32d8					      sta	R2
     72  32d8					      sty	R2 + 1
     73  32d8					      ENDIF
     74  32d8					      jsr	STDLIB_PRINT_DECIMAL
     75  32d8					      ENDM		; @pull
     76  32d8
     77  32d8							; Print string in memory (pointer on stack)
     78  32d8					      MAC	printstaticstring
     79  32d8					      IF	!FPULL
     80  32d8					      pla
     81  32d8					      tay
     82  32d8					      pla
     83  32d8					      ENDIF
     84  32d8					      import	I_STDLIB_PRINTSTR
     85  32d8					      jsr	STDLIB_PRINTSTR
     86  32d8					      ENDM		; @pull
     87  32d8
     88  32d8							; Print string on string stack and pull it off
     89  32d8					      MAC	printstring
     90  32d8					      ldx	SP
     91  32d8					      inx
     92  32d8					      txa
     93  32d8					      ldy	#>STRING_WORKAREA
     94  32d8					      import	I_STDLIB_PRINTSTR
     95  32d8					      jsr	STDLIB_PRINTSTR
     96  32d8							; Move stack pointer
     97  32d8					      tya
     98  32d8					      clc
     99  32d8					      adc	SP
    100  32d8					      sta	SP
    101  32d8					      ENDM
    102  32d8
    103  32d8							; Print int on stack as PETSCII string
    104  32d8					      MAC	printlong
    105  32d8					      F_str@_long
    106  32d8					      printstring
    107  32d8					      ENDM		; @pull
    108  32d8
    109  32d8					      MAC	printfloat
    110  32d8					      import	I_FPLIB
    111  32d8					      import	I_FOUT
    112  32d8					      import	I_STDLIB_PRINTSTR
    113  32d8					      plfloattofac
    114  32d8					      jsr	FOUT
    115  32d8					      jsr	STDLIB_PRINTSTR
    116  32d8					      ENDM		; @pull
    117  32d8
    118  32d8							; Print tab character
    119  32d8					      MAC	printtab
    120  32d8					      import	I_STDLIB_TAB
    121  32d8					      jsr	STDLIB_TAB
    122  32d8					      ENDM
    123  32d8
    124  32d8							; Print a newline character
    125  32d8					      MAC	printnl
    126  32d8					      lda	#13
    127  32d8					      kerncall	KERNAL_CHROUT
    128  32d8					      ENDM
    129  32d8
    130  32d8							; Move cursor to next tab
    131  32d8				  -	      IFCONST	I_STDLIB_TAB_IMPORTED
    132  32d8				  -STDLIB_TAB SUBROUTINE
    133  32d8				  -	      sec
    134  32d8				  -	      kerncall	KERNAL_PLOT
    135  32d8				  -	      tya
    136  32d8				  -	      ldy	#$ff
    137  32d8				  -.1
    138  32d8				  -	      iny
    139  32d8				  -	      cmp.wy	.tabs
    140  32d8				  -	      bcs	.1
    141  32d8				  -	      cpy	#3
    142  32d8				  -	      bne	.2
    143  32d8				  -	      printnl
    144  32d8				  -	      rts
    145  32d8				  -.2	      lda.wy	.tabs
    146  32d8				  -	      tay
    147  32d8				  -	      clc
    148  32d8				  -	      kerncall	KERNAL_PLOT
    149  32d8				  -	      rts
    150  32d8				  -
    151  32d8				  -.tabs      HEX	0A 14 1E 28 00
    152  32d8					      ENDIF
    153  32d8
    154  32d8							; print petscii string
    155  32d8							; Pointer to string in AY
    156  32d8							; At the end Y holds chars printed + 1
    157  32d8					      IFCONST	I_STDLIB_PRINTSTR_IMPORTED
    158  32d8				   STDLIB_PRINTSTR SUBROUTINE
    159  32d8		       85 02		      sta	R0	; store string start low byte
    160  32da		       84 03		      sty	R0 + 1	; store string start high byte
    161  32dc		       a0 00		      ldy	#0
    162  32de		       b1 02		      lda	(R0),y	; string length
    163  32e0		       f0 10		      beq	.2
    164  32e2		       85 04		      sta	R2
    165  32e4		       c8		      iny
    166  32e5				   .1
    167  32e5		       b1 02		      lda	(R0),y	; get byte from string
      0  32e7					      kerncall	KERNAL_CHROUT
      1  32e7		       20 d2 ff 	      jsr	KERNAL_CHROUT
    169  32ea		       c8		      iny
    170  32eb		       c4 04		      cpy	R2
    171  32ed		       90 f6		      bcc	.1
    172  32ef		       f0 f4		      beq	.1
    173  32f1		       60		      rts
    174  32f2				   .2
    175  32f2		       c8		      iny
    176  32f3		       60		      rts
    177  32f4					      ENDIF
    178  32f4
    179  32f4							; convert byte to decimal petscii in YXA
    180  32f4					      IFCONST	I_STDLIB_BYTE_TO_PETSCII_IMPORTED
    181  32f4				   STDLIB_BYTE_TO_PETSCII SUBROUTINE
    182  32f4		       a0 2f		      ldy	#$2f
    183  32f6		       a2 3a		      ldx	#$3a
    184  32f8		       38		      sec
    185  32f9		       c8	   .1	      iny
    186  32fa		       e9 64		      sbc	#100
    187  32fc		       b0 fb		      bcs	.1
    188  32fe		       ca	   .2	      dex
    189  32ff		       69 0a		      adc	#10
    190  3301		       30 fb		      bmi	.2
    191  3303		       69 2f		      adc	#$2f
    192  3305		       60		      rts
    193  3306					      ENDIF
    194  3306
    195  3306							; print byte type as decimal
    196  3306					      IFCONST	I_STDLIB_PRINT_BYTE_IMPORTED
      0  3306					      import	I_STDLIB_BYTE_TO_PETSCII
      1  3306				   I_STDLIB_BYTE_TO_PETSCII_IMPORTED SET	1
    198  3306				   STDLIB_PRINT_BYTE SUBROUTINE
    199  3306		       a0 00		      ldy	#$00
    200  3308		       84 02		      sty	R0	; has a digit been printed?
    201  330a		       20 f4 32 	      jsr	STDLIB_BYTE_TO_PETSCII
    202  330d		       48		      pha
    203  330e		       98		      tya
    204  330f		       c9 30		      cmp	#$30
    205  3311		       f0 05		      beq	.skip
      0  3313					      kerncall	KERNAL_CHROUT
      1  3313		       20 d2 ff 	      jsr	KERNAL_CHROUT
    207  3316		       e6 02		      inc	R0
    208  3318				   .skip
    209  3318		       8a		      txa
    210  3319		       c9 30		      cmp	#$30
    211  331b		       d0 04		      bne	.printit
    212  331d		       a4 02		      ldy	R0
    213  331f		       f0 03		      beq	.skip2
    214  3321				   .printit
      0  3321					      kerncall	KERNAL_CHROUT
      1  3321		       20 d2 ff 	      jsr	KERNAL_CHROUT
    216  3324				   .skip2
    217  3324		       68		      pla
      0  3325					      kerncall	KERNAL_CHROUT
      1  3325		       20 d2 ff 	      jsr	KERNAL_CHROUT
    219  3328		       60		      rts
    220  3329					      ENDIF
    221  3329
    222  3329				  -	      IFCONST	I_STDLIB_PRINT_DECIMAL_IMPORTED
    223  3329				  -STDLIB_PRINT_DECIMAL SUBROUTINE
    224  3329				  -	      ldx	#1
    225  3329				  -.1
    226  3329				  -	      lda	R2,x
    227  3329				  -	      lsr
    228  3329				  -	      lsr
    229  3329				  -	      lsr
    230  3329				  -	      lsr
    231  3329				  -	      clc
    232  3329				  -	      adc	#$30
    233  3329				  -	      kerncall	KERNAL_CHROUT
    234  3329				  -	      lda	R2,x
    235  3329				  -	      and	#%00001111
    236  3329				  -	      adc	#$30
    237  3329				  -	      kerncall	KERNAL_CHROUT
    238  3329				  -	      dex
    239  3329				  -	      bpl	.1
    240  3329				  -	      rts
    241  3329					      ENDIF
    242  3329
    243  3329					      MAC	locate
    244  3329					      IF	!FPULL
    245  3329					      pla
    246  3329					      ENDIF
    247  3329					      tax
    248  3329					      pla
    249  3329					      tay
    250  3329					      clc
    251  3329					      kerncall	KERNAL_PLOT
    252  3329					      ENDM		; @pull
    253  3329
    254  3329							; DECLARE FUNCTION CSRLIN AS BYTE () SHARED STATIC INLINE
    255  3329					      MAC	f_csrlin
    256  3329					      sec
    257  3329					      kerncall	KERNAL_PLOT
    258  3329					      txa
    259  3329					      IF	!FPUSH
    260  3329					      pha
    261  3329					      ENDIF
    262  3329					      ENDM		; @push
    263  3329
    264  3329							;DECLARE FUNCTION POS AS BYTE () SHARED STATIC INLINE
    265  3329					      MAC	f_pos
    266  3329					      sec
    267  3329					      kerncall	KERNAL_PLOT
    268  3329					      tya
    269  3329					      IF	!FPUSH
    270  3329					      pha
    271  3329					      ENDIF
    272  3329					      ENDM		; @push
    273  3329
    274  3329							; [Color,] Char, Col, Row pushed on stack
    275  3329							; {1} = 1 color was pushed
    276  3329					      MAC	charat
    277  3329					      IF	!FPULL
    278  3329					      pla
    279  3329					      ENDIF
    280  3329					      import	I_CALC_SCRROWPTR
    281  3329					      jsr	CALC_SCRROWPTR
    282  3329					      pla
    283  3329					      tay
    284  3329					      pla
    285  3329					      sta	(R0),y
    286  3329					      IF	{1} == 1	; Color was provided
    287  3329					      pla
    288  3329					      IF	(TARGET & pet) == 0
    289  3329					      tax
    290  3329					      lda	R0 + 1
    291  3329					      sec
    292  3329					      IF	TARGET & c264
    293  3329					      sbc	#$0C
    294  3329					      ELSE
    295  3329					      sbc	KERNAL_SCREEN_ADDR
    296  3329					      ENDIF
    297  3329					      clc
    298  3329					      adc	#>COLOR_RAM
    299  3329					      sta	R0 + 1
    300  3329					      txa
    301  3329					      sta	(R0),y
    302  3329					      ENDIF
    303  3329					      ENDIF
    304  3329					      ENDM		; @pull
    305  3329
    306  3329							; [Color,] Col, Row pushed on stack
    307  3329							; String on string stack
    308  3329					      MAC	textat
    309  3329					      IF	!FPULL
    310  3329					      pla
    311  3329					      ENDIF
    312  3329					      import	I_CALC_SCRROWPTR
    313  3329					      jsr	CALC_SCRROWPTR
    314  3329					      pla
    315  3329					      clc
    316  3329					      adc	R0
    317  3329					      sta	R0
    318  3329					      bcc	.2
    319  3329					      inc	R0 + 1
    320  3329				   .2
    321  3329					      lda	#$60
    322  3329					      import	I_STRREMOV_SC
    323  3329					      jsr	STRREMOV_SC
    324  3329					      IF	{1} == 1	; Color was provided
    325  3329					      pla
    326  3329					      IF	(TARGET & pet) == 0
    327  3329					      tax
    328  3329					      lda	R0 + 1
    329  3329					      sec
    330  3329					      IF	TARGET & c264
    331  3329					      sbc	#$0C	; high byte is always 0C on plus4
    332  3329					      ELSE
    333  3329					      sbc	KERNAL_SCREEN_ADDR
    334  3329					      ENDIF
    335  3329					      clc
    336  3329					      adc	#>COLOR_RAM
    337  3329					      sta	R0 + 1
    338  3329					      lda	R3
    339  3329					      tay
    340  3329					      dey
    341  3329					      txa
    342  3329				   .loop
    343  3329					      sta	(R0),y
    344  3329					      dey
    345  3329					      bpl	.loop
    346  3329					      ENDIF
    347  3329					      ENDIF
    348  3329					      ENDM		; @pull
    349  3329
    350  3329							; Calculates a pointer to screen row
    351  3329							; Row number in A
    352  3329							; Outputs pointer in R0
    353  3329				  -	      IFCONST	I_CALC_SCRROWPTR_IMPORTED
    354  3329				  -CALC_SCRROWPTR SUBROUTINE
    355  3329				  -			; 22-column screen
    356  3329				  -	      IF	TARGET & vic20
    357  3329				  -	      REPEAT	2
    358  3329				  -	      asl
    359  3329				  -	      REPEND
    360  3329				  -	      tax		; A * 4
    361  3329				  -	      sta	R0
    362  3329				  -	      lda	#0
    363  3329				  -	      sta	R0 + 1
    364  3329				  -	      REPEAT	2
    365  3329				  -	      asl	R0
    366  3329				  -	      rol	R0 + 1
    367  3329				  -	      REPEND		; A * 16
    368  3329				  -	      txa
    369  3329				  -	      clc
    370  3329				  -	      adc	R0
    371  3329				  -	      sta	R0
    372  3329				  -	      lda	#0
    373  3329				  -	      adc	R0 + 1
    374  3329				  -	      sta	R0 + 1
    375  3329				  -	      txa
    376  3329				  -	      lsr
    377  3329				  -	      clc
    378  3329				  -	      adc	R0
    379  3329				  -	      sta	R0
    380  3329				  -	      lda	#0
    381  3329				  -	      adc	R0 + 1
    382  3329				  -			; 40 or 80-column screen
    383  3329				  -	      ELSE
    384  3329				  -	      REPEAT	3
    385  3329				  -	      asl
    386  3329				  -	      REPEND
    387  3329				  -	      pha		; A * 8
    388  3329				  -	      sta	R0
    389  3329				  -	      lda	#0
    390  3329				  -	      sta	R0 + 1
    391  3329				  -	      REPEAT	2
    392  3329				  -	      asl	R0
    393  3329				  -	      rol	R0 + 1
    394  3329				  -	      REPEND		; A * 32
    395  3329				  -	      pla
    396  3329				  -			; A * 32 + A * 8 = A * 40
    397  3329				  -	      clc
    398  3329				  -	      adc	R0
    399  3329				  -	      sta	R0
    400  3329				  -	      lda	#$00
    401  3329				  -	      adc	R0 + 1
    402  3329				  -	      IF	TARGET == pet8032	; 80-column PET
    403  3329				  -	      sta	R0 + 1
    404  3329				  -	      asl	R0
    405  3329				  -	      rol	R0 + 1
    406  3329				  -	      lda	R0 + 1
    407  3329				  -	      ENDIF
    408  3329				  -	      ENDIF
    409  3329				  -	      IF	TARGET & pet
    410  3329				  -	      adc	#$80	; high byte is always 08 on a PET
    411  3329				  -	      ENDIF
    412  3329				  -	      IF	TARGET & c264
    413  3329				  -	      adc	#$0c	; high byte is always 0C on plus4
    414  3329				  -	      ENDIF
    415  3329				  -	      IF	(TARGET == c64) || (TARGET == c128) || (TARGET & vic20)
    416  3329				  -	      adc	KERNAL_SCREEN_ADDR
    417  3329				  -	      ENDIF
    418  3329				  -	      sta	R0 + 1
    419  3329				  -	      rts
    420  3329					      ENDIF
    421  3329
    422  3329							; Set Video Matrix Base Address
    423  3329					      MAC	screen
    424  3329					      IF	!FPULL
    425  3329					      pla
    426  3329					      ENDIF
    427  3329							; This command has only effect on the C64/C128
    428  3329					      IF	TARGET == c64 || TARGET == c128
    429  3329					      asl
    430  3329					      asl
    431  3329					      sta	KERNAL_SCREEN_ADDR
    432  3329					      pha
    433  3329					      lda	CIA_DIRECTIONALR
    434  3329					      and	#%00000011
    435  3329					      eor	#%00000011
    436  3329					      REPEAT	6
    437  3329					      asl
    438  3329					      REPEND
    439  3329					      adc	KERNAL_SCREEN_ADDR
    440  3329					      sta	KERNAL_SCREEN_ADDR
    441  3329					      pla
    442  3329					      asl
    443  3329					      asl
    444  3329					      sta	R0
    445  3329					      lda	VICII_MEMCONTROL
    446  3329					      and	#%00001111
    447  3329					      ora	R0
    448  3329					      sta	VICII_MEMCONTROL
    449  3329					      IF	TARGET == c64
    450  3329					      import	I_RESET_SCRVECTORS
    451  3329					      jsr	RESET_SCRVECTORS
    452  3329					      ELSE
    453  3329					      jsr	$CA24
    454  3329					      jsr	KERNAL_HOME
    455  3329					      ENDIF
    456  3329					      ENDIF
    457  3329					      ENDM		; @pull
    458  3329
    459  3329				  -	      IFCONST	I_RESET_SCRVECTORS_IMPORTED
    460  3329				  -RESET_SCRVECTORS SUBROUTINE
    461  3329				  -	      lda	KERNAL_SCREEN_ADDR
    462  3329				  -	      ora	#$80
    463  3329				  -	      tay
    464  3329				  -	      lda	#0
    465  3329				  -	      tax
    466  3329				  -.loop
    467  3329				  -	      sty	SRVEC,x
    468  3329				  -	      clc
    469  3329				  -	      adc	#$28
    470  3329				  -	      bcc	.skip
    471  3329				  -	      iny
    472  3329				  -.skip
    473  3329				  -	      inx
    474  3329				  -	      cpx	#$1a
    475  3329				  -	      bne	.loop
    476  3329				  -	      lda	#$ff
    477  3329				  -	      sta	SRVEC,x
    478  3329				  -	      jmp	KERNAL_HOME
    479  3329					      ENDIF
    480  3329
    481  3329					      MAC	border
    482  3329
    483  3329					      IF	!FPULL
    484  3329					      pla
    485  3329					      ENDIF
    486  3329
    487  3329					      IF	TARGET == c64 || TARGET == c128
    488  3329					      sta	VICII_BORDER
    489  3329					      ENDIF
    490  3329
    491  3329					      IF	TARGET & vic20
    492  3329					      sta	R0
    493  3329					      lda	VICI_BORDER_BG
    494  3329					      and	#%11111000
    495  3329					      ora	R0
    496  3329					      sta	VICI_BORDER_BG
    497  3329					      ENDIF
    498  3329
    499  3329					      IF	TARGET & c264
    500  3329					      sta	R0
    501  3329					      pla
    502  3329					      asl
    503  3329					      asl
    504  3329					      asl
    505  3329					      asl
    506  3329					      ora	R0
    507  3329					      sta	TED_BORDER
    508  3329					      ENDIF
    509  3329
    510  3329					      ENDM		; @fpull
    511  3329
    512  3329					      MAC	background
    513  3329
    514  3329					      IF	!FPULL
    515  3329					      pla
    516  3329					      ENDIF
    517  3329
    518  3329					      IF	TARGET == c64 || TARGET == c128
    519  3329					      sta	VICII_BACKGROUND
    520  3329					      ENDIF
    521  3329
    522  3329					      IF	TARGET & vic20
    523  3329					      asl
    524  3329					      asl
    525  3329					      asl
    526  3329					      asl
    527  3329					      sta	R0
    528  3329					      lda	VICI_BORDER_BG
    529  3329					      and	#%00001111
    530  3329					      ora	R0
    531  3329					      sta	VICI_BORDER_BG
    532  3329					      ENDIF
    533  3329
    534  3329					      IF	TARGET & c264
    535  3329					      sta	R0
    536  3329					      pla
    537  3329					      asl
    538  3329					      asl
    539  3329					      asl
    540  3329					      asl
    541  3329					      ora	R0
    542  3329					      sta	TED_BACKGROUND
    543  3329					      ENDIF
    544  3329
    545  3329					      ENDM		; @fpull
------- FILE io/io.asm
------- FILE io/_file.asm LEVEL 4 PASS 4
      0  3329					      INCLUDE	"io/_file.asm"
      1  3329							; Calls SETNAM with string on stack
      2  3329							; {1} = 0 name is empty
      3  3329							; {1} = 1 name is not empty
      4  3329					      MAC	setnam
      5  3329					      IF	{1} == 1
      6  3329					      ldx	SP
      7  3329					      inx
      8  3329					      lda	STRING_WORKAREA,x
      9  3329					      inx
     10  3329					      ldy	#>STRING_WORKAREA
     11  3329					      ELSE
     12  3329					      lda	#$00	; no filename
     13  3329					      tax
     14  3329					      tay
     15  3329					      ENDIF
     16  3329					      kerncall	KERNAL_SETNAM
     17  3329					      IF	{1} == 1
     18  3329					      import	I_STRSCRATCH
     19  3329					      jsr	STRSCRATCH
     20  3329					      ENDIF
     21  3329					      ENDM
     22  3329
     23  3329					      MAC	setlfs
     24  3329					      pla
     25  3329					      tay
     26  3329					      pla
     27  3329					      tax
     28  3329					      pla
     29  3329					      kerncall	KERNAL_SETLFS
     30  3329					      ENDM
     31  3329
     32  3329					      MAC	open
     33  3329					      import	I_RUNTIME_ERROR
     34  3329					      kerncall	KERNAL_OPEN
     35  3329					      bcc	.ok
     36  3329					      jmp	RUNTIME_ERROR
     37  3329				   .ok
     38  3329					      ENDM
     39  3329
     40  3329					      MAC	close
     41  3329					      IF	!FPULL
     42  3329					      pla
     43  3329					      ENDIF
     44  3329					      kerncall	KERNAL_CLOSE
     45  3329					      ENDM		; @pull
     46  3329
     47  3329							; GET#
     48  3329							; logical file# on stack
     49  3329							; returns char on stack
     50  3329					      MAC	get_hash
     51  3329					      IF	!FPULL
     52  3329					      pla
     53  3329					      ENDIF
     54  3329					      tax
     55  3329					      kerncall	KERNAL_CHKIN
     56  3329					      kerncall	KERNAL_CHRIN
     57  3329					      pha
     58  3329					      kerncall	KERNAL_CLRCHN
     59  3329					      ENDM		; @pull
     60  3329
     61  3329					      MAC	f_st
     62  3329					      jsr	KERNAL_READST
     63  3329					      IF	!FPUSH
     64  3329					      pha
     65  3329					      ENDIF
     66  3329					      ENDM		; @push
     67  3329
     68  3329							; INPUT#
     69  3329							; Output on string stack
     70  3329					      MAC	input_hash
     71  3329					      import	I_STRREAD
     72  3329					      jsr	I_STRREAD
     73  3329					      ENDM
     74  3329
     75  3329							; Set file as default input
     76  3329							; Call before input#, read# commands
     77  3329					      MAC	chkin
     78  3329					      ldx	{1}
     79  3329					      kerncall	KERNAL_CHKIN
     80  3329					      ENDM
     81  3329
     82  3329							; Set file as default output
     83  3329							; Call before print#, write# commands
     84  3329					      MAC	chkout
     85  3329					      ldx	{1}
     86  3329					      kerncall	KERNAL_CHKOUT
     87  3329					      ENDM
     88  3329
     89  3329							; Restore default input/output to keyboard/screen.
     90  3329							; Call after input# and print# commands
     91  3329					      MAC	clrchn
     92  3329					      kerncall	KERNAL_CLRCHN
     93  3329					      ENDM
     94  3329
     95  3329							; WRITE# (numeric or udt)
     96  3329							; value on stack (pushed first)
     97  3329							; logical file# in R9
     98  3329							; byte length in {1}
     99  3329					      MAC	write
    100  3329					      ldx	#{1}
    101  3329					      import	I_BINWRITE
    102  3329					      jsr	I_BINWRITE
    103  3329					      ENDM
    104  3329
    105  3329							; Writes arbitrary number of bytes to file
    106  3329							; logical file # in R9
    107  3329							; number of bytes in X
    108  3329							; data on stack
    109  3329				  -	      IFCONST	I_BINWRITE_IMPORTED
    110  3329				  -I_BINWRITE SUBROUTINE
    111  3329				  -			; save return address
    112  3329				  -	      pla
    113  3329				  -	      sta	RA
    114  3329				  -	      pla
    115  3329				  -	      sta	RB
    116  3329				  -.loop
    117  3329				  -	      pla
    118  3329				  -	      kerncall	KERNAL_CHROUT
    119  3329				  -	      dex
    120  3329				  -	      bne	.loop
    121  3329				  -			; restore return address
    122  3329				  -	      lda	RB
    123  3329				  -	      pha
    124  3329				  -	      lda	RA
    125  3329				  -	      pha
    126  3329				  -	      rts
    127  3329					      ENDIF
    128  3329
    129  3329							; READ# (numeric or udt)
    130  3329							; target address pushed on stack
    131  3329							; byte length in {1}
    132  3329					      MAC	read
    133  3329					      pla
    134  3329					      tax
    135  3329					      pla
    136  3329					      ldy	#{1}
    137  3329					      import	I_BINREAD
    138  3329					      jsr	I_BINREAD
    139  3329					      ENDM
    140  3329
    141  3329							; Restores arbitrary number of bytes from file
    142  3329							; Destination ptr in A/X
    143  3329							; Number of bytes in Y
    144  3329				  -	      IFCONST	I_BINREAD_IMPORTED
    145  3329				  -I_BINREAD  SUBROUTINE
    146  3329				  -	      sta	R0
    147  3329				  -	      stx	R0 + 1
    148  3329				  -.loop
    149  3329				  -	      dey
    150  3329				  -	      bmi	.q
    151  3329				  -	      kerncall	KERNAL_CHRIN
    152  3329				  -	      sta	(R0),y
    153  3329				  -	      jmp	.loop
    154  3329				  -.q
    155  3329				  -	      rts
    156  3329					      ENDIF
    157  3329
    158  3329							; Output single character to opened file
    159  3329							; {1} - char
    160  3329					      MAC	chrout
    161  3329					      lda	#{1}
    162  3329					      kerncall	KERNAL_CHROUT
    163  3329					      ENDM
    164  3329
    165  3329							; PRINT# (string)
    166  3329							; string on string stack
    167  3329					      MAC	print_hash
    168  3329					      import	I_STRWRITE
    169  3329					      jsr	I_STRWRITE
    170  3329					      ENDM
    171  3329
    172  3329							; Load routine
    173  3329							; load 1: load at address stored in file
    174  3329							; load 0: load at a specified address
    175  3329					      MAC	load
    176  3329					      IF	USEIRQ == 1
    177  3329					      jsr	IRQRESET
    178  3329					      ENDIF
    179  3329							; get address
    180  3329					      IF	{1} == 0
    181  3329					      pla
    182  3329					      tay
    183  3329					      pla
    184  3329					      tax
    185  3329					      ENDIF
    186  3329					      lda	#$00
    187  3329					      kerncall	KERNAL_LOAD
    188  3329					      bcc	.q
    189  3329					      import	I_RUNTIME_ERROR
    190  3329					      jmp	RUNTIME_ERROR
    191  3329				   .q
    192  3329					      IF	USEIRQ == 1
    193  3329					      jsr	IRQSETUP
    194  3329					      ENDIF
    195  3329					      ENDM
    196  3329
    197  3329							; Save routine
    198  3329					      MAC	save
    199  3329							; get start address
    200  3329					      IF	USEIRQ == 1
    201  3329					      jsr	IRQRESET
    202  3329					      ENDIF
    203  3329					      pla
    204  3329					      sta	R0 + 1
    205  3329					      pla
    206  3329					      sta	R0
    207  3329					      pla
    208  3329					      tay
    209  3329					      pla
    210  3329					      tax
    211  3329					      lda	#R0
    212  3329					      kerncall	KERNAL_SAVE
    213  3329					      bcc	.q
    214  3329					      import	I_RUNTIME_ERROR
    215  3329					      jmp	RUNTIME_ERROR
    216  3329				   .q
    217  3329					      IF	USEIRQ == 1
    218  3329					      jsr	IRQSETUP
    219  3329					      ENDIF
    220  3329					      ENDM
    221  3329
    222  3329							; Read string from file
    223  3329							; logical file no in A
    224  3329				  -	      IFCONST	I_STRREAD_IMPORTED
    225  3329				  -I_STRREAD  SUBROUTINE
    226  3329				  -	      ldx	#0
    227  3329				  -	      stx	R0	; Quote off
    228  3329				  -.loop
    229  3329				  -	      kerncall	KERNAL_CHRIN
    230  3329				  -	      pha
    231  3329				  -	      kerncall	KERNAL_READST
    232  3329				  -	      beq	.ok
    233  3329				  -	      pla
    234  3329				  -	      jmp	.over
    235  3329				  -.ok
    236  3329				  -	      pla
    237  3329				  -			; Is it <EOL> ?
    238  3329				  -	      cmp	#$0d
    239  3329				  -	      beq	.over
    240  3329				  -			; Is it '"' ?
    241  3329				  -	      cmp	#$22
    242  3329				  -	      bne	.1
    243  3329				  -	      lda	R0
    244  3329				  -	      eor	#$ff
    245  3329				  -	      sta	R0
    246  3329				  -	      jmp	.loop
    247  3329				  -.1
    248  3329				  -			; Is it ',' and quote off ?
    249  3329				  -	      cmp	#$2c
    250  3329				  -	      bne	.2
    251  3329				  -	      ldy	R0
    252  3329				  -	      beq	.over
    253  3329				  -.2
    254  3329				  -	      sta	[STRING_BUFFER1 + 1],x
    255  3329				  -	      inx
    256  3329				  -	      cpx	#95
    257  3329				  -	      bne	.loop
    258  3329				  -.over
    259  3329				  -	      stx	STRING_BUFFER1
    260  3329				  -	      pstringvar	STRING_BUFFER1
    261  3329				  -	      rts
    262  3329					      ENDIF
    263  3329
    264  3329							; Write string to file
    265  3329							; Logical file no in X
    266  3329							; String on string stack
    267  3329				  -	      IFCONST	I_STRWRITE_IMPORTED
    268  3329				  -I_STRWRITE SUBROUTINE
    269  3329				  -	      ldx	SP
    270  3329				  -	      inx
    271  3329				  -	      lda	STRING_WORKAREA,x
    272  3329				  -	      sta	R2
    273  3329				  -	      inx
    274  3329				  -	      stx	R0
    275  3329				  -	      lda	#>STRING_WORKAREA
    276  3329				  -	      sta	R0 + 1
    277  3329				  -	      ldy	#0
    278  3329				  -.loop
    279  3329				  -	      lda	(R0),y
    280  3329				  -	      kerncall	KERNAL_CHROUT
    281  3329				  -	      iny
    282  3329				  -	      cpy	R2
    283  3329				  -	      bne	.loop
    284  3329				  -.q
    285  3329				  -	      kerncall	KERNAL_CHROUT
    286  3329				  -	      rts
    287  3329					      ENDIF
    288  3329
    289  3329							; Read disk status
    290  3329							; Partly taken from
    291  3329							; https://codebase64.org/doku.php?id=base:reading_the_error_channel_of_a_disk_drive
    292  3329				  -	      IFCONST	I_IO_READST_IMPORTED
    293  3329				  -IO_READST  SUBROUTINE
    294  3329				  -	      lda	#0	; no filename
    295  3329				  -	      tax
    296  3329				  -	      tay
    297  3329				  -	      sta	R0	; will hold status code
    298  3329				  -	      kerncall	KERNAL_SETNAM
    299  3329				  -	      lda	#15	; file number 15
    300  3329				  -	      ldx	$BA	; last used device number
    301  3329				  -	      bne	.skip
    302  3329				  -	      ldx	#8	; default to device 8
    303  3329				  -.skip
    304  3329				  -	      ldy	#15	; secondary address 15 (error channel)
    305  3329				  -	      kerncall	KERNAL_SETLFS
    306  3329				  -	      kerncall	KERNAL_OPEN
    307  3329				  -	      bcs	.error
    308  3329				  -	      ldx	#15	; filenumber 15
    309  3329				  -	      kerncall	KERNAL_CHKIN
    310  3329				  -	      kerncall	KERNAL_CHRIN	; first decimal byte in A
    311  3329				  -	      sec
    312  3329				  -	      sbc	#$30
    313  3329				  -	      asl		; multiply by 10
    314  3329				  -	      sta	R0
    315  3329				  -	      asl
    316  3329				  -	      asl
    317  3329				  -	      clc
    318  3329				  -	      adc	R0
    319  3329				  -	      sta	R0
    320  3329				  -	      kerncall	KERNAL_CHRIN	; second decimal byte in A
    321  3329				  -	      sec
    322  3329				  -	      sbc	#$30
    323  3329				  -	      clc
    324  3329				  -	      adc	R0
    325  3329				  -	      sta	R0
    326  3329				  -	      lda	#15	; filenumber 15
    327  3329				  -	      kerncall	KERNAL_CLOSE	; call CLOSE
    328  3329				  -	      kerncall	KERNAL_CLRCHN
    329  3329				  -	      lda	R0
    330  3329				  -	      rts
    331  3329				  -.error
    332  3329				  -	      import	I_RUNTIME_ERROR
    333  3329				  -	      jmp	RUNTIME_ERROR
    334  3329					      ENDIF
------- FILE io/io.asm
------- FILE io/_keyboard.asm LEVEL 4 PASS 4
      0  3329					      INCLUDE	"io/_keyboard.asm"
      1  3329
      2  3329				  -	      IF	TARGET == c64 || TARGET = c128
      3  3329				  -IO_KEYW    EQU	$DC00
      4  3329				  -IO_KEYR    EQU	$DC01
      5  3329				  -IO_DDRA    EQU	$DC02
      6  3329				  -IO_DDRB    EQU	$DC03
      7  3329					      ENDIF
      8  3329
      9  3329					      IF	TARGET & vic20
     10  3329		       91 20	   IO_KEYW    EQU	$9120
     11  3329		       91 21	   IO_KEYR    EQU	$9121
     12  3329					      ENDIF
     13  3329
     14  3329				  -	      IF	TARGET & c264
     15  3329				  -IO_KEYW    EQU	$FD30
     16  3329				  -IO_KEYR    EQU	$FF08
     17  3329					      ENDIF
     18  3329
     19  3329				  -	      IF	TARGET & pet
     20  3329				  -IO_KEYW    EQU	$E810
     21  3329				  -IO_KEYR    EQU	$E812
     22  3329					      ENDIF
     23  3329
     24  3329							; GET
     25  3329					      MAC	get
     26  3329					      kerncall	KERNAL_GETIN
     27  3329					      IF	!FPUSH
     28  3329					      pha
     29  3329					      ENDIF
     30  3329					      ENDM		; @push
     31  3329
     32  3329							; Input string from keyboard
     33  3329					      MAC	input
     34  3329					      import	I_IO_INPUT
     35  3329					      jsr	IO_INPUT
     36  3329					      lda	#<STRING_BUFFER1
     37  3329					      sta	R0
     38  3329					      lda	#>STRING_BUFFER1
     39  3329					      sta	R0 + 1
     40  3329					      lda	STRING_BUFFER1
     41  3329					      import	I_STRMOV
     42  3329					      jsr	STRMOV
     43  3329					      ENDM
     44  3329
     45  3329				  -	      IFCONST	I_IO_INPUT_IMPORTED
     46  3329				  -IO_INPUT   SUBROUTINE
     47  3329				  -	      ldy	#0
     48  3329				  -.loop
     49  3329				  -	      kerncall	KERNAL_CHRIN
     50  3329				  -	      sta.wy	STRING_BUFFER1 + 1
     51  3329				  -	      iny
     52  3329				  -	      cmp	#$0d
     53  3329				  -	      bne	.loop
     54  3329				  -	      dey		; remove <CR> from end of input
     55  3329				  -	      sty	STRING_BUFFER1
     56  3329				  -	      rts
     57  3329					      ENDIF
     58  3329
     59  3329							; DECLARE FUNCTION KEY AS BYTE (scancode AS WORD) SHARED STATIC INLINE
     60  3329							; HB: Keyboard write mask
     61  3329							; LB: Keyboard read mask
     62  3329					      MAC	f_key_word
     63  3329					      IF	TARGET == c64 || TARGET = c128
     64  3329					      ldx	#%11111111
     65  3329					      stx	IO_DDRA
     66  3329					      ldx	#%00000000
     67  3329					      stx	IO_DDRB
     68  3329					      ENDIF
     69  3329					      If	!FPULL
     70  3329					      pla
     71  3329					      sta	IO_KEYW
     72  3329					      IF	TARGET & c264
     73  3329					      sta	IO_KEYR
     74  3329					      ENDIF
     75  3329					      ELSE
     76  3329					      sty	IO_KEYW
     77  3329					      IF	TARGET & c264
     78  3329					      sta	IO_KEYR
     79  3329					      ENDIF
     80  3329					      ENDIF
     81  3329					      ENDIF
     82  3329					      If	!FPULL
     83  3329					      pla
     84  3329					      ENDIF
     85  3329					      and	IO_KEYR
     86  3329					      bne	.f
     87  3329					      ptrue
     88  3329					      bne	.q
     89  3329				   .f
     90  3329					      pfalse
     91  3329				   .q
     92  3329					      ENDM		; @push @pull
------- FILE io/io.asm
------- FILE io/_joystick.asm LEVEL 4 PASS 4
      0  3329					      INCLUDE	"io/_joystick.asm"
      1  3329
      2  3329				  -	      IF	TARGET & c264
     26  3329				  -	      ENDM		; @pull @push
     27  3329					      ENDIF
     28  3329
     29  3329				  -	      IF	TARGET == c64
     48  3329				  -	      ENDM		; @pull @push
     49  3329					      ENDIF
     50  3329
     51  3329					      IF	TARGET & vic20
     52  3329					      MAC	f_joy_byte
     53  3329				   VIA1DDR    EQU	$9113
     54  3329				   VIA2DDR    EQU	$9122
     55  3329				   OUTPUTA    EQU	$9111
     56  3329				   OUTPUTB    EQU	$9120
     57  3329					      IF	!FPULL
     58  3329					      pla
     59  3329					      ENDIF
     60  3329					      lda	#0
     61  3329					      sta	VIA1DDR
     62  3329					      lda	#$7F
     63  3329					      sta	VIA2DDR
     64  3329					      lda	OUTPUTB
     65  3329					      ora	#%01111111
     66  3329					      and	OUTPUTA
     67  3329					      eor	#$ff
     68  3329					      IF	!FPUSH
     69  3329					      pha
     70  3329					      ENDIF
     71  3329					      ldx	#$ff
     72  3329					      stx	VIA2DDR
     73  3329					      ENDM		; @pull @push
     74  3329					      ENDIF
     75  3329
------- FILE io/io.asm
------- FILE io/_error.asm LEVEL 4 PASS 4
      0  3329					      INCLUDE	"io/_error.asm"
      1  3329		       00 01	   ERR_TOO_MANY_FILES EQU	$01
      2  3329		       00 02	   ERR_FILE_OPEN EQU	$02
      3  3329		       00 03	   ERR_FILE_NOT_OPEN EQU	$03
      4  3329		       00 04	   ERR_FILE_NOT_FOUND EQU	$04
      5  3329		       00 05	   ERR_DEVICE_NOT_PRESENT EQU	$05
      6  3329		       00 06	   ERR_NOT_INPUT_FILE EQU	$06
      7  3329		       00 07	   ERR_NOT_OUTPUT_FILE EQU	$07
      8  3329		       00 08	   ERR_MISSING_FILENAME EQU	$08
      9  3329		       00 09	   ERR_ILLEGAL_DEVICE_NO EQU	$09
     10  3329		       00 0a	   ERR_DEVICE_NOT_READY EQU	$0a
     11  3329		       00 0b	   ERR_READ_ERROR EQU	$0b
     12  3329		       00 0e	   ERR_ILQTY  EQU	$0e
     13  3329		       00 0f	   ERR_OVERFLOW EQU	$0f
     14  3329		       00 14	   ERR_DIVZERO EQU	$14
     15  3329		       00 15	   ERR_ILLEGAL_DIRECT EQU	$15
     16  3329
     17  3329		       ff 81	   SCINIT     EQU	$ff81
     18  3329
     19  3329					      MAC	seterrhandler
     20  3329					      lda	#<{1}
     21  3329					      sta	ERR_VECTOR
     22  3329					      lda	#>{1}
     23  3329					      sta	ERR_VECTOR + 1
     24  3329					      ENDM
     25  3329
     26  3329					      MAC	error
     27  3329					      IF	!FPULL
     28  3329					      pla
     29  3329					      ENDIF
     30  3329					      import	I_RUNTIME_ERROR
     31  3329					      jmp	RUNTIME_ERROR
     32  3329					      ENDM		; @pull
     33  3329
     34  3329					      MAC	f_err
     35  3329					      lda	ERRNO
     36  3329					      IF	!FPUSH
     37  3329					      pha
     38  3329					      ENDIF
     39  3329					      ENDM		; @push
     40  3329
     41  3329							; Return value of the ERR() function
     42  3329		       00	   ERRNO      HEX	00
     43  332a
     44  332a							; Default error handler
     45  332a							; redirect to custor handling routine if set
     46  332a							; or
     47  332a							; display error message and end program
     48  332a					      IFCONST	I_RUNTIME_ERROR_IMPORTED
     49  332a				   RUNTIME_ERROR SUBROUTINE
     50  332a		       8d 29 33 	      sta	ERRNO
     51  332d		       ac 51 33 	      ldy	ERR_VECTOR + 1
     52  3330		       d0 14		      bne	.custom
     53  3332							; No custom error handler, do default
     54  3332		       48		      pha
     55  3333							;jsr SCINIT
      0  3333					      printnl
      1  3333		       a9 0d		      lda	#13
      0  3335					      kerncall	KERNAL_CHROUT
      1  3335		       20 d2 ff 	      jsr	KERNAL_CHROUT
     57  3338		       a9 49		      lda	#<.err
     58  333a		       a0 33		      ldy	#>.err
      0  333c					      import	I_STDLIB_PRINTSTR
      1  333c				   I_STDLIB_PRINTSTR_IMPORTED SET	1
     60  333c		       20 d8 32 	      jsr	STDLIB_PRINTSTR
      0  333f					      printbyte		; pulls error code off of stack
      0  333f					      import	I_STDLIB_PRINT_BYTE
      1  333f				   I_STDLIB_PRINT_BYTE_IMPORTED SET	1
      2  333f					      IF	!FPULL
      3  333f		       68		      pla
      4  3340					      ENDIF
      5  3340		       20 06 33 	      jsr	STDLIB_PRINT_BYTE
      0  3343					      xend
      1  3343				  -	      IF	USEIRQ == 1
      2  3343				  -	      jsr	IRQRESET
      3  3343					      ENDIF
      4  3343				  -	      IF	TARGET == c64
      5  3343				  -
      6  3343				  -	      lda	$01
      7  3343				  -	      ora	#%00000001
      8  3343				  -	      sta	$01
      9  3343					      ENDIF
     10  3343				  -	      IF	TARGET == c128
     11  3343				  -
     12  3343				  -	      lda	#%0
     13  3343				  -	      sta	MMU
     14  3343				  -
     15  3343				  -	      lda	#$00
     16  3343				  -	      sta	$D8
     17  3343				  -
     18  3343				  -	      lda	INIT_STATUS
     19  3343				  -	      ora	#1
     20  3343				  -	      sta	INIT_STATUS
     21  3343					      ENDIF
     22  3343
     23  3343					      IF	TARGET & vic20
     24  3343		       6c 02 c0 	      jmp	($C002)
     25  3346					      ENDIF
     26  3346				  -	      IF	TARGET & c264
     27  3346				  -	      jmp	$8003
     28  3346					      ENDIF
     29  3346				  -	      IF	TARGET == c64
     30  3346				  -	      jmp	($A002)
     31  3346					      ENDIF
     32  3346				  -	      IF	TARGET == c128
     33  3346				  -	      jmp	($0A00)
     34  3346					      ENDIF
     35  3346				  -	      IF	TARGET & pet && TARGET < pet4
     36  3346				  -	      jmp	$C389
     37  3346					      ENDIF
     38  3346				  -	      IF	TARGET & pet && TARGET >= pet4
     39  3346				  -	      jmp	$B3FF
     40  3346					      ENDIF
     63  3346				   .custom
     64  3346		       6c 50 33 	      jmp	(ERR_VECTOR)
     65  3349
     66  3349							; "error "
     67  3349		       06 45 52 52*.err       HEX	06 45 52 52 4f 52 20
     68  3350
     69  3350							; Error redirection vector
     70  3350							; If HB = 0 errors won't be redirected
     71  3350		       00 00	   ERR_VECTOR HEX	00 00
     72  3352					      ENDIF
------- FILE io/io.asm
------- FILE xcb3lib.asm
     29  3352							; Memory library
------- FILE mem/mem.asm LEVEL 3 PASS 4
      0  3352					      INCLUDE	"mem/mem.asm"
------- FILE mem/_fn.asm LEVEL 4 PASS 4
      0  3352					      INCLUDE	"mem/_fn.asm"
      1  3352							; XC=BASIC memory functions
      2  3352
      3  3352							; DECLARE FUNCTION PEEK AS BYTE (address AS WORD) SHARED STATIC INLINE
      4  3352					      MAC	f_peek_word
      5  3352					      IF	!FPULL
      6  3352					      pla
      7  3352					      sta	.l + 2
      8  3352					      pla
      9  3352					      sta	.l + 1
     10  3352					      ELSE
     11  3352					      sta	.l + 1
     12  3352					      sty	.l + 2
     13  3352					      ENDIF
     14  3352				   .l	      lda	$FFFF
     15  3352					      IF	!FPUSH
     16  3352					      pha
     17  3352					      ENDIF
     18  3352					      ENDM		; @push @pull
     19  3352
     20  3352					      MAC	f_deek_word
     21  3352					      IF	!FPULL
     22  3352					      pla
     23  3352					      sta	R1
     24  3352					      pla
     25  3352					      sta	R0
     26  3352					      ELSE
     27  3352					      sta	R0
     28  3352					      sty	R1
     29  3352					      ENDIF
     30  3352					      IF	!FPUSH
     31  3352					      ldy	#$00
     32  3352					      lda	(R0),y
     33  3352					      pha
     34  3352					      iny
     35  3352					      lda	(R0),y
     36  3352					      pha
     37  3352					      ELSE
     38  3352					      ldy	#$00
     39  3352					      lda	(R0),y
     40  3352					      tax
     41  3352					      iny
     42  3352					      lda	(R0),y
     43  3352					      tay
     44  3352					      txa
     45  3352					      ENDIF
     46  3352					      ENDM		; @push @pull
------- FILE mem/mem.asm
------- FILE mem/_routines.asm LEVEL 4 PASS 4
      0  3352					      INCLUDE	"mem/_routines.asm"
      1  3352							; Fills memory area
      2  3352							;
      3  3352							; derived from Practical Memory Move Routines
      4  3352							; by Bruce Clark
      5  3352							;
      6  3352							; R0: destination address
      7  3352							; A: fill byte
      8  3352							; R2: number of bytes to copy
      9  3352				  -	      IFCONST	I_MEMSET_IMPORTED
     10  3352				  -MEMSET     SUBROUTINE
     11  3352				  -.dst       EQU	R0
     12  3352				  -.siz       EQU	R2
     13  3352				  -	      ldy	#0
     14  3352				  -	      ldx	.siz+1
     15  3352				  -	      beq	.md2
     16  3352				  -.md1
     17  3352				  -	      sta	(.dst),Y
     18  3352				  -	      iny
     19  3352				  -	      bne	.md1
     20  3352				  -	      inc	.dst+1
     21  3352				  -	      dex
     22  3352				  -	      bne	.md1
     23  3352				  -.md2       ldx	.siz
     24  3352				  -	      beq	.md4
     25  3352				  -.md3
     26  3352				  -	      sta	(.dst),Y
     27  3352				  -	      iny
     28  3352				  -	      dex
     29  3352				  -	      bne	.md3
     30  3352				  -.md4       rts
     31  3352					      ENDIF
     32  3352
     33  3352					      MAC	memset
     34  3352					      IF	!FPULL
     35  3352					      pla
     36  3352					      sta	R1
     37  3352					      pla
     38  3352					      sta	R0
     39  3352					      ELSE
     40  3352					      sta	R0
     41  3352					      sty	R1
     42  3352					      ENDIF
     43  3352					      pla
     44  3352					      sta	R3
     45  3352					      pla
     46  3352					      sta	R2
     47  3352					      pla
     48  3352					      import	I_MEMSET
     49  3352					      jsr	MEMSET
     50  3352					      ENDM		; @pull
     51  3352
     52  3352							; Copies memory area downwards
     53  3352							; from Practical Memory Move Routines
     54  3352							; by Bruce Clark
     55  3352							;
     56  3352							; R0: source address
     57  3352							; R2: destination address
     58  3352							; R4: number of bytes to copy
     59  3352							;
     60  3352							; overlapping safe downwards only
     61  3352
     62  3352					      IFCONST	I_MEMCPY_IMPORTED
     63  3352				   MEMCPY     SUBROUTINE
     64  3352		       00 02	   .src       EQU	R0
     65  3352		       00 04	   .dst       EQU	R2
     66  3352		       00 06	   .siz       EQU	R4
     67  3352		       a0 00		      ldy	#0
     68  3354		       a6 07		      ldx	.siz+1
     69  3356		       f0 0e		      beq	.md2
     70  3358		       b1 02	   .md1       lda	(.src),Y
     71  335a		       91 04		      sta	(.dst),Y
     72  335c		       c8		      iny
     73  335d		       d0 f9		      bne	.md1
     74  335f		       e6 03		      inc	.src+1
     75  3361		       e6 05		      inc	.dst+1
     76  3363		       ca		      dex
     77  3364		       d0 f2		      bne	.md1
     78  3366		       a6 06	   .md2       ldx	.siz
     79  3368		       f0 08		      beq	.md4
     80  336a		       b1 02	   .md3       lda	(.src),Y
     81  336c		       91 04		      sta	(.dst),Y
     82  336e		       c8		      iny
     83  336f		       ca		      dex
     84  3370		       d0 f8		      bne	.md3
     85  3372		       60	   .md4       rts
     86  3373					      ENDIF
     87  3373
     88  3373					      MAC	memcpy
     89  3373					      IF	!FPULL
     90  3373					      pla
     91  3373					      sta	R1
     92  3373					      pla
     93  3373					      sta	R0
     94  3373					      ELSE
     95  3373					      sta	R0
     96  3373					      sty	R1
     97  3373					      ENDIF
     98  3373					      pla
     99  3373					      sta	R3
    100  3373					      pla
    101  3373					      sta	R2
    102  3373					      pla
    103  3373					      sta	R5
    104  3373					      pla
    105  3373					      sta	R4
    106  3373					      import	I_MEMCPY
    107  3373					      jsr	MEMCPY
    108  3373					      ENDM		; @pull
    109  3373
    110  3373							; Copies memory area upwards
    111  3373							;
    112  3373							; from Practical Memory Move Routines
    113  3373							; by Bruce Clark
    114  3373							;
    115  3373							; FROM = source start address
    116  3373							; TO = destination start address
    117  3373							; SIZE = number of bytes to move
    118  3373				  -	      IFCONST	I_MEMSHIFT_IMPORTED
    119  3373				  -MEMSHIFT   SUBROUTINE
    120  3373				  -.FROM      EQU	R0
    121  3373				  -.TO	      EQU	R2
    122  3373				  -.SIZE      EQU	R4
    123  3373				  -
    124  3373				  -	      ldx	.SIZE+1
    125  3373				  -	      clc		; start at the final pages of FROM and TO
    126  3373				  -	      txa
    127  3373				  -	      adc	.FROM+1
    128  3373				  -	      sta	.FROM+1
    129  3373				  -	      clc
    130  3373				  -	      txa
    131  3373				  -	      adc	.TO+1
    132  3373				  -	      sta	.TO+1
    133  3373				  -	      inx
    134  3373				  -	      ldy	.SIZE
    135  3373				  -	      beq	.mu3
    136  3373				  -	      dey
    137  3373				  -	      beq	.mu2
    138  3373				  -.mu1
    139  3373				  -	      lda	(.FROM),y
    140  3373				  -	      sta	(.TO),y
    141  3373				  -	      dey
    142  3373				  -	      bne	.mu1
    143  3373				  -.mu2
    144  3373				  -	      lda	(.FROM),y
    145  3373				  -	      sta	(.TO),Y
    146  3373				  -.mu3
    147  3373				  -	      dey
    148  3373				  -	      dec	.FROM+1
    149  3373				  -	      dec	.TO+1
    150  3373				  -	      dex
    151  3373				  -	      bne	.mu1
    152  3373				  -	      rts
    153  3373					      ENDIF
    154  3373
    155  3373					      MAC	memshift
    156  3373					      IF	!FPULL
    157  3373					      pla
    158  3373					      sta	R1
    159  3373					      pla
    160  3373					      sta	R0
    161  3373					      ELSE
    162  3373					      sta	R0
    163  3373					      sty	R1
    164  3373					      ENDIF
    165  3373					      pla
    166  3373					      sta	R3
    167  3373					      pla
    168  3373					      sta	R2
    169  3373					      pla
    170  3373					      sta	R5
    171  3373					      pla
    172  3373					      sta	R4
    173  3373					      import	I_MEMSHIFT
    174  3373					      jsr	MEMSHIFT
    175  3373					      ENDM		; @pull
    176  3373
    177  3373					      MAC	poke
    178  3373					      IF	!FPULL
    179  3373					      pla
    180  3373					      sta	.l + 2
    181  3373					      pla
    182  3373					      sta	.l + 1
    183  3373					      ELSE
    184  3373					      sta	.l + 1
    185  3373					      sty	.l + 2
    186  3373					      ENDIF
    187  3373					      pla
    188  3373				   .l	      sta	$ffff
    189  3373					      ENDM		; @pull
    190  3373
    191  3373							; usage: poke {const address}
    192  3373					      MAC	poke_constaddr
    193  3373					      IF	!FPULL
    194  3373					      pla
    195  3373					      ENDIF
    196  3373					      sta	{1}
    197  3373					      ENDM		; @pull
    198  3373
    199  3373					      MAC	doke
    200  3373					      IF	!FPULL
    201  3373					      pla
    202  3373					      sta	R1
    203  3373					      pla
    204  3373					      sta	R0
    205  3373					      ELSE
    206  3373					      sta	R0
    207  3373					      sty	R1
    208  3373					      ENDIF
    209  3373					      ldy	#$01
    210  3373					      pla
    211  3373					      sta	(R0),y
    212  3373					      dey
    213  3373					      pla
    214  3373					      sta	(R0),y
    215  3373					      ENDM		; @pull
    216  3373
    217  3373							; usage: doke {const address}
    218  3373					      MAC	doke_constaddr
    219  3373					      IF	!FPULL
    220  3373					      pla
    221  3373					      sta	{1} + 1
    222  3373					      pla
    223  3373					      sta	{1}
    224  3373					      ELSE
    225  3373					      sta	{1}
    226  3373					      sty	{1} + 1
    227  3373					      ENDIF
    228  3373					      ENDM		; @pull
------- FILE mem/mem.asm
------- FILE xcb3lib.asm
     31  3373							; System library
------- FILE sys/sys.asm LEVEL 3 PASS 4
      0  3373					      INCLUDE	"sys/sys.asm"
      1  3373							; XC=BASIC system functions
      2  3373					      IF	TARGET == c64 || TARGET & vic20
      3  3373		       03 0c	   SAREG      EQU	$030C
      4  3373		       03 0d	   SXREG      EQU	$030D
      5  3373		       03 0e	   SYREG      EQU	$030E
      6  3373		       03 0f	   SPREG      EQU	$030F
      7  3373					      ENDIF
      8  3373				  -	      IF	TARGET & c264
      9  3373				  -SAREG      EQU	$07F2
     10  3373				  -SXREG      EQU	$07F3
     11  3373				  -SYREG      EQU	$07F4
     12  3373				  -SPREG      EQU	$07F5
     13  3373					      ENDIF
     14  3373
     15  3373				  -	      IF	TARGET == c128
     16  3373				  -MMU	      EQU	$FF00
     17  3373				  -INIT_STATUS EQU	$0A04
     18  3373					      ENDIF
     19  3373
     20  3373					      IF	TARGET == c64 || TARGET & vic20 || TARGET == c128
     21  3373		       00 a0	   JIFFY      EQU	$A0
     22  3373					      ENDIF
     23  3373				  -	      IF	TARGET & c264
     24  3373				  -JIFFY      EQU	$A3
     25  3373					      ENDIF
     26  3373				  -	      IF	TARGET >= pet
     27  3373				  -JIFFY      EQU	$8D
     28  3373					      ENDIF
     29  3373
     30  3373							; Initial code that runs when the program is started
     31  3373					      MAC	xbegin
     32  3373					      spreset
     33  3373					      framereset
     34  3373					      IF	TARGET == c64
     35  3373							; Bank out BASIC ROM
     36  3373					      lda	$01
     37  3373					      and	#%11111110
     38  3373					      sta	$01
     39  3373					      ENDIF
     40  3373					      IF	TARGET == c128
     41  3373							; Set up MMU
     42  3373					      lda	#%001110
     43  3373					      sta	MMU
     44  3373							; Disable irq based screen editor
     45  3373					      lda	#$ff
     46  3373					      sta	$D8
     47  3373							; Disable BASIC IRQ
     48  3373					      lda	INIT_STATUS
     49  3373					      and	#%11111110
     50  3373					      sta	INIT_STATUS
     51  3373					      ENDIF
     52  3373					      IF	USEIRQ == 1
     53  3373					      jsr	IRQSETUP
     54  3373					      ENDIF
     55  3373							; Init FP workspace
     56  3373					      ldx	#[TEMP3 - CHARAC + 1]
     57  3373					      lda	#0
     58  3373				   .1
     59  3373					      sta	CHARAC,x
     60  3373					      dex
     61  3373					      bne	.1
     62  3373					      ENDM
     63  3373
     64  3373							; Final code that runs when the program is terminated
     65  3373					      MAC	xend
     66  3373					      IF	USEIRQ == 1
     67  3373					      jsr	IRQRESET
     68  3373					      ENDIF
     69  3373					      IF	TARGET == c64
     70  3373							; Bank in BASIC ROM
     71  3373					      lda	$01
     72  3373					      ora	#%00000001
     73  3373					      sta	$01
     74  3373					      ENDIF
     75  3373					      IF	TARGET == c128
     76  3373							; Reset MMU
     77  3373					      lda	#%0
     78  3373					      sta	MMU
     79  3373							; Enable irq based screen editor
     80  3373					      lda	#$00
     81  3373					      sta	$D8
     82  3373							; Enable BASIC IRQ
     83  3373					      lda	INIT_STATUS
     84  3373					      ora	#1
     85  3373					      sta	INIT_STATUS
     86  3373					      ENDIF
     87  3373							; Do BASIC start
     88  3373					      IF	TARGET & vic20
     89  3373					      jmp	($C002)
     90  3373					      ENDIF
     91  3373					      IF	TARGET & c264
     92  3373					      jmp	$8003
     93  3373					      ENDIF
     94  3373					      IF	TARGET == c64
     95  3373					      jmp	($A002)
     96  3373					      ENDIF
     97  3373					      IF	TARGET == c128
     98  3373					      jmp	($0A00)
     99  3373					      ENDIF
    100  3373					      IF	TARGET & pet && TARGET < pet4
    101  3373					      jmp	$C389
    102  3373					      ENDIF
    103  3373					      IF	TARGET & pet && TARGET >= pet4
    104  3373					      jmp	$B3FF
    105  3373					      ENDIF
    106  3373					      ENDM
    107  3373
    108  3373							; DECLARE FUNCTION TI AS LONG () SHARED STATIC INLINE
    109  3373					      MAC	f_ti
    110  3373					      IF	!USEIRQ
    111  3373					      sei
    112  3373					      ENDIF
    113  3373					      lda	JIFFY + 2
    114  3373					      IF	!FPUSH
    115  3373					      pha
    116  3373					      lda	JIFFY + 1
    117  3373					      pha
    118  3373					      lda	JIFFY
    119  3373					      pha
    120  3373					      ELSE
    121  3373					      ldy	JIFFY + 1
    122  3373					      ldx	JIFFY
    123  3373					      ENDIF
    124  3373					      IF	!USEIRQ
    125  3373					      cli
    126  3373					      ENDIF
    127  3373					      ENDM		; @push
    128  3373
    129  3373							; SYS Command
    130  3373							; Use SYS 1 for fast call, SYS 0 for regular call
    131  3373					      MAC	sys
    132  3373					      IF	!FPULL
    133  3373					      pla
    134  3373					      sta	.jsr + 2
    135  3373					      pla
    136  3373					      sta	.jsr + 1
    137  3373					      ELSE
    138  3373					      sta	.jsr + 1
    139  3373					      sty	.jsr + 2
    140  3373					      ENDIF
    141  3373					      IF	{1} == 0
    142  3373					      lda	SPREG
    143  3373					      pha
    144  3373					      lda	SAREG
    145  3373					      ldx	SXREG
    146  3373					      ldy	SYREG
    147  3373					      plp
    148  3373					      ENDIF
    149  3373				   .jsr
    150  3373					      jsr	$FFFF
    151  3373					      IF	{1} == 0
    152  3373					      php
    153  3373					      sta	SAREG
    154  3373					      stx	SXREG
    155  3373					      sty	SYREG
    156  3373					      pla
    157  3373					      sta	SPREG
    158  3373					      ENDIF
    159  3373					      ENDM		; @pull
    160  3373
    161  3373							; SYS Command with constant address
    162  3373							; Use SYS <addr>, 1 for fast call, SYS <addr>, 0 for regular call
    163  3373					      MAC	sys_constaddr
    164  3373					      IF	{2} == 0
    165  3373					      lda	SPREG
    166  3373					      pha
    167  3373					      lda	SAREG
    168  3373					      ldx	SXREG
    169  3373					      ldy	SYREG
    170  3373					      plp
    171  3373					      ENDIF
    172  3373				   .jsr
    173  3373					      jsr	{1}
    174  3373					      IF	{2} == 0
    175  3373					      php
    176  3373					      sta	SAREG
    177  3373					      stx	SXREG
    178  3373					      sty	SYREG
    179  3373					      pla
    180  3373					      sta	SPREG
    181  3373					      ENDIF
    182  3373					      ENDM
    183  3373
    184  3373					      MAC	wait
    185  3373				   .MASK      EQU	R2
    186  3373				   .TRIG      EQU	R3
    187  3373					      IF	!FPULL
    188  3373					      pla
    189  3373					      sta	.loop + 2
    190  3373					      pla
    191  3373					      sta	.loop + 1
    192  3373					      ELSE
    193  3373					      sta	.loop + 1
    194  3373					      sty	.loop + 2
    195  3373					      ENDIF
    196  3373					      pla
    197  3373					      sta	.MASK
    198  3373					      pla
    199  3373					      sta	.TRIG
    200  3373				   .loop
    201  3373					      lda.w	$0000
    202  3373					      eor	.TRIG
    203  3373					      and	.MASK
    204  3373					      beq	.loop
    205  3373					      ENDM		; @pull
------- FILE xcb3lib.asm
     33  3373							; Interrupts
------- FILE irq/irq.asm LEVEL 3 PASS 4
      0  3373					      INCLUDE	"irq/irq.asm"
      1  3373				  -	      IF	TARGET == c64
      2  3373				  -	      INCLUDE	"irq/_c64.asm"
      3  3373					      ENDIF
      4  3373
      5  3373					      IF	TARGET & vic20
------- FILE irq/_vic20.asm LEVEL 4 PASS 4
      0  3373					      INCLUDE	"irq/_vic20.asm"
      1  3373				  -	      IF	USEIRQ == 1
      2  3373				  -
      3  3373				  -IRQVECTOR  EQU	$0314
      4  3373				  -VIA_TIMERBLO EQU	$9128
      5  3373				  -VIA_TIMERBHI EQU	$9129
      6  3373				  -VIA_IRQFL  EQU	$912D
      7  3373				  -VIA_IRQEN  EQU	$912E
      8  3373				  -			; Flags
      9  3373				  -			; bit 0 - custom timer interrupts enabled
     10  3373				  -			; bit 1 - system interrupts enabled
     11  3373				  -IRQ_TIMER  EQU	1
     12  3373				  -IRQ_SYSTEM EQU	2
     13  3373				  -			; Store timeout value here
     14  3373				  -IRQ_TIMER_LATCH HEX	00 00
     15  3373				  -
     31  3373				  -	      ENDM
     32  3373				  -
     43  3373				  -	      ENDM
     44  3373				  -
     56  3373				  -	      ENDM
     57  3373				  -
     58  3373				  -IRQSETUP   SUBROUTINE
     59  3373				  -	      sei
     60  3373				  -	      lda	#<XCBIRQ
     61  3373				  -	      sta	IRQVECTOR
     62  3373				  -	      lda	#>XCBIRQ
     63  3373				  -	      sta	IRQVECTOR + 1
     64  3373				  -	      cli
     65  3373				  -	      rts
     66  3373				  -
     67  3373				  -IRQRESET   SUBROUTINE
     68  3373				  -	      sei
     69  3373				  -	      lda	#<$EABF
     70  3373				  -	      sta	IRQVECTOR
     71  3373				  -	      lda	#>$EABF
     72  3373				  -	      sta	IRQVECTOR + 1
     73  3373				  -	      lda	#%00100000
     74  3373				  -	      sta	VIA_IRQEN
     75  3373				  -	      lda	#%11000000
     76  3373				  -	      sta	VIA_IRQEN
     77  3373				  -	      cli
     78  3373				  -	      rts
     79  3373				  -
     80  3373				  -XCBIRQ     SUBROUTINE
     81  3373				  -	      cld
     82  3373				  -	      lda	VIA_IRQFL
     83  3373				  -	      and	#%00100000
     84  3373				  -	      beq	.sysirq
     85  3373				  -	      phsr
     86  3373				  -IRQ_TIMER_V
     87  3373				  -	      jsr	$FFFF	; To be modified by application
     88  3373				  -	      plsr
     89  3373				  -	      lda	VIA_TIMERBLO
     90  3373				  -	      lda	IRQ_TIMER_LATCH
     91  3373				  -	      sta	VIA_TIMERBLO
     92  3373				  -	      lda	IRQ_TIMER_LATCH + 1
     93  3373				  -	      sta	VIA_TIMERBHI
     94  3373				  -	      jmp	$EB18
     95  3373				  -.sysirq
     96  3373				  -	      jmp	$EABF
     97  3373				  -
     98  3373					      ENDIF
------- FILE irq/irq.asm
      7  3373					      ENDIF
      8  3373
      9  3373				  -	      IF	TARGET & c264
     10  3373				  -	      INCLUDE	"irq/_c264.asm"
     11  3373					      ENDIF
     12  3373
     13  3373				  -	      IF	TARGET & pet
     14  3373				  -	      INCLUDE	"irq/_pet.asm"
     15  3373					      ENDIF
     16  3373
     17  3373				  -	      IF	TARGET == c128
     18  3373				  -	      INCLUDE	"irq/_c128.asm"
     19  3373					      ENDIF
------- FILE xcb3lib.asm
     35  3373							; Graphics
------- FILE grx/grx.asm LEVEL 3 PASS 4
      0  3373					      INCLUDE	"grx/grx.asm"
      1  3373				  -	      IF	TARGET == c64 || TARGET == c128
      2  3373				  -HSCR       EQU	$D016
      3  3373				  -VSCR       EQU	$D011
      4  3373				  -RAST       EQU	$D012
      5  3373				  -RAST8      EQU	$D011
      6  3373					      ENDIF
      7  3373				  -	      IF	TARGET & c264
      8  3373				  -HSCR       EQU	$FF07
      9  3373				  -VSCR       EQU	$FF06
     10  3373				  -RAST       EQU	$FF0B
     11  3373				  -RAST8      EQU	$FF0A
     12  3373					      ENDIF
     13  3373					      IF	TARGET & vic20
     14  3373		       90 04	   RAST       EQU	$9004
     15  3373		       90 03	   RAST8      EQU	$9003
     16  3373					      ENDIF
     17  3373
     18  3373		       00 01	   VMODE_TEXT EQU	1
     19  3373		       00 02	   VMODE_BITMAP EQU	2
     20  3373		       00 03	   VMODE_EXT  EQU	3
     21  3373		       00 00	   VMODE_HIRES EQU	0
     22  3373		       00 01	   VMODE_MULTI EQU	1
     23  3373
     24  3373					      MAC	hscroll
     25  3373					      IF	!FPULL
     26  3373					      pla
     27  3373					      ENDIF
     28  3373					      IF	TARGET & vic20 || TARGET & pet
     29  3373					      ELSE
     30  3373					      and	#%00000111
     31  3373					      sta	R0
     32  3373					      lda	HSCR
     33  3373					      and	#%11111000
     34  3373					      ora	R0
     35  3373					      sta	HSCR
     36  3373					      ENDIF
     37  3373					      ENDM		; @pull
     38  3373
     39  3373					      MAC	vscroll
     40  3373					      IF	!FPULL
     41  3373					      pla
     42  3373					      ENDIF
     43  3373					      IF	TARGET & vic20 || TARGET & pet
     44  3373					      ELSE
     45  3373					      and	#%00000111
     46  3373					      sta	R0
     47  3373					      lda	VSCR
     48  3373					      and	#%11111000
     49  3373					      ora	R0
     50  3373					      sta	VSCR
     51  3373					      ENDIF
     52  3373					      ENDM		; @pull
     53  3373
     54  3373							; 1 = text
     55  3373							; 2 = bitmap
     56  3373							; 3 = ext
     57  3373					      MAC	vmode
     58  3373					      IF	TARGET & vic20 || TARGET & pet
     59  3373					      ELSE
     60  3373					      lda	VSCR
     61  3373					      IF	{1} == 1
     62  3373					      and	#%11011111
     63  3373					      ENDIF
     64  3373					      IF	{1} == 2
     65  3373					      ora	#%00100000
     66  3373					      ENDIF
     67  3373					      IF	{1} == 3
     68  3373					      ora	#%01000000
     69  3373					      ENDIF
     70  3373					      sta	VSCR
     71  3373					      ENDIF
     72  3373					      ENDM
     73  3373
     74  3373							; 0 = hires
     75  3373							; 1 = multi
     76  3373					      MAC	vmodecolor
     77  3373					      IF	TARGET & vic20 || TARGET & pet
     78  3373					      ELSE
     79  3373					      lda	HSCR
     80  3373					      IF	{1} == 1
     81  3373					      ora	#%00010000
     82  3373					      ELSE
     83  3373					      and	#%11101111
     84  3373					      ENDIF
     85  3373					      sta	HSCR
     86  3373					      ENDIF
     87  3373					      ENDM
     88  3373
     89  3373					      MAC	rsel
     90  3373					      IF	TARGET & vic20 || TARGET & pet
     91  3373					      ELSE
     92  3373					      lda	VSCR
     93  3373					      IF	{1} == 1
     94  3373					      ora	#%00001000
     95  3373					      ELSE
     96  3373					      and	#%11110111
     97  3373					      ENDIF
     98  3373					      sta	VSCR
     99  3373					      ENDIF
    100  3373					      ENDM
    101  3373
    102  3373					      MAC	csel
    103  3373					      IF	TARGET & vic20 || TARGET & pet
    104  3373					      ELSE
    105  3373					      lda	HSCR
    106  3373					      IF	{1} == 1
    107  3373					      ora	#%00001000
    108  3373					      ELSE
    109  3373					      and	#%11110111
    110  3373					      ENDIF
    111  3373					      sta	HSCR
    112  3373					      ENDIF
    113  3373					      ENDM
    114  3373
    115  3373					      MAC	charsetram
    116  3373					      IF	TARGET & c264
    117  3373					      lda	$FF12
    118  3373					      and	#%11111011
    119  3373					      sta	$FF12
    120  3373					      ENDIF
    121  3373					      IF	TARGET & vic20
    122  3373					      lda	$9005
    123  3373					      ora	#%00001000
    124  3373					      sta	$9005
    125  3373					      ENDIF
    126  3373					      ENDM
    127  3373
    128  3373					      MAC	charsetrom
    129  3373					      IF	TARGET & c264
    130  3373					      lda	$FF12
    131  3373					      ora	#%00000100
    132  3373					      sta	$FF12
    133  3373					      ENDIF
    134  3373					      IF	TARGET & vic20
    135  3373					      lda	$9005
    136  3373					      and	#%11110111
    137  3373					      sta	$9005
    138  3373					      ENDIF
    139  3373					      ENDM
    140  3373
    141  3373					      MAC	charset
    142  3373					      IF	!FPULL
    143  3373					      pla
    144  3373					      ENDIF
    145  3373					      IF	(TARGET == c64) || (TARGET == c128)
    146  3373					      asl
    147  3373					      and	#%00001110
    148  3373					      sta	R0
    149  3373					      lda	$D018
    150  3373					      and	#%11110001
    151  3373					      ora	R0
    152  3373					      sta	$D018
    153  3373					      ENDIF
    154  3373					      IF	TARGET & c264
    155  3373					      asl
    156  3373					      asl
    157  3373					      sta	R0
    158  3373					      lda	$FF13
    159  3373					      and	#%00000011
    160  3373					      ora	R0
    161  3373					      sta	$FF13
    162  3373					      ENDIF
    163  3373					      IF	TARGET & vic20
    164  3373					      and	#%00000111
    165  3373					      sta	R0
    166  3373					      lda	$9005
    167  3373					      and	#%11111000
    168  3373					      ora	R0
    169  3373					      sta	$9005
    170  3373					      ENDIF
    171  3373					      ENDM		; @pull
    172  3373
    173  3373					      MAC	f_scan
    174  3373					      IF	TARGET & vic20
    175  3373					      clc
    176  3373					      lda	RAST8
    177  3373					      asl
    178  3373					      lda	RAST
    179  3373					      asl
    180  3373					      pha
    181  3373					      lda	#0
    182  3373					      rol
    183  3373					      pha
    184  3373					      ELSE
    185  3373					      lda	RAST
    186  3373					      pha
    187  3373					      lda	RAST8
    188  3373					      IF	(TARGET == c64) || (TARGET == c128)
    189  3373					      asl
    190  3373					      lda	#0
    191  3373					      rol
    192  3373					      ENDIF
    193  3373					      IF	TARGET & c264
    194  3373					      and	#%00000001
    195  3373					      ENDIF
    196  3373					      pha
    197  3373					      ENDIF
    198  3373					      ENDM
------- FILE xcb3lib.asm
     37  3373							; Sound
     38  3373				  -	      IF	USESFX
     39  3373				  -	      INCLUDE	"sfx/sfx.asm"
     40  3373					      ENDIF
     41  3373							; Sprites
     42  3373				  -	      IF	USESPR
     43  3373				  -	      INCLUDE	"grx/sprite.asm"
     44  3373					      ENDIF
     45  3373							; Optimizer
------- FILE opt/opt.asm LEVEL 3 PASS 4
      0  3373					      INCLUDE	"opt/opt.asm"
      1  3373							; --------------------------------
      2  3373							; XC=BASIC optimized macros
      3  3373							; --------------------------------
      4  3373
      5  3373							; BYTES
      6  3373
      7  3373							; Quick addition
      8  3373					      MAC	pbytevar_pbyte_addbyte
      9  3373					      lda	{1}
     10  3373					      clc
     11  3373					      adc	#{2}
     12  3373					      IF	!FPUSH
     13  3373					      pha
     14  3373					      ENDIF
     15  3373					      ENDM		; @push
     16  3373
     17  3373					      MAC	pbyte_pbytevar_addbyte
     18  3373					      lda	#{1}
     19  3373					      clc
     20  3373					      adc	{2}
     21  3373					      IF	!FPUSH
     22  3373					      pha
     23  3373					      ENDIF
     24  3373					      ENDM		; @push
     25  3373
     26  3373					      MAC	pbytevar_pbytevar_addbyte
     27  3373					      lda	{1}
     28  3373					      clc
     29  3373					      adc	{2}
     30  3373					      IF	!FPUSH
     31  3373					      pha
     32  3373					      ENDIF
     33  3373					      ENDM		; @push
     34  3373
     35  3373							; Quick subtraction
     36  3373					      MAC	pbytevar_pbyte_subbyte
     37  3373					      lda	{1}
     38  3373					      sec
     39  3373					      sbc	#{2}
     40  3373					      IF	!FPUSH
     41  3373					      pha
     42  3373					      ENDIF
     43  3373					      ENDM		; @push
     44  3373
     45  3373					      MAC	pbyte_pbytevar_subbyte
     46  3373					      lda	#{1}
     47  3373					      sec
     48  3373					      sbc	{2}
     49  3373					      IF	!FPUSH
     50  3373					      pha
     51  3373					      ENDIF
     52  3373					      ENDM		; @push
     53  3373
     54  3373					      MAC	pbytevar_pbytevar_subbyte
     55  3373					      lda	{1}
     56  3373					      sec
     57  3373					      sbc	{2}
     58  3373					      IF	!FPUSH
     59  3373					      pha
     60  3373					      ENDIF
     61  3373					      ENDM		; @push
     62  3373
     63  3373							; Increase instad of addition
     64  3373					      MAC	pbytevar_pbyte_addbyte_plbytevar
     65  3373					      IF	{1} == {3} && {2} == 1	; Same vars and addend = 1
     66  3373					      inc	{1}
     67  3373					      ELSE
     68  3373					      lda	{1}
     69  3373					      clc
     70  3373					      adc	#{2}
     71  3373					      sta	{3}
     72  3373					      ENDIF
     73  3373					      ENDM
     74  3373
     75  3373					      MAC	pbyte_pbytevar_addbyte_plbytevar
     76  3373					      IF	{2} == {3} && {1} == 1	; Same vars and addend = 1
     77  3373					      inc	{2}
     78  3373					      ELSE
     79  3373					      lda	#{1}
     80  3373					      clc
     81  3373					      adc	{2}
     82  3373					      sta	{3}
     83  3373					      ENDIF
     84  3373					      ENDM
     85  3373
     86  3373							; Decrease instad of subtraction
     87  3373					      MAC	pbytevar_pbyte_subbyte_plbytevar
     88  3373					      IF	{1} == {3} && {2} == 1	; Same vars and addend = 1
     89  3373					      dec	{1}
     90  3373					      ELSE
     91  3373					      lda	{1}
     92  3373					      sec
     93  3373					      sbc	#{2}
     94  3373					      sta	{3}
     95  3373					      ENDIF
     96  3373					      ENDM
     97  3373
     98  3373							; Quick OR
     99  3373					      MAC	pbytevar_pbyte_orbyte
    100  3373					      lda	{1}
    101  3373					      ora	#{2}
    102  3373					      IF	!FPUSH
    103  3373					      pha
    104  3373					      ENDIF
    105  3373					      ENDM		; @push
    106  3373
    107  3373					      MAC	pbyte_pbytevar_orbyte
    108  3373					      lda	#{1}
    109  3373					      ora	{2}
    110  3373					      IF	!FPUSH
    111  3373					      pha
    112  3373					      ENDIF
    113  3373					      ENDM		; @push
    114  3373
    115  3373					      MAC	pbytevar_pbytevar_orbyte
    116  3373					      lda	{1}
    117  3373					      ora	{2}
    118  3373					      IF	!FPUSH
    119  3373					      pha
    120  3373					      ENDIF
    121  3373					      ENDM		; @push
    122  3373
    123  3373							; Quick AND
    124  3373					      MAC	pbytevar_pbyte_andbyte
    125  3373					      lda	{1}
    126  3373					      and	#{2}
    127  3373					      IF	!FPUSH
    128  3373					      pha
    129  3373					      ENDIF
    130  3373					      ENDM		; @push
    131  3373
    132  3373					      MAC	pbyte_pbytevar_andbyte
    133  3373					      lda	#{1}
    134  3373					      and	{2}
    135  3373					      IF	!FPUSH
    136  3373					      pha
    137  3373					      ENDIF
    138  3373					      ENDM		; @push
    139  3373
    140  3373					      MAC	pbytevar_pbytevar_andbyte
    141  3373					      lda	{1}
    142  3373					      and	{2}
    143  3373					      IF	!FPUSH
    144  3373					      pha
    145  3373					      ENDIF
    146  3373					      ENDM		; @push
    147  3373
    148  3373							; Quick XOR
    149  3373					      MAC	pbytevar_pbyte_xorbyte
    150  3373					      lda	{1}
    151  3373					      eor	#{2}
    152  3373					      IF	!FPUSH
    153  3373					      pha
    154  3373					      ENDIF
    155  3373					      ENDM		; @push
    156  3373
    157  3373					      MAC	pbyte_pbytevar_xorbyte
    158  3373					      lda	#{1}
    159  3373					      eor	{2}
    160  3373					      IF	!FPUSH
    161  3373					      pha
    162  3373					      ENDIF
    163  3373					      ENDM		; @push
    164  3373
    165  3373					      MAC	pbytevar_pbytevar_xorbyte
    166  3373					      lda	{1}
    167  3373					      eor	{2}
    168  3373					      IF	!FPUSH
    169  3373					      pha
    170  3373					      ENDIF
    171  3373					      ENDM		; @push
    172  3373
    173  3373							; WORDS, INTS and DECIMALS
    174  3373
    175  3373							; Quick addition
    176  3373					      MAC	pint_pintvar_addint
    177  3373					      lda	#<{1}
    178  3373					      clc
    179  3373					      adc	{2}
    180  3373					      IF	!FPUSH
    181  3373					      pha
    182  3373					      ELSE
    183  3373					      tax
    184  3373					      ENDIF
    185  3373					      lda	#>{1}
    186  3373					      adc	{2} + 1
    187  3373					      IF	!FPUSH
    188  3373					      pha
    189  3373					      ELSE
    190  3373					      tay
    191  3373					      txa
    192  3373					      ENDIF
    193  3373					      ENDM		; @push
    194  3373
    195  3373					      MAC	pbyte_f_cint_byte_pintvar_addint
    196  3373					      pint_pintvar_addint	{1}, {2}
    197  3373					      ENDM		; @push
    198  3373
    199  3373					      MAC	pword_pwordvar_addword
    200  3373					      pint_pintvar_addint	{1}, {2}
    201  3373					      ENDM		; @push
    202  3373
    203  3373					      MAC	pbyte_f_cword_byte_pwordvar_addword
    204  3373					      pint_pintvar_addint	{1}, {2}
    205  3373					      ENDM		; @push
    206  3373
    207  3373					      MAC	pdecimal_pdecimalvar_adddecimal
    208  3373					      IF	!USEIRQ
    209  3373					      sei
    210  3373					      ENDIF
    211  3373					      sed
    212  3373					      lda	#{1}
    213  3373					      clc
    214  3373					      adc	{3}
    215  3373					      IF	!FPUSH
    216  3373					      pha
    217  3373					      ELSE
    218  3373					      tax
    219  3373					      ENDIF
    220  3373					      lda	#{2}
    221  3373					      adc	{3} + 1
    222  3373					      IF	!FPUSH
    223  3373					      pha
    224  3373					      ELSE
    225  3373					      tay
    226  3373					      txa
    227  3373					      ENDIF
    228  3373					      cld
    229  3373					      IF	!USEIRQ
    230  3373					      cli
    231  3373					      ENDIF
    232  3373					      ENDM		; @push
    233  3373
    234  3373					      MAC	pint_pintvar_addint_plintvar
    235  3373					      IF	{1} == 1 && {2} == {3}
    236  3373					      inc	{2}
    237  3373					      bne	.1
    238  3373					      inc	{2} + 1
    239  3373				   .1
    240  3373					      ELSE
    241  3373					      lda	#<{1}
    242  3373					      clc
    243  3373					      adc	{2}
    244  3373					      sta	{3}
    245  3373					      lda	#>{1}
    246  3373					      adc	{2} + 1
    247  3373					      sta	{3} + 1
    248  3373					      ENDIF
    249  3373					      ENDM
    250  3373
    251  3373					      MAC	pbyte_f_cint_byte_pintvar_addint_plintvar
    252  3373					      pint_pintvar_addint_plintvar	{1}, {2}, {3}
    253  3373					      ENDM
    254  3373
    255  3373					      MAC	pword_pwordvar_addword_plwordvar
    256  3373					      pint_pintvar_addint_plintvar	{1}, {2}, {3}
    257  3373					      ENDM
    258  3373
    259  3373					      MAC	pbyte_f_cword_byte_pwordvar_addword_plwordvar
    260  3373					      pint_pintvar_addint_plintvar	{1}, {2}, {3}
    261  3373					      ENDM
    262  3373
    263  3373					      MAC	pdecimal_pdecimalvar_adddecimal_pldecimalvar
    264  3373					      IF	!USEIRQ
    265  3373					      sei
    266  3373					      ENDIF
    267  3373					      sed
    268  3373					      lda	#{1}
    269  3373					      clc
    270  3373					      adc	{3}
    271  3373					      sta	{4}
    272  3373					      lda	#{2}
    273  3373					      adc	{3} + 1
    274  3373					      sta	{4} + 1
    275  3373					      cld
    276  3373					      IF	!USEIRQ
    277  3373					      cli
    278  3373					      ENDIF
    279  3373					      ENDM
    280  3373
    281  3373					      MAC	pintvar_pint_addint
    282  3373					      lda	{1}
    283  3373					      clc
    284  3373					      adc	#<{2}
    285  3373					      IF	!FPUSH
    286  3373					      pha
    287  3373					      ELSE
    288  3373					      tax
    289  3373					      ENDIF
    290  3373					      lda	{1} + 1
    291  3373					      adc	#>{2}
    292  3373					      IF	!FPUSH
    293  3373					      pha
    294  3373					      ELSE
    295  3373					      tay
    296  3373					      txa
    297  3373					      ENDIF
    298  3373					      ENDM		; @push
    299  3373
    300  3373					      MAC	pintvar_pbyte_f_cint_byte_addint
    301  3373					      pintvar_pint_addint	{1}, {2}
    302  3373					      ENDM		; @push
    303  3373
    304  3373					      MAC	pwordvar_pword_addword
    305  3373					      pintvar_pint_addint	{1}, {2}
    306  3373					      ENDM		; @push
    307  3373
    308  3373					      MAC	pwordvar_pbyte_f_cword_byte_addword
    309  3373					      pintvar_pint_addint	{1}, {2}
    310  3373					      ENDM		; @push
    311  3373
    312  3373					      MAC	pdecimalvar_pdecimal_adddecimal
    313  3373					      IF	!USEIRQ
    314  3373					      sei
    315  3373					      ENDIF
    316  3373					      sed
    317  3373					      lda	{1}
    318  3373					      clc
    319  3373					      adc	#{2}
    320  3373					      IF	!FPUSH
    321  3373					      pha
    322  3373					      ELSE
    323  3373					      tax
    324  3373					      ENDIF
    325  3373					      lda	{1} + 1
    326  3373					      adc	#{3}
    327  3373					      IF	!FPUSH
    328  3373					      pha
    329  3373					      ELSE
    330  3373					      tay
    331  3373					      txa
    332  3373					      ENDIF
    333  3373					      cld
    334  3373					      IF	!USEIRQ
    335  3373					      cli
    336  3373					      ENDIF
    337  3373					      ENDM		; @push
    338  3373
    339  3373					      MAC	pintvar_pint_addint_plintvar
    340  3373					      IF	{2} == 1 && {1} == {3}
    341  3373					      inc	{1}
    342  3373					      bne	.1
    343  3373					      inc	{1} + 1
    344  3373				   .1
    345  3373					      ELSE
    346  3373					      lda	{1}
    347  3373					      clc
    348  3373					      adc	#<{2}
    349  3373					      sta	{3}
    350  3373					      lda	{1} + 1
    351  3373					      adc	#>{2}
    352  3373					      sta	{3} + 1
    353  3373					      ENDIF
    354  3373					      ENDM
    355  3373
    356  3373					      MAC	pintvar_pbyte_f_cint_byte_addint_plintvar
    357  3373					      pintvar_pint_addint_plintvar	{1}, {2}, {3}
    358  3373					      ENDM
    359  3373
    360  3373					      MAC	pwordvar_pword_addword_plwordvar
    361  3373					      pintvar_pint_addint_plintvar	{1}, {2}, {3}
    362  3373					      ENDM
    363  3373
    364  3373					      MAC	pwordvar_pbyte_f_cword_byte_addword_plwordvar
    365  3373					      pintvar_pint_addint_plintvar	{1}, {2}, {3}
    366  3373					      ENDM
    367  3373
    368  3373					      MAC	pdecimalvar_pdecimal_addecimal_pldecimalvar
    369  3373					      IF	!USEIRQ
    370  3373					      sei
    371  3373					      ENDIF
    372  3373					      sed
    373  3373					      lda	{1}
    374  3373					      clc
    375  3373					      adc	#{2}
    376  3373					      sta	{4}
    377  3373					      lda	{1} + 1
    378  3373					      adc	#{3}
    379  3373					      sta	{4} + 1
    380  3373					      cld
    381  3373					      IF	!USEIRQ
    382  3373					      cli
    383  3373					      ENDIF
    384  3373					      ENDM
    385  3373
    386  3373					      MAC	pintvar_pintvar_addint
    387  3373					      lda	{1}
    388  3373					      clc
    389  3373					      adc	{2}
    390  3373					      IF	!FPUSH
    391  3373					      pha
    392  3373					      ELSE
    393  3373					      tax
    394  3373					      ENDIF
    395  3373					      lda	{1} + 1
    396  3373					      adc	{2} + 1
    397  3373					      IF	!FPUSH
    398  3373					      pha
    399  3373					      ELSE
    400  3373					      tay
    401  3373					      txa
    402  3373					      ENDIF
    403  3373					      ENDM		; @push
    404  3373
    405  3373					      MAC	pwordvar_pwordvar_addword
    406  3373					      pintvar_pintvar_addint	{1}, {2}
    407  3373					      ENDM		; @push
    408  3373
    409  3373					      MAC	pdecimalvar_pdecimalvar_adddecimal
    410  3373					      IF	!USEIRQ
    411  3373					      sei
    412  3373					      ENDIF
    413  3373					      sed
    414  3373					      pintvar_pintvar_addint	{1}, {2}
    415  3373					      cld
    416  3373					      IF	!USEIRQ
    417  3373					      cli
    418  3373					      ENDIF
    419  3373					      ENDM		; @push
    420  3373
    421  3373					      MAC	pintvar_pintvar_addint_plintvar
    422  3373					      lda	{1}
    423  3373					      clc
    424  3373					      adc	{2}
    425  3373					      sta	{3}
    426  3373					      lda	{1} + 1
    427  3373					      adc	{2} + 1
    428  3373					      sta	{3} + 1
    429  3373					      ENDM
    430  3373
    431  3373					      MAC	pwordvar_pwordvar_addword_plwordvar
    432  3373					      pintvar_pintvar_addint	{1}, {2}, {3}
    433  3373					      ENDM		; @push
    434  3373
    435  3373					      MAC	pdecimalvar_pdecimalvar_adddecimal_pldecimalvar
    436  3373					      IF	!USEIRQ
    437  3373					      sei
    438  3373					      ENDIF
    439  3373					      sed
    440  3373					      pintvar_pintvar_addint	{1}, {2}, {3}
    441  3373					      cld
    442  3373					      IF	!USEIRQ
    443  3373					      cli
    444  3373					      ENDIF
    445  3373					      ENDM		; @push
    446  3373
    447  3373							; Quick subtraction
    448  3373
    449  3373					      MAC	pint_pintvar_subint
    450  3373					      lda	#<{1}
    451  3373					      sec
    452  3373					      sbc	{2}
    453  3373					      IF	!FPUSH
    454  3373					      pha
    455  3373					      ELSE
    456  3373					      tax
    457  3373					      ENDIF
    458  3373					      lda	#>{1}
    459  3373					      sbc	{2} + 1
    460  3373					      IF	!FPUSH
    461  3373					      pha
    462  3373					      ELSE
    463  3373					      tay
    464  3373					      txa
    465  3373					      ENDIF
    466  3373					      ENDM		; @push
    467  3373
    468  3373					      MAC	pword_pwordvar_subword
    469  3373					      pint_pintvar_subint	{1}, {2}
    470  3373					      ENDM		; @push
    471  3373
    472  3373					      MAC	pdecimal_pdecimalvar_subdecimal
    473  3373					      IF	!USEIRQ
    474  3373					      sei
    475  3373					      ENDIF
    476  3373					      sed
    477  3373					      lda	#{1}
    478  3373					      sec
    479  3373					      sbc	{3}
    480  3373					      IF	!FPUSH
    481  3373					      pha
    482  3373					      ELSE
    483  3373					      tax
    484  3373					      ENDIF
    485  3373					      lda	#{2}
    486  3373					      sbc	{3} + 1
    487  3373					      IF	!FPUSH
    488  3373					      pha
    489  3373					      ELSE
    490  3373					      tay
    491  3373					      txa
    492  3373					      ENDIF
    493  3373					      cld
    494  3373					      IF	!USEIRQ
    495  3373					      cli
    496  3373					      ENDIF
    497  3373					      ENDM		; @push
    498  3373
    499  3373					      MAC	pint_pintvar_subint_plintvar
    500  3373					      lda	#<{1}
    501  3373					      sec
    502  3373					      sbc	{2}
    503  3373					      sta	{3}
    504  3373					      lda	#>{1}
    505  3373					      sbc	{2} + 1
    506  3373					      sta	{3} + 1
    507  3373					      ENDM
    508  3373
    509  3373					      MAC	pword_pwordvar_subword_plwordvar
    510  3373					      pint_pintvar_subint_plintvar	{1}, {2}, {3}
    511  3373					      ENDM
    512  3373
    513  3373					      MAC	pdecimal_pdecimalvar_subdecimal_pldecimalvar
    514  3373					      IF	!USEIRQ
    515  3373					      sei
    516  3373					      ENDIF
    517  3373					      sed
    518  3373					      lda	#{1}
    519  3373					      sec
    520  3373					      sbc	{3}
    521  3373					      sta	{4}
    522  3373					      lda	#{2}
    523  3373					      sbc	{3} + 1
    524  3373					      sta	{4} + 1
    525  3373					      cld
    526  3373					      IF	!USEIRQ
    527  3373					      cli
    528  3373					      ENDIF
    529  3373					      ENDM
    530  3373
    531  3373					      MAC	pintvar_pint_subint
    532  3373					      lda	{1}
    533  3373					      sec
    534  3373					      sbc	#<{2}
    535  3373					      IF	!FPUSH
    536  3373					      pha
    537  3373					      ELSE
    538  3373					      tax
    539  3373					      ENDIF
    540  3373					      lda	{1} + 1
    541  3373					      sbc	#>{2}
    542  3373					      IF	!FPUSH
    543  3373					      pha
    544  3373					      ELSE
    545  3373					      tay
    546  3373					      txa
    547  3373					      ENDIF
    548  3373					      ENDM		; @push
    549  3373
    550  3373					      MAC	pwordvar_pword_subword
    551  3373					      pintvar_pint_subint	{1}, {2}
    552  3373					      ENDM		; @push
    553  3373
    554  3373					      MAC	pdecimalvar_pdecimal_subdecimal
    555  3373					      IF	!USEIRQ
    556  3373					      sei
    557  3373					      ENDIF
    558  3373					      sed
    559  3373					      lda	{1}
    560  3373					      sec
    561  3373					      sbc	#{2}
    562  3373					      IF	!FPUSH
    563  3373					      pha
    564  3373					      ELSE
    565  3373					      tax
    566  3373					      ENDIF
    567  3373					      lda	{1} + 1
    568  3373					      sbc	#{3}
    569  3373					      IF	!FPUSH
    570  3373					      pha
    571  3373					      ELSE
    572  3373					      tay
    573  3373					      txa
    574  3373					      ENDIF
    575  3373					      cld
    576  3373					      IF	!USEIRQ
    577  3373					      cli
    578  3373					      ENDIF
    579  3373					      ENDM		; @push
    580  3373
    581  3373					      MAC	pintvar_pint_subint_plintvar
    582  3373					      lda	{1}
    583  3373					      sec
    584  3373					      sbc	#<{2}
    585  3373					      sta	{3}
    586  3373					      lda	{1} + 1
    587  3373					      sbc	#>{2}
    588  3373					      sta	{3} + 1
    589  3373					      ENDM
    590  3373
    591  3373					      MAC	pwordvar_pword_subword_plwordvar
    592  3373					      pintvar_pint_subint_plintvar	{1}, {2}, {3}
    593  3373					      ENDM
    594  3373
    595  3373					      MAC	pdecimalvar_pdecimal_subdecimal_pldecimalvar
    596  3373					      IF	!USEIRQ
    597  3373					      sei
    598  3373					      ENDIF
    599  3373					      sed
    600  3373					      lda	{1}
    601  3373					      sec
    602  3373					      sbc	#{2}
    603  3373					      sta	{4}
    604  3373					      lda	{1} + 1
    605  3373					      sbc	#{3}
    606  3373					      sta	{4} + 1
    607  3373					      cld
    608  3373					      IF	!USEIRQ
    609  3373					      cli
    610  3373					      ENDIF
    611  3373					      ENDM
    612  3373
    613  3373					      MAC	pintvar_pintvar_subint
    614  3373					      lda	{1}
    615  3373					      sec
    616  3373					      sbc	{2}
    617  3373					      IF	!FPUSH
    618  3373					      pha
    619  3373					      ELSE
    620  3373					      tax
    621  3373					      ENDIF
    622  3373					      lda	{1} + 1
    623  3373					      sbc	{2} + 1
    624  3373					      IF	!FPUSH
    625  3373					      pha
    626  3373					      ELSE
    627  3373					      tay
    628  3373					      txa
    629  3373					      ENDIF
    630  3373					      ENDM		; @push
    631  3373
    632  3373					      MAC	pwordvar_pwordvar_subword
    633  3373					      pintvar_pintvar_subint	{1}, {2}
    634  3373					      ENDM		; @push
    635  3373
    636  3373					      MAC	pdecimalvar_pdecimalvar_subdecimal
    637  3373					      IF	!USEIRQ
    638  3373					      sei
    639  3373					      ENDIF
    640  3373					      sed
    641  3373					      pintvar_pintvar_subint	{1}, {2}
    642  3373					      cld
    643  3373					      IF	!USEIRQ
    644  3373					      cli
    645  3373					      ENDIF
    646  3373					      ENDM		; @push
    647  3373
    648  3373					      MAC	pintvar_pintvar_subint_plintvar
    649  3373					      lda	{1}
    650  3373					      sec
    651  3373					      sbc	{2}
    652  3373					      sta	{3}
    653  3373					      lda	{1} + 1
    654  3373					      sbc	{2} + 1
    655  3373					      sta	{3} + 1
    656  3373					      ENDM
    657  3373
    658  3373					      MAC	pwordvar_pwordvar_subword_plwordvar
    659  3373					      pintvar_pintvar_subint_plintvar	{1}, {2}, {3}
    660  3373					      ENDM
    661  3373
    662  3373					      MAC	pdecimalvar_pdecimalvar_subdecimal_pldecimalvar
    663  3373					      IF	!USEIRQ
    664  3373					      sei
    665  3373					      ENDIF
    666  3373					      sed
    667  3373					      pintvar_pintvar_subint_plintvar	{1}, {2}, {3}
    668  3373					      cld
    669  3373					      IF	!USEIRQ
    670  3373					      cli
    671  3373					      ENDIF
    672  3373					      ENDM
    673  3373
    674  3373							; Array access
    675  3373
    676  3373					      MAC	pbytevar_pbytearrayfast
    677  3373					      ldx	{1}
    678  3373					      lda	{2},x
    679  3373					      IF	!FPUSH
    680  3373					      pha
    681  3373					      ENDIF
    682  3373					      ENDM		; @push
    683  3373
    684  3373							; Quick comparison of bytes
    685  3373
    686  3373					      MAC	pbyte_pbyte_cmpbyteeq
    687  3373					      lda	#{1}
    688  3373					      cmp	#{2}
    689  3373					      beq	.true
    690  3373					      pfalse
    691  3373					      beq	.end
    692  3373				   .true
    693  3373					      ptrue
    694  3373				   .end
    695  3373					      ENDM		; @push
    696  3373
    697  3373					      MAC	pbytevar_pbyte_cmpbyteeq
    698  3373					      lda	{1}
    699  3373					      cmp	#{2}
    700  3373					      beq	.true
    701  3373					      pfalse
    702  3373					      beq	.end
    703  3373				   .true
    704  3373					      ptrue
    705  3373				   .end
    706  3373					      ENDM		; @push
    707  3373
    708  3373					      MAC	pbyte_pbytevar_cmpbyteeq
    709  3373					      lda	#{1}
    710  3373					      cmp	{2}
    711  3373					      beq	.true
    712  3373					      pfalse
    713  3373					      beq	.end
    714  3373				   .true
    715  3373					      ptrue
    716  3373				   .end
    717  3373					      ENDM		; @push
    718  3373
    719  3373					      MAC	pbytevar_pbytevar_cmpbyteeq
    720  3373					      lda	{1}
    721  3373					      cmp	{2}
    722  3373					      beq	.true
    723  3373					      pfalse
    724  3373					      beq	.end
    725  3373				   .true
    726  3373					      ptrue
    727  3373				   .end
    728  3373					      ENDM		; @push
    729  3373
    730  3373					      MAC	pbyte_pbyte_cmpytebneq
    731  3373					      lda	#{1}
    732  3373					      cmp	#{2}
    733  3373					      bne	.true
    734  3373					      pfalse
    735  3373					      beq	.end
    736  3373				   .true
    737  3373					      ptrue
    738  3373				   .end
    739  3373					      ENDM		; @push
    740  3373
    741  3373					      MAC	pbytevar_pbyte_cmpytebneq
    742  3373					      lda	{1}
    743  3373					      cmp	#{2}
    744  3373					      bne	.true
    745  3373					      pfalse
    746  3373					      beq	.end
    747  3373				   .true
    748  3373					      ptrue
    749  3373				   .end
    750  3373					      ENDM		; @push
    751  3373
    752  3373					      MAC	pbyte_pbytevar_cmpytebneq
    753  3373					      lda	#{1}
    754  3373					      cmp	{2}
    755  3373					      bne	.true
    756  3373					      pfalse
    757  3373					      beq	.end
    758  3373				   .true
    759  3373					      ptrue
    760  3373				   .end
    761  3373					      ENDM		; @push
    762  3373
    763  3373					      MAC	pbytevar_pbytevar_cmpytebneq
    764  3373					      lda	{1}
    765  3373					      cmp	{2}
    766  3373					      bne	.true
    767  3373					      pfalse
    768  3373					      beq	.end
    769  3373				   .true
    770  3373					      ptrue
    771  3373				   .end
    772  3373					      ENDM		; @push
    773  3373
    774  3373					      MAC	pbyte_pbyte_cmpbytelt
    775  3373					      lda	#{1}
    776  3373					      cmp	#{2}
    777  3373					      bcs	.false
    778  3373					      ptrue
    779  3373					      bne	.end
    780  3373				   .false
    781  3373					      pfalse
    782  3373				   .end
    783  3373					      ENDM		; @push
    784  3373
    785  3373					      MAC	pbytevar_pbyte_cmpbytelt
    786  3373					      lda	{1}
    787  3373					      cmp	#{2}
    788  3373					      bcs	.false
    789  3373					      ptrue
    790  3373					      bne	.end
    791  3373				   .false
    792  3373					      pfalse
    793  3373				   .end
    794  3373					      ENDM		; @push
    795  3373
    796  3373					      MAC	pbyte_pbytevar_cmpbytelt
    797  3373					      lda	#{1}
    798  3373					      cmp	{2}
    799  3373					      bcs	.false
    800  3373					      ptrue
    801  3373					      bne	.end
    802  3373				   .false
    803  3373					      pfalse
    804  3373				   .end
    805  3373					      ENDM		; @push
    806  3373
    807  3373					      MAC	pbytevar_pbytevar_cmpbytelt
    808  3373					      lda	{1}
    809  3373					      cmp	{2}
    810  3373					      bcs	.false
    811  3373					      ptrue
    812  3373					      bne	.end
    813  3373				   .false
    814  3373					      pfalse
    815  3373				   .end
    816  3373					      ENDM		; @push
    817  3373
    818  3373					      MAC	pbyte_pbyte_cmpbytelte
    819  3373					      lda	#{2}
    820  3373					      cmp	#{1}
    821  3373					      bcs	.true
    822  3373					      pfalse
    823  3373					      beq	.end
    824  3373				   .true
    825  3373					      ptrue
    826  3373				   .end
    827  3373					      ENDM		; @push
    828  3373
    829  3373					      MAC	pbyte_pbytevar_cmpbytelte
    830  3373					      lda	{2}
    831  3373					      cmp	#{1}
    832  3373					      bcs	.true
    833  3373					      pfalse
    834  3373					      beq	.end
    835  3373				   .true
    836  3373					      ptrue
    837  3373				   .end
    838  3373					      ENDM		; @push
    839  3373
    840  3373					      MAC	pbytevar_pbyte_cmpbytelte
    841  3373					      lda	#{2}
    842  3373					      cmp	{1}
    843  3373					      bcs	.true
    844  3373					      pfalse
    845  3373					      beq	.end
    846  3373				   .true
    847  3373					      ptrue
    848  3373				   .end
    849  3373					      ENDM		; @push
    850  3373
    851  3373					      MAC	pbytevar_pbytevar_cmpbytelte
    852  3373					      lda	{2}
    853  3373					      cmp	{1}
    854  3373					      bcs	.true
    855  3373					      pfalse
    856  3373					      beq	.end
    857  3373				   .true
    858  3373					      ptrue
    859  3373				   .end
    860  3373					      ENDM		; @push
    861  3373
    862  3373					      MAC	pbyte_pbyte_cmpbbytegte
    863  3373					      lda	#{1}
    864  3373					      cmp	#{2}
    865  3373					      bcs	.true
    866  3373					      pfalse
    867  3373					      beq	.end
    868  3373				   .true
    869  3373					      ptrue
    870  3373				   .end
    871  3373					      ENDM		; @push
    872  3373
    873  3373					      MAC	pbytevar_pbyte_cmpbbytegte
    874  3373					      lda	{1}
    875  3373					      cmp	#{2}
    876  3373					      bcs	.true
    877  3373					      pfalse
    878  3373					      beq	.end
    879  3373				   .true
    880  3373					      ptrue
    881  3373				   .end
    882  3373					      ENDM		; @push
    883  3373
    884  3373					      MAC	pbyte_pbytevar_cmpbbytegte
    885  3373					      lda	#{1}
    886  3373					      cmp	{2}
    887  3373					      bcs	.true
    888  3373					      pfalse
    889  3373					      beq	.end
    890  3373				   .true
    891  3373					      ptrue
    892  3373				   .end
    893  3373					      ENDM		; @push
    894  3373
    895  3373					      MAC	pbytevar_pbytevar_cmpbytegte
    896  3373					      lda	{1}
    897  3373					      cmp	{2}
    898  3373					      bcs	.true
    899  3373					      pfalse
    900  3373					      beq	.end
    901  3373				   .true
    902  3373					      ptrue
    903  3373				   .end
    904  3373					      ENDM		; @push
    905  3373
    906  3373					      MAC	pbyte_pbyte_cmpbytegt
    907  3373					      lda	#{2}
    908  3373					      cmp	#{1}
    909  3373					      bcc	.true
    910  3373					      pfalse
    911  3373					      beq	.end
    912  3373				   .true
    913  3373					      ptrue
    914  3373				   .end
    915  3373					      ENDM		; @push
    916  3373
    917  3373					      MAC	pbyte_pbytevar_cmpbytegt
    918  3373					      lda	{2}
    919  3373					      cmp	#{1}
    920  3373					      bcc	.true
    921  3373					      pfalse
    922  3373					      beq	.end
    923  3373				   .true
    924  3373					      ptrue
    925  3373				   .end
    926  3373					      ENDM		; @push
    927  3373
    928  3373					      MAC	pbytevar_pbyte_cmpbytegt
    929  3373					      lda	#{2}
    930  3373					      cmp	{1}
    931  3373					      bcc	.true
    932  3373					      pfalse
    933  3373					      beq	.end
    934  3373				   .true
    935  3373					      ptrue
    936  3373				   .end
    937  3373					      ENDM		; @push
    938  3373
    939  3373					      MAC	pbytevar_pbytevar_cmpbytegt
    940  3373					      lda	{2}
    941  3373					      cmp	{1}
    942  3373					      bcc	.true
    943  3373					      pfalse
    944  3373					      beq	.end
    945  3373				   .true
    946  3373					      ptrue
    947  3373				   .end
    948  3373					      ENDM		; @push
    949  3373
    950  3373							; Quick comparison and branching
    951  3373
    952  3373					      MAC	pbyte_pbyte_cmpbyteeq_cond_stmt
    953  3373					      lda	#{1}
    954  3373					      cmp	#{2}
    955  3373					      beq	.true
    956  3373					      IF	{4} > 0 && {2} < $10000
    957  3373					      jmp	{4}
    958  3373					      ELSE
    959  3373					      jmp	{3}
    960  3373					      ENDIF
    961  3373				   .true
    962  3373					      ENDM
    963  3373
    964  3373					      MAC	pbytevar_pbyte_cmpbyteeq_cond_stmt
    965  3373					      lda	{1}
    966  3373					      cmp	#{2}
    967  3373					      beq	.true
    968  3373					      IF	{4} > 0 && {2} < $10000
    969  3373					      jmp	{4}
    970  3373					      ELSE
    971  3373					      jmp	{3}
    972  3373					      ENDIF
    973  3373				   .true
    974  3373					      ENDM
    975  3373
    976  3373					      MAC	pbyte_pbytevar_cmpbyteeq_cond_stmt
    977  3373					      lda	#{1}
    978  3373					      cmp	{2}
    979  3373					      beq	.true
    980  3373					      IF	{4} > 0 && {2} < $10000
    981  3373					      jmp	{4}
    982  3373					      ELSE
    983  3373					      jmp	{3}
    984  3373					      ENDIF
    985  3373				   .true
    986  3373					      ENDM
    987  3373
    988  3373					      MAC	pbytevar_pbytevar_cmpbyteeq_cond_stmt
    989  3373					      lda	{1}
    990  3373					      cmp	{2}
    991  3373					      beq	.true
    992  3373					      IF	{4} > 0 && {2} < $10000
    993  3373					      jmp	{4}
    994  3373					      ELSE
    995  3373					      jmp	{3}
    996  3373					      ENDIF
    997  3373				   .true
    998  3373					      ENDM
    999  3373
   1000  3373					      MAC	pbyte_pbyte_cmpytebneq_cond_stmt
   1001  3373					      lda	#{1}
   1002  3373					      cmp	#{2}
   1003  3373					      bne	.true
   1004  3373					      IF	{4} > 0 && {2} < $10000
   1005  3373					      jmp	{4}
   1006  3373					      ELSE
   1007  3373					      jmp	{3}
   1008  3373					      ENDIF
   1009  3373				   .true
   1010  3373					      ENDM
   1011  3373
   1012  3373					      MAC	pbytevar_pbyte_cmpytebneq_cond_stmt
   1013  3373					      lda	{1}
   1014  3373					      cmp	#{2}
   1015  3373					      bne	.true
   1016  3373					      IF	{4} > 0 && {2} < $10000
   1017  3373					      jmp	{4}
   1018  3373					      ELSE
   1019  3373					      jmp	{3}
   1020  3373					      ENDIF
   1021  3373				   .true
   1022  3373					      ENDM
   1023  3373
   1024  3373					      MAC	pbyte_pbytevar_cmpytebneq_cond_stmt
   1025  3373					      lda	#{1}
   1026  3373					      cmp	{2}
   1027  3373					      bne	.true
   1028  3373					      IF	{4} > 0 && {2} < $10000
   1029  3373					      jmp	{4}
   1030  3373					      ELSE
   1031  3373					      jmp	{3}
   1032  3373					      ENDIF
   1033  3373				   .true
   1034  3373					      ENDM
   1035  3373
   1036  3373					      MAC	pbytevar_pbytevar_cmpytebneq_cond_stmt
   1037  3373					      lda	{1}
   1038  3373					      cmp	{2}
   1039  3373					      bne	.true
   1040  3373					      IF	{4} > 0 && {2} < $10000
   1041  3373					      jmp	{4}
   1042  3373					      ELSE
   1043  3373					      jmp	{3}
   1044  3373					      ENDIF
   1045  3373				   .true
   1046  3373					      ENDM
   1047  3373
   1048  3373					      MAC	pbyte_pbyte_cmpbytelt_cond_stmt
   1049  3373					      lda	#{1}
   1050  3373					      cmp	#{2}
   1051  3373					      bcc	.true
   1052  3373					      IF	{4} > 0 && {2} < $10000
   1053  3373					      jmp	{4}
   1054  3373					      ELSE
   1055  3373					      jmp	{3}
   1056  3373					      ENDIF
   1057  3373				   .true
   1058  3373					      ENDM
   1059  3373
   1060  3373					      MAC	pbytevar_pbyte_cmpbytelt_cond_stmt
   1061  3373					      lda	{1}
   1062  3373					      cmp	#{2}
   1063  3373					      bcc	.true
   1064  3373					      IF	{4} > 0 && {2} < $10000
   1065  3373					      jmp	{4}
   1066  3373					      ELSE
   1067  3373					      jmp	{3}
   1068  3373					      ENDIF
   1069  3373				   .true
   1070  3373					      ENDM
   1071  3373
   1072  3373					      MAC	pbyte_pbytevar_cmpbytelt_cond_stmt
   1073  3373					      lda	#{1}
   1074  3373					      cmp	{2}
   1075  3373					      bcc	.true
   1076  3373					      IF	{4} > 0 && {2} < $10000
   1077  3373					      jmp	{4}
   1078  3373					      ELSE
   1079  3373					      jmp	{3}
   1080  3373					      ENDIF
   1081  3373				   .true
   1082  3373					      ENDM
   1083  3373
   1084  3373					      MAC	pbytevar_pbytevar_cmpbytelt_cond_stmt
   1085  3373					      lda	{1}
   1086  3373					      cmp	{2}
   1087  3373					      bcc	.true
   1088  3373					      IF	{4} > 0 && {2} < $10000
   1089  3373					      jmp	{4}
   1090  3373					      ELSE
   1091  3373					      jmp	{3}
   1092  3373					      ENDIF
   1093  3373				   .true
   1094  3373					      ENDM
   1095  3373
   1096  3373					      MAC	pbyte_pbyte_cmpbytelte_cond_stmt
   1097  3373					      lda	#{2}
   1098  3373					      cmp	#{1}
   1099  3373					      bcs	.true
   1100  3373					      IF	{4} > 0 && {2} < $10000
   1101  3373					      jmp	{4}
   1102  3373					      ELSE
   1103  3373					      jmp	{3}
   1104  3373					      ENDIF
   1105  3373				   .true
   1106  3373					      ENDM
   1107  3373
   1108  3373					      MAC	pbyte_pbytevar_cmpbytelte_cond_stmt
   1109  3373					      lda	{2}
   1110  3373					      cmp	#{1}
   1111  3373					      bcs	.true
   1112  3373					      IF	{4} > 0 && {2} < $10000
   1113  3373					      jmp	{4}
   1114  3373					      ELSE
   1115  3373					      jmp	{3}
   1116  3373					      ENDIF
   1117  3373				   .true
   1118  3373					      ENDM
   1119  3373
   1120  3373					      MAC	pbytevar_pbyte_cmpbytelte_cond_stmt
   1121  3373					      lda	#{2}
   1122  3373					      cmp	{1}
   1123  3373					      bcs	.true
   1124  3373					      IF	{4} > 0 && {2} < $10000
   1125  3373					      jmp	{4}
   1126  3373					      ELSE
   1127  3373					      jmp	{3}
   1128  3373					      ENDIF
   1129  3373				   .true
   1130  3373					      ENDM
   1131  3373
   1132  3373					      MAC	pbytevar_pbytevar_cmpbytelte_cond_stmt
   1133  3373					      lda	{2}
   1134  3373					      cmp	{1}
   1135  3373					      bcs	.true
   1136  3373					      IF	{4} > 0 && {2} < $10000
   1137  3373					      jmp	{4}
   1138  3373					      ELSE
   1139  3373					      jmp	{3}
   1140  3373					      ENDIF
   1141  3373				   .true
   1142  3373					      ENDM
   1143  3373
   1144  3373					      MAC	pbyte_pbyte_cmpbbytegte_cond_stmt
   1145  3373					      lda	#{1}
   1146  3373					      cmp	#{2}
   1147  3373					      bcs	.true
   1148  3373					      IF	{4} > 0 && {2} < $10000
   1149  3373					      jmp	{4}
   1150  3373					      ELSE
   1151  3373					      jmp	{3}
   1152  3373					      ENDIF
   1153  3373				   .true
   1154  3373					      ENDM
   1155  3373
   1156  3373					      MAC	pbytevar_pbyte_cmpbbytegte_cond_stmt
   1157  3373					      lda	{1}
   1158  3373					      cmp	#{2}
   1159  3373					      bcs	.true
   1160  3373					      IF	{4} > 0 && {2} < $10000
   1161  3373					      jmp	{4}
   1162  3373					      ELSE
   1163  3373					      jmp	{3}
   1164  3373					      ENDIF
   1165  3373				   .true
   1166  3373					      ENDM
   1167  3373
   1168  3373					      MAC	pbyte_pbytevar_cmpbbytegte_cond_stmt
   1169  3373					      lda	#{1}
   1170  3373					      cmp	{2}
   1171  3373					      bcs	.true
   1172  3373					      IF	{4} > 0 && {2} < $10000
   1173  3373					      jmp	{4}
   1174  3373					      ELSE
   1175  3373					      jmp	{3}
   1176  3373					      ENDIF
   1177  3373				   .true
   1178  3373					      ENDM
   1179  3373
   1180  3373					      MAC	pbytevar_pbytevar_cmpbytegte_cond_stmt
   1181  3373					      lda	{1}
   1182  3373					      cmp	{2}
   1183  3373					      bcs	.true
   1184  3373					      IF	{4} > 0 && {2} < $10000
   1185  3373					      jmp	{4}
   1186  3373					      ELSE
   1187  3373					      jmp	{3}
   1188  3373					      ENDIF
   1189  3373				   .true
   1190  3373					      ENDM
   1191  3373
   1192  3373					      MAC	pbyte_pbyte_cmpbytegt_cond_stmt
   1193  3373					      lda	#{2}
   1194  3373					      cmp	#{1}
   1195  3373					      bcc	.true
   1196  3373					      IF	{4} > 0 && {2} < $10000
   1197  3373					      jmp	{4}
   1198  3373					      ELSE
   1199  3373					      jmp	{3}
   1200  3373					      ENDIF
   1201  3373				   .true
   1202  3373					      ENDM
   1203  3373
   1204  3373					      MAC	pbyte_pbytevar_cmpbytegt_cond_stmt
   1205  3373					      lda	{2}
   1206  3373					      cmp	#{1}
   1207  3373					      bcc	.true
   1208  3373					      IF	{4} > 0 && {2} < $10000
   1209  3373					      jmp	{4}
   1210  3373					      ELSE
   1211  3373					      jmp	{3}
   1212  3373					      ENDIF
   1213  3373				   .true
   1214  3373					      ENDM
   1215  3373
   1216  3373					      MAC	pbytevar_pbyte_cmpbytegt_cond_stmt
   1217  3373					      lda	#{2}
   1218  3373					      cmp	{1}
   1219  3373					      bcc	.true
   1220  3373					      IF	{4} > 0 && {2} < $10000
   1221  3373					      jmp	{4}
   1222  3373					      ELSE
   1223  3373					      jmp	{3}
   1224  3373					      ENDIF
   1225  3373				   .true
   1226  3373					      ENDM
   1227  3373
   1228  3373					      MAC	pbytevar_pbytevar_cmpbytegt_cond_stmt
   1229  3373					      lda	{2}
   1230  3373					      cmp	{1}
   1231  3373					      bcc	.true
   1232  3373					      IF	{4} > 0 && {2} < $10000
   1233  3373					      jmp	{4}
   1234  3373					      ELSE
   1235  3373					      jmp	{3}
   1236  3373					      ENDIF
   1237  3373				   .true
   1238  3373					      ENDM
------- FILE xcb3lib.asm
------- FILE C:\Users\PC\AppData\Local\Temp\xcbtmp_ABF8A21B.asm
   2194  3373
   2195  3373
   2196  3373
   2197  3373				   data_start
   2198  3373		       01 93	   _S1	      HEX	01 93
   2199  3375		       17 3e 3e 3e*_S2	      HEX	17 3E 3E 3E 3E 3E 3E 3E 3E 3E 3E 3E 3E 3E 3E 3E 3E
   2200  3386		       3e 3e 3e 3e*	      HEX	3E 3E 3E 3E 3E 9D 3E
   2201  338d		       01 93	   _S3	      HEX	01 93
   2202  338f		       01 93	   _S4	      HEX	01 93
   2203  3391		       01 13	   _S5	      HEX	01 13
   2204  3393		       15 3e 38 38*_S6	      HEX	15 3E 38 38 38 38 38 38 38 38 38 38 38 38 38 38 38
   2205  33a4		       38 38 38 38*	      HEX	38 38 38 38 38
   2206  33a9		       04 11 11 11*_S7	      HEX	04 11 11 11 11
   2207  33ae		       01 13	   _S8	      HEX	01 13
   2208  33b0		       01 13	   _S9	      HEX	01 13
   2209  33b2				   L_src2.bvector
   2210  33b2		       00 01 15 16*	      DC.B	$00,$01,$15,$16,$17,$18,$2A,$2B
   2211  33ba		       2c 2d 2e 2f	      DC.B	$2C,$2D,$2E,$2F
   2212  33be				   L_src2.chardata
   2213  33be		       ff ff 99 66*	      DC.B	$FF,$FF,$99,$66,$66,$99,$FF,$FF
   2214  33c6		       c3 ff ff c3*	      DC.B	$C3,$FF,$FF,$C3,$C3,$FF,$FF,$C3
   2215  33ce		       3c 3c 19 ff*	      DC.B	$3C,$3C,$19,$FF,$BC
   2216  33d3
   2217  33d3		       3c 24 e7 03*	      DC.B	$3C,$24,$E7,$03,$04,$18,$18,$3C
   2218  33db		       7e 7e 3c 3c*	      DC.B	$7E,$7E,$3C,$3C,$42,$A5,$99,$99
   2219  33e3		       a5 42 3c 00*	      DC.B	$A5,$42,$3C,$00,$18,$24,$7E,$7E
   2220  33eb		       7e		      DC.B	$7E
   2221  33ec
   2222  33ec		       7e 00 00 00*	      DC.B	$7E,$00,$00,$00,$00,$00,$00,$00
   2223  33f4		       00 00 00 00*	      DC.B	$00,$00,$00,$00,$00,$00,$00,$00
   2224  33fc		       00 00		      DC.B	$00,$00
   2225  33fe				   L_src2.lmdata
   2226  33fe		       a9 00 85 01*	      DC.B	$A9,$00,$85,$01,$A9,$FF,$8D,$22
   2227  3406		       91 a9 20 2c*	      DC.B	$91,$A9,$20,$2C,$1F,$91,$D0,$05
   2228  340e		       a9 01 85 01*	      DC.B	$A9,$01,$85,$01,$60,$A9,$08,$2C
   2229  3416
   2230  3416		       1f 91 d0 05*	      DC.B	$1F,$91,$D0,$05,$A9,$02,$85,$01
   2231  341e		       60 a9 10 2c*	      DC.B	$60,$A9,$10,$2C,$1F,$91,$D0,$05
   2232  3426		       a9 03 85 01*	      DC.B	$A9,$03,$85,$01,$60,$A9,$04,$2C
   2233  342e		       1f		      DC.B	$1F
   2234  342f
   2235  342f		       91 d0 03 85*	      DC.B	$91,$D0,$03,$85,$01,$60,$A9,$7F
   2236  3437		       8d 22 91 a9*	      DC.B	$8D,$22,$91,$A9,$80,$2C,$20,$91
   2237  343f		       d0 04 a9 05*	      DC.B	$D0,$04,$A9,$05,$85,$01,$60
   2238  3446				   vars_start
   2239 U34b4 ????				      SEG.U	"VARIABLES"
   2240 U3446					      ORG	vars_start
   2241 U3446		       00 00	   V_src2.get_random_direction_.get_random_direction DS.B	2
   2242 U3448		       00 00	   V_src2.random_word_word.limit DS.B	2
   2243 U344a		       00 00	   V_src2.random_word_word.mask DS.B	2
   2244 U344c		       00 00	   V_src2.random_word_word.random DS.B	2
   2245 U344e		       00	   V_src2.playermove_.playermove DS.B	1
   2246 U344f		       00	   V_src2.barrel_move_.barrel_move DS.B	1
   2247 U3450		       00 00	   V_src2.pos_man DS.B	2
   2248 U3452		       00 00	   V_src2.dir_man DS.B	2
   2249 U3452		       33 b2	   V_src2.bstack EQU	L_src2.bvector
   2250 U3454		       00 00	   V_src2.pos_barrel DS.B	2
   2251 U3456		       00 00	   V_src2.dir_barrel DS.B	2
   2252 U3458		       00	   V_src2.cbarrel DS.B	1
   2253 U3459		       00 00	   V_src2.score DS.B	2
   2254 U345b		       00	   V_src2.nbags DS.B	1
   2255 U345c		       00	   V_src2.level DS.B	1
   2256 U345d		       00 00	   V_src2.lives DS.B	2
   2257 U345f		       00 00	   V_src2.n_bonus DS.B	2
   2258 U3461		       00	   V_src2.holes DS.B	1
   2259 U3462		       00 00	   V_src2.bonus_multiplier DS.B	2
   2260 U3464		       00 00 00 00 V_src2.divert_chance DS.B	4
   2261 U3468		       00 00 00 00*V_src2.d   DS.B	5
   2262 U346d		       00 00	   V_src2.n   DS.B	2
   2263 U346f		       00	   V_src2.w   DS.B	1
   2264 U3470		       00	   V_src2.m   DS.B	1
   2265 U3471		       00	   V_src2.o   DS.B	1
   2266 U3472		       00	   V_src2.t   DS.B	1
   2267 U3473		       00	   V_src2.freq DS.B	1
   2268 U3474		       00	   V_src2.e   DS.B	1
   2269 U3475		       00 00 00 00*V_src2.a@  DS.B	25
   2270 U348e		       00 00	   X_src2.forlim9 DS.B	2
   2271 U3490		       00 00	   V_src2.draw_level_.r DS.B	2
   2272 U3492		       00 00 00 00*V_src2.draw_level_.b@ DS.B	23
   2273 U34a9		       00 00	   V_src2.draw_level_.forstep24 DS.B	2
   2274 U34ab		       00	   V_src2.draw_level_.forlim27 DS.B	1
   2275 U34ac		       00	   V_src2.draw_level_.forstep27 DS.B	1
   2276 U34ad		       00	   V_src2.draw_level_.forlim30 DS.B	1
   2277 U34ae		       00 00	   V_src2.draw_level_.forstep34 DS.B	2
   2278 U34b0		       00 00	   V_src2.draw_level_.forstep35 DS.B	2
   2279 U34b2		       00 00	   V_src2.random_word_word.r DS.B	2
   2280 U34b4				   vars_end
